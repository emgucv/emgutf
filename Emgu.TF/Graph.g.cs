 
//----------------------------------------------------------------------------
//  Copyright (C) 2004-2024 by EMGU Corporation. All rights reserved.       
//  This code is automatically generated by a program from Tensorflow 2.17.0.  
//  Please do not modify manually.
//----------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Text;
using Emgu.TF.Util;
using System.Runtime.InteropServices;

namespace Emgu.TF
{
   public partial class Graph : UnmanagedObject
   {
              // Skipped function __MklDummyConv2DBackpropFilterWithBias
        // Skipped function __MklDummyConv2DWithBias
        // Skipped function __MklDummyPadWithConv2D
        // Skipped function __MklDummyPadWithFusedConv2D
        // Skipped function _Arg
        // Skipped function _ArrayToList
        // Skipped function _ConfigureDistributedTPU
        // Skipped function _DeviceArg
        // Skipped function _DeviceRetval
        // Skipped function _DisconnectHostFromDistributedTPUSystem
        // Skipped function _EagerConst
        // Skipped function _FusedBatchNormEx
        // Skipped function _FusedBatchNormGradEx
        // Skipped function _FusedConv2D
        // Skipped function _FusedConv3D
        // Skipped function _FusedDepthwiseConv2dNative
        // Skipped function _FusedMatMul
        // Skipped function _FusedQuantizedConv2D
        // Skipped function _FusedQuantizedDepthwiseConv2D
        // Skipped function _HostCast
        // Skipped function _HostRecv
        // Skipped function _HostSend
        // Skipped function _If
        // Skipped function _InitializeHostForDistributedTPU
        // Skipped function _ListToArray
        // Skipped function _MklAvgPool
        // Skipped function _MklAvgPool3D
        // Skipped function _MklAvgPool3DGrad
        // Skipped function _MklAvgPoolGrad
        // Skipped function _MklBatchMatMul
        // Skipped function _MklBatchMatMulV2
        // Skipped function _MklConcat
        // Skipped function _MklConcatV2
        // Skipped function _MklConjugateTranspose
        // Skipped function _MklConv2D
        // Skipped function _MklConv2DBackpropFilter
        // Skipped function _MklConv2DBackpropFilterWithBias
        // Skipped function _MklConv2DBackpropInput
        // Skipped function _MklConv2DWithBias
        // Skipped function _MklConv3D
        // Skipped function _MklConv3DBackpropFilterV2
        // Skipped function _MklConv3DBackpropInputV2
        // Skipped function _MklDepthwiseConv2dNative
        // Skipped function _MklDepthwiseConv2dNativeBackpropFilter
        // Skipped function _MklDepthwiseConv2dNativeBackpropInput
        // Skipped function _MklDequantize
        // Skipped function _MklEinsum
        // Skipped function _MklElu
        // Skipped function _MklEluGrad
        // Skipped function _MklFusedBatchMatMulV2
        // Skipped function _MklFusedBatchNorm
        // Skipped function _MklFusedBatchNormEx
        // Skipped function _MklFusedBatchNormGrad
        // Skipped function _MklFusedBatchNormGradV2
        // Skipped function _MklFusedBatchNormGradV3
        // Skipped function _MklFusedBatchNormV2
        // Skipped function _MklFusedBatchNormV3
        // Skipped function _MklFusedConv2D
        // Skipped function _MklFusedDepthwiseConv2dNative
        // Skipped function _MklFusedInstanceNorm
        // Skipped function _MklFusedMatMul
        // Skipped function _MklFusedMish
        // Skipped function _MklLayerNorm
        // Skipped function _MklLeakyRelu
        // Skipped function _MklLeakyReluGrad
        // Skipped function _MklMatMul
        // Skipped function _MklMaxPool
        // Skipped function _MklMaxPool3D
        // Skipped function _MklMaxPool3DGrad
        // Skipped function _MklMaxPoolGrad
        // Skipped function _MklNativeAvgPool
        // Skipped function _MklNativeAvgPool3D
        // Skipped function _MklNativeAvgPool3DGrad
        // Skipped function _MklNativeAvgPoolGrad
        // Skipped function _MklNativeConv2D
        // Skipped function _MklNativeConv2DBackpropFilter
        // Skipped function _MklNativeConv2DBackpropFilterWithBias
        // Skipped function _MklNativeConv2DBackpropInput
        // Skipped function _MklNativeConv2DWithBias
        // Skipped function _MklNativeConv3D
        // Skipped function _MklNativeConv3DBackpropFilterV2
        // Skipped function _MklNativeConv3DBackpropInputV2
        // Skipped function _MklNativeDepthwiseConv2dNative
        // Skipped function _MklNativeDepthwiseConv2dNativeBackpropFilter
        // Skipped function _MklNativeDepthwiseConv2dNativeBackpropInput
        // Skipped function _MklNativeFusedBatchNorm
        // Skipped function _MklNativeFusedBatchNormEx
        // Skipped function _MklNativeFusedBatchNormGrad
        // Skipped function _MklNativeFusedBatchNormGradV2
        // Skipped function _MklNativeFusedBatchNormGradV3
        // Skipped function _MklNativeFusedBatchNormV2
        // Skipped function _MklNativeFusedBatchNormV3
        // Skipped function _MklNativeFusedConv2D
        // Skipped function _MklNativeFusedConv3D
        // Skipped function _MklNativeFusedDepthwiseConv2dNative
        // Skipped function _MklNativeFusedMatMul
        // Skipped function _MklNativeMaxPool
        // Skipped function _MklNativeMaxPool3D
        // Skipped function _MklNativeMaxPool3DGrad
        // Skipped function _MklNativeMaxPoolGrad
        // Skipped function _MklNativePadWithConv2D
        // Skipped function _MklNativePadWithFusedConv2D
        // Skipped function _MklNativeSparseMatrixMatMul
        // Skipped function _MklPadWithConv2D
        // Skipped function _MklPadWithFusedConv2D
        // Skipped function _MklQuantizedAvgPool
        // Skipped function _MklQuantizedConcatV2
        // Skipped function _MklQuantizedConv2D
        // Skipped function _MklQuantizedConv2DAndRelu
        // Skipped function _MklQuantizedConv2DAndReluAndRequantize
        // Skipped function _MklQuantizedConv2DAndRequantize
        // Skipped function _MklQuantizedConv2DPerChannel
        // Skipped function _MklQuantizedConv2DWithBias
        // Skipped function _MklQuantizedConv2DWithBiasAndRelu
        // Skipped function _MklQuantizedConv2DWithBiasAndReluAndRequantize
        // Skipped function _MklQuantizedConv2DWithBiasAndRequantize
        // Skipped function _MklQuantizedConv2DWithBiasSignedSumAndReluAndRequantize
        // Skipped function _MklQuantizedConv2DWithBiasSumAndRelu
        // Skipped function _MklQuantizedConv2DWithBiasSumAndReluAndRequantize
        // Skipped function _MklQuantizedDepthwiseConv2D
        // Skipped function _MklQuantizedDepthwiseConv2DWithBias
        // Skipped function _MklQuantizedDepthwiseConv2DWithBiasAndRelu
        // Skipped function _MklQuantizedDepthwiseConv2DWithBiasAndReluAndRequantize
        // Skipped function _MklQuantizedMatMulWithBias
        // Skipped function _MklQuantizedMatMulWithBiasAndDequantize
        // Skipped function _MklQuantizedMatMulWithBiasAndRelu
        // Skipped function _MklQuantizedMatMulWithBiasAndReluAndRequantize
        // Skipped function _MklQuantizedMatMulWithBiasAndRequantize
        // Skipped function _MklQuantizedMaxPool
        // Skipped function _MklQuantizeV2
        // Skipped function _MklRelu
        // Skipped function _MklRelu6
        // Skipped function _MklRelu6Grad
        // Skipped function _MklReluGrad
        // Skipped function _MklSoftmax
        // Skipped function _MklSwish
        // Skipped function _MklTanh
        // Skipped function _MklTanhGrad
        // Skipped function _MklTranspose
        // Skipped function _NcclBroadcastRecv
        // Skipped function _NcclBroadcastSend
        // Skipped function _NcclReduceRecv
        // Skipped function _NcclReduceSend
        // Skipped function _ParallelConcatStart
        // Skipped function _ParallelConcatUpdate
        // Skipped function _QuantizedMatMul
        // Skipped function _QuantizedMaxPool3D
        // Skipped function _ReadVariablesOp
        // Skipped function _Recv
        // Skipped function _Retval
        // Skipped function _ScopedAllocator
        // Skipped function _ScopedAllocatorConcat
        // Skipped function _ScopedAllocatorSplit
        // Skipped function _Send
        // Skipped function _SetGlobalTPUArray
        // Skipped function _ShutdownDistributedTPU
        // Skipped function _SwitchN
        // Skipped function _TensorToHashBucketFast
        // Skipped function _TPUCompileMlir
        // Skipped function _TPUReplicate
        // Skipped function _UnaryOpsComposition
        // Skipped function _VarHandlesOp
        // Skipped function _WaitForDistributedTPU
        // Skipped function _While
        // Skipped function _XlaCompile
        // Skipped function _XlaCompileMlirPlaceholderProgramKey
        // Skipped function _XlaHostComputeMlir
        // Skipped function _XlaMerge
        // Skipped function _XlaRecvAtHost
        // Skipped function _XlaRecvAtHostV2
        // Skipped function _XlaRun
        // Skipped function _XlaSendFromHost
        // Skipped function _XlaSendFromHostV2

        /// <summary>
        /// Abort
        /// </summary>
        /// <param name="error_msg">error msg</param>
        /// <param name="exit_without_error">exit without error</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation Abort(string error_msg = null, bool exit_without_error = false, String opName = "Abort") 
        {
            OperationDescription desc = NewOperation("Abort", opName);
            if (error_msg != null)
                 desc.SetAttr("error_msg", error_msg);
            if (exit_without_error != false)
                desc.SetAttr("exit_without_error", exit_without_error);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Abs
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Abs(Output x, String opName = "Abs") 
        {
            OperationDescription desc = NewOperation("Abs", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AccumulateNV2
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="shape">shape</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] sum(type: DtInvalid).
        /// </returns>
        public Operation AccumulateNV2(Output inputs, long[] shape, String opName = "AccumulateNV2") 
        {
            OperationDescription desc = NewOperation("AccumulateNV2", opName);
            desc.AddInput(inputs);
            desc.SetAttrShape("shape", shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AccumulatorApplyGradient
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="local_step">Input to the operation. </param>
        /// <param name="gradient">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation AccumulatorApplyGradient(Output handle, Output local_step, Output gradient, String opName = "AccumulatorApplyGradient") 
        {
            OperationDescription desc = NewOperation("AccumulatorApplyGradient", opName);
            desc.AddInput(handle);
            desc.AddInput(local_step);
            desc.AddInput(gradient);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AccumulatorNumAccumulated
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] num_accumulated(type: DtInt32).
        /// </returns>
        public Operation AccumulatorNumAccumulated(Output handle, String opName = "AccumulatorNumAccumulated") 
        {
            OperationDescription desc = NewOperation("AccumulatorNumAccumulated", opName);
            desc.AddInput(handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AccumulatorSetGlobalStep
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="new_global_step">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation AccumulatorSetGlobalStep(Output handle, Output new_global_step, String opName = "AccumulatorSetGlobalStep") 
        {
            OperationDescription desc = NewOperation("AccumulatorSetGlobalStep", opName);
            desc.AddInput(handle);
            desc.AddInput(new_global_step);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AccumulatorTakeGradient
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="num_required">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] average(type: DtInvalid).
        /// </returns>
        public Operation AccumulatorTakeGradient(Output handle, Output num_required, DataType dtype, String opName = "AccumulatorTakeGradient") 
        {
            OperationDescription desc = NewOperation("AccumulatorTakeGradient", opName);
            desc.AddInput(handle);
            desc.AddInput(num_required);
            desc.SetAttr("dtype", dtype);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Acos
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Acos(Output x, String opName = "Acos") 
        {
            OperationDescription desc = NewOperation("Acos", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Acosh
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Acosh(Output x, String opName = "Acosh") 
        {
            OperationDescription desc = NewOperation("Acosh", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Add
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation Add(Output x, Output y, String opName = "Add") 
        {
            OperationDescription desc = NewOperation("Add", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AddManySparseToTensorsMap
        /// </summary>
        /// <param name="sparse_indices">Input to the operation. </param>
        /// <param name="sparse_values">Input to the operation. </param>
        /// <param name="sparse_shape">Input to the operation. </param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] sparse_handles(type: DtInt64).
        /// </returns>
        public Operation AddManySparseToTensorsMap(Output sparse_indices, Output sparse_values, Output sparse_shape, string container = null, string shared_name = null, String opName = "AddManySparseToTensorsMap") 
        {
            OperationDescription desc = NewOperation("AddManySparseToTensorsMap", opName);
            desc.AddInput(sparse_indices);
            desc.AddInput(sparse_values);
            desc.AddInput(sparse_shape);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AddN
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] sum(type: DtInvalid).
        /// </returns>
        public Operation AddN(Output inputs, String opName = "AddN") 
        {
            OperationDescription desc = NewOperation("AddN", opName);
            desc.AddInput(inputs);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AddSparseToTensorsMap
        /// </summary>
        /// <param name="sparse_indices">Input to the operation. </param>
        /// <param name="sparse_values">Input to the operation. </param>
        /// <param name="sparse_shape">Input to the operation. </param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] sparse_handle(type: DtInt64).
        /// </returns>
        public Operation AddSparseToTensorsMap(Output sparse_indices, Output sparse_values, Output sparse_shape, string container = null, string shared_name = null, String opName = "AddSparseToTensorsMap") 
        {
            OperationDescription desc = NewOperation("AddSparseToTensorsMap", opName);
            desc.AddInput(sparse_indices);
            desc.AddInput(sparse_values);
            desc.AddInput(sparse_shape);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AddV2
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation AddV2(Output x, Output y, String opName = "AddV2") 
        {
            OperationDescription desc = NewOperation("AddV2", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AdjustContrast
        /// </summary>
        /// <param name="images">Input to the operation. </param>
        /// <param name="contrast_factor">Input to the operation. </param>
        /// <param name="min_value">Input to the operation. </param>
        /// <param name="max_value">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtFloat).
        /// </returns>
        public Operation AdjustContrast(Output images, Output contrast_factor, Output min_value, Output max_value, String opName = "AdjustContrast") 
        {
            OperationDescription desc = NewOperation("AdjustContrast", opName);
            desc.AddInput(images);
            desc.AddInput(contrast_factor);
            desc.AddInput(min_value);
            desc.AddInput(max_value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AdjustContrastv2
        /// </summary>
        /// <param name="images">Input to the operation. </param>
        /// <param name="contrast_factor">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation AdjustContrastv2(Output images, Output contrast_factor, String opName = "AdjustContrastv2") 
        {
            OperationDescription desc = NewOperation("AdjustContrastv2", opName);
            desc.AddInput(images);
            desc.AddInput(contrast_factor);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AdjustHue
        /// </summary>
        /// <param name="images">Input to the operation. </param>
        /// <param name="delta">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation AdjustHue(Output images, Output delta, String opName = "AdjustHue") 
        {
            OperationDescription desc = NewOperation("AdjustHue", opName);
            desc.AddInput(images);
            desc.AddInput(delta);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AdjustSaturation
        /// </summary>
        /// <param name="images">Input to the operation. </param>
        /// <param name="scale">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation AdjustSaturation(Output images, Output scale, String opName = "AdjustSaturation") 
        {
            OperationDescription desc = NewOperation("AdjustSaturation", opName);
            desc.AddInput(images);
            desc.AddInput(scale);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// All
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="reduction_indices">Input to the operation. </param>
        /// <param name="keep_dims">keep dims</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtBool).
        /// </returns>
        public Operation All(Output input, Output reduction_indices, bool keep_dims = false, String opName = "All") 
        {
            OperationDescription desc = NewOperation("All", opName);
            desc.AddInput(input);
            desc.AddInput(reduction_indices);
            if (keep_dims != false)
                desc.SetAttr("keep_dims", keep_dims);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AllCandidateSampler
        /// </summary>
        /// <param name="true_classes">Input to the operation. </param>
        /// <param name="num_true">num true</param>
        /// <param name="num_sampled">num sampled</param>
        /// <param name="unique">unique</param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] sampled_candidates(type: DtInt64).
        /// [1] true_expected_count(type: DtFloat).
        /// [2] sampled_expected_count(type: DtFloat).
        /// </returns>
        public Operation AllCandidateSampler(Output true_classes, long num_true, long num_sampled, bool unique, long seed = 0, long seed2 = 0, String opName = "AllCandidateSampler") 
        {
            OperationDescription desc = NewOperation("AllCandidateSampler", opName);
            desc.AddInput(true_classes);
            desc.SetAttr("num_true", num_true);
            desc.SetAttr("num_sampled", num_sampled);
            desc.SetAttr("unique", unique);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AllToAll
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="group_assignment">Input to the operation. </param>
        /// <param name="concat_dimension">concat dimension</param>
        /// <param name="split_dimension">split dimension</param>
        /// <param name="split_count">split count</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation AllToAll(Output input, Output group_assignment, long concat_dimension, long split_dimension, long split_count, String opName = "AllToAll") 
        {
            OperationDescription desc = NewOperation("AllToAll", opName);
            desc.AddInput(input);
            desc.AddInput(group_assignment);
            desc.SetAttr("concat_dimension", concat_dimension);
            desc.SetAttr("split_dimension", split_dimension);
            desc.SetAttr("split_count", split_count);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Angle
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="Tout">Tout</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Angle(Output input, DataType? Tout = null, String opName = "Angle") 
        {
            OperationDescription desc = NewOperation("Angle", opName);
            desc.AddInput(input);
            if (Tout.HasValue)
                desc.SetAttr("Tout", Tout.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AnonymousHashTable
        /// </summary>
        /// <param name="key_dtype">key dtype</param>
        /// <param name="value_dtype">value dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] table_handle(type: DtResource).
        /// </returns>
        public Operation AnonymousHashTable(DataType key_dtype, DataType value_dtype, String opName = "AnonymousHashTable") 
        {
            OperationDescription desc = NewOperation("AnonymousHashTable", opName);
            desc.SetAttr("key_dtype", key_dtype);
            desc.SetAttr("value_dtype", value_dtype);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AnonymousIterator
        /// </summary>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// </returns>
        public Operation AnonymousIterator(DataType[] output_types, long[][] output_shapes, String opName = "AnonymousIterator") 
        {
            OperationDescription desc = NewOperation("AnonymousIterator", opName);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AnonymousIteratorV2
        /// </summary>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// [1] deleter(type: DtVariant).
        /// </returns>
        public Operation AnonymousIteratorV2(DataType[] output_types, long[][] output_shapes, String opName = "AnonymousIteratorV2") 
        {
            OperationDescription desc = NewOperation("AnonymousIteratorV2", opName);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AnonymousIteratorV3
        /// </summary>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// </returns>
        public Operation AnonymousIteratorV3(DataType[] output_types, long[][] output_shapes, String opName = "AnonymousIteratorV3") 
        {
            OperationDescription desc = NewOperation("AnonymousIteratorV3", opName);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AnonymousMemoryCache
        /// </summary>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// [1] deleter(type: DtVariant).
        /// </returns>
        public Operation AnonymousMemoryCache(String opName = "AnonymousMemoryCache") 
        {
            OperationDescription desc = NewOperation("AnonymousMemoryCache", opName);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AnonymousMultiDeviceIterator
        /// </summary>
        /// <param name="devices">devices</param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// [1] deleter(type: DtVariant).
        /// </returns>
        public Operation AnonymousMultiDeviceIterator(string[] devices, DataType[] output_types, long[][] output_shapes, String opName = "AnonymousMultiDeviceIterator") 
        {
            OperationDescription desc = NewOperation("AnonymousMultiDeviceIterator", opName);
            desc.SetAttr("devices", devices);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AnonymousMultiDeviceIteratorV3
        /// </summary>
        /// <param name="devices">devices</param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// </returns>
        public Operation AnonymousMultiDeviceIteratorV3(string[] devices, DataType[] output_types, long[][] output_shapes, String opName = "AnonymousMultiDeviceIteratorV3") 
        {
            OperationDescription desc = NewOperation("AnonymousMultiDeviceIteratorV3", opName);
            desc.SetAttr("devices", devices);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AnonymousMutableDenseHashTable
        /// </summary>
        /// <param name="empty_key">Input to the operation. </param>
        /// <param name="deleted_key">Input to the operation. </param>
        /// <param name="value_dtype">value dtype</param>
        /// <param name="value_shape">value shape</param>
        /// <param name="initial_num_buckets">initial num buckets</param>
        /// <param name="max_load_factor">max load factor</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] table_handle(type: DtResource).
        /// </returns>
        public Operation AnonymousMutableDenseHashTable(Output empty_key, Output deleted_key, DataType value_dtype, long[] value_shape = null, long initial_num_buckets = 131072, float max_load_factor = 0.8f, String opName = "AnonymousMutableDenseHashTable") 
        {
            OperationDescription desc = NewOperation("AnonymousMutableDenseHashTable", opName);
            desc.AddInput(empty_key);
            desc.AddInput(deleted_key);
            desc.SetAttr("value_dtype", value_dtype);
            if (value_shape != null)
                 desc.SetAttrShape("value_shape", value_shape);
            if (initial_num_buckets != 131072)
                desc.SetAttr("initial_num_buckets", initial_num_buckets);
            if (max_load_factor != 0.8f)
                desc.SetAttr("max_load_factor", max_load_factor);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AnonymousMutableHashTable
        /// </summary>
        /// <param name="key_dtype">key dtype</param>
        /// <param name="value_dtype">value dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] table_handle(type: DtResource).
        /// </returns>
        public Operation AnonymousMutableHashTable(DataType key_dtype, DataType value_dtype, String opName = "AnonymousMutableHashTable") 
        {
            OperationDescription desc = NewOperation("AnonymousMutableHashTable", opName);
            desc.SetAttr("key_dtype", key_dtype);
            desc.SetAttr("value_dtype", value_dtype);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AnonymousMutableHashTableOfTensors
        /// </summary>
        /// <param name="key_dtype">key dtype</param>
        /// <param name="value_dtype">value dtype</param>
        /// <param name="value_shape">value shape</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] table_handle(type: DtResource).
        /// </returns>
        public Operation AnonymousMutableHashTableOfTensors(DataType key_dtype, DataType value_dtype, long[] value_shape = null, String opName = "AnonymousMutableHashTableOfTensors") 
        {
            OperationDescription desc = NewOperation("AnonymousMutableHashTableOfTensors", opName);
            desc.SetAttr("key_dtype", key_dtype);
            desc.SetAttr("value_dtype", value_dtype);
            if (value_shape != null)
                 desc.SetAttrShape("value_shape", value_shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AnonymousRandomSeedGenerator
        /// </summary>
        /// <param name="seed">Input to the operation. </param>
        /// <param name="seed2">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// [1] deleter(type: DtVariant).
        /// </returns>
        public Operation AnonymousRandomSeedGenerator(Output seed, Output seed2, String opName = "AnonymousRandomSeedGenerator") 
        {
            OperationDescription desc = NewOperation("AnonymousRandomSeedGenerator", opName);
            desc.AddInput(seed);
            desc.AddInput(seed2);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AnonymousSeedGenerator
        /// </summary>
        /// <param name="seed">Input to the operation. </param>
        /// <param name="seed2">Input to the operation. </param>
        /// <param name="reshuffle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// [1] deleter(type: DtVariant).
        /// </returns>
        public Operation AnonymousSeedGenerator(Output seed, Output seed2, Output reshuffle, String opName = "AnonymousSeedGenerator") 
        {
            OperationDescription desc = NewOperation("AnonymousSeedGenerator", opName);
            desc.AddInput(seed);
            desc.AddInput(seed2);
            desc.AddInput(reshuffle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Any
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="reduction_indices">Input to the operation. </param>
        /// <param name="keep_dims">keep dims</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtBool).
        /// </returns>
        public Operation Any(Output input, Output reduction_indices, bool keep_dims = false, String opName = "Any") 
        {
            OperationDescription desc = NewOperation("Any", opName);
            desc.AddInput(input);
            desc.AddInput(reduction_indices);
            if (keep_dims != false)
                desc.SetAttr("keep_dims", keep_dims);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ApplyAdadelta
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="accum_update">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="rho">Input to the operation. </param>
        /// <param name="epsilon">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation ApplyAdadelta(Output var, Output accum, Output accum_update, Output lr, Output rho, Output epsilon, Output grad, bool use_locking = false, String opName = "ApplyAdadelta") 
        {
            OperationDescription desc = NewOperation("ApplyAdadelta", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(accum_update);
            desc.AddInput(lr);
            desc.AddInput(rho);
            desc.AddInput(epsilon);
            desc.AddInput(grad);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ApplyAdagrad
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="update_slots">update slots</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation ApplyAdagrad(Output var, Output accum, Output lr, Output grad, bool use_locking = false, bool update_slots = true, String opName = "ApplyAdagrad") 
        {
            OperationDescription desc = NewOperation("ApplyAdagrad", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(lr);
            desc.AddInput(grad);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            if (update_slots != true)
                desc.SetAttr("update_slots", update_slots);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ApplyAdagradDA
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="gradient_accumulator">Input to the operation. </param>
        /// <param name="gradient_squared_accumulator">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="l1">Input to the operation. </param>
        /// <param name="l2">Input to the operation. </param>
        /// <param name="global_step">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation ApplyAdagradDA(Output var, Output gradient_accumulator, Output gradient_squared_accumulator, Output grad, Output lr, Output l1, Output l2, Output global_step, bool use_locking = false, String opName = "ApplyAdagradDA") 
        {
            OperationDescription desc = NewOperation("ApplyAdagradDA", opName);
            desc.AddInput(var);
            desc.AddInput(gradient_accumulator);
            desc.AddInput(gradient_squared_accumulator);
            desc.AddInput(grad);
            desc.AddInput(lr);
            desc.AddInput(l1);
            desc.AddInput(l2);
            desc.AddInput(global_step);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ApplyAdagradV2
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="epsilon">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="update_slots">update slots</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation ApplyAdagradV2(Output var, Output accum, Output lr, Output epsilon, Output grad, bool use_locking = false, bool update_slots = true, String opName = "ApplyAdagradV2") 
        {
            OperationDescription desc = NewOperation("ApplyAdagradV2", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(lr);
            desc.AddInput(epsilon);
            desc.AddInput(grad);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            if (update_slots != true)
                desc.SetAttr("update_slots", update_slots);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ApplyAdam
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="m">Input to the operation. </param>
        /// <param name="v">Input to the operation. </param>
        /// <param name="beta1_power">Input to the operation. </param>
        /// <param name="beta2_power">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="beta1">Input to the operation. </param>
        /// <param name="beta2">Input to the operation. </param>
        /// <param name="epsilon">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="use_nesterov">use nesterov</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation ApplyAdam(Output var, Output m, Output v, Output beta1_power, Output beta2_power, Output lr, Output beta1, Output beta2, Output epsilon, Output grad, bool use_locking = false, bool use_nesterov = false, String opName = "ApplyAdam") 
        {
            OperationDescription desc = NewOperation("ApplyAdam", opName);
            desc.AddInput(var);
            desc.AddInput(m);
            desc.AddInput(v);
            desc.AddInput(beta1_power);
            desc.AddInput(beta2_power);
            desc.AddInput(lr);
            desc.AddInput(beta1);
            desc.AddInput(beta2);
            desc.AddInput(epsilon);
            desc.AddInput(grad);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            if (use_nesterov != false)
                desc.SetAttr("use_nesterov", use_nesterov);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ApplyAdaMax
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="m">Input to the operation. </param>
        /// <param name="v">Input to the operation. </param>
        /// <param name="beta1_power">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="beta1">Input to the operation. </param>
        /// <param name="beta2">Input to the operation. </param>
        /// <param name="epsilon">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation ApplyAdaMax(Output var, Output m, Output v, Output beta1_power, Output lr, Output beta1, Output beta2, Output epsilon, Output grad, bool use_locking = false, String opName = "ApplyAdaMax") 
        {
            OperationDescription desc = NewOperation("ApplyAdaMax", opName);
            desc.AddInput(var);
            desc.AddInput(m);
            desc.AddInput(v);
            desc.AddInput(beta1_power);
            desc.AddInput(lr);
            desc.AddInput(beta1);
            desc.AddInput(beta2);
            desc.AddInput(epsilon);
            desc.AddInput(grad);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ApplyAddSign
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="m">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="alpha">Input to the operation. </param>
        /// <param name="sign_decay">Input to the operation. </param>
        /// <param name="beta">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation ApplyAddSign(Output var, Output m, Output lr, Output alpha, Output sign_decay, Output beta, Output grad, bool use_locking = false, String opName = "ApplyAddSign") 
        {
            OperationDescription desc = NewOperation("ApplyAddSign", opName);
            desc.AddInput(var);
            desc.AddInput(m);
            desc.AddInput(lr);
            desc.AddInput(alpha);
            desc.AddInput(sign_decay);
            desc.AddInput(beta);
            desc.AddInput(grad);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ApplyCenteredRMSProp
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="mg">Input to the operation. </param>
        /// <param name="ms">Input to the operation. </param>
        /// <param name="mom">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="rho">Input to the operation. </param>
        /// <param name="momentum">Input to the operation. </param>
        /// <param name="epsilon">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation ApplyCenteredRMSProp(Output var, Output mg, Output ms, Output mom, Output lr, Output rho, Output momentum, Output epsilon, Output grad, bool use_locking = false, String opName = "ApplyCenteredRMSProp") 
        {
            OperationDescription desc = NewOperation("ApplyCenteredRMSProp", opName);
            desc.AddInput(var);
            desc.AddInput(mg);
            desc.AddInput(ms);
            desc.AddInput(mom);
            desc.AddInput(lr);
            desc.AddInput(rho);
            desc.AddInput(momentum);
            desc.AddInput(epsilon);
            desc.AddInput(grad);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ApplyFtrl
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="linear">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="l1">Input to the operation. </param>
        /// <param name="l2">Input to the operation. </param>
        /// <param name="lr_power">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="multiply_linear_by_lr">multiply linear by lr</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation ApplyFtrl(Output var, Output accum, Output linear, Output grad, Output lr, Output l1, Output l2, Output lr_power, bool use_locking = false, bool multiply_linear_by_lr = false, String opName = "ApplyFtrl") 
        {
            OperationDescription desc = NewOperation("ApplyFtrl", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(linear);
            desc.AddInput(grad);
            desc.AddInput(lr);
            desc.AddInput(l1);
            desc.AddInput(l2);
            desc.AddInput(lr_power);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            if (multiply_linear_by_lr != false)
                desc.SetAttr("multiply_linear_by_lr", multiply_linear_by_lr);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ApplyFtrlV2
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="linear">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="l1">Input to the operation. </param>
        /// <param name="l2">Input to the operation. </param>
        /// <param name="l2_shrinkage">Input to the operation. </param>
        /// <param name="lr_power">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="multiply_linear_by_lr">multiply linear by lr</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation ApplyFtrlV2(Output var, Output accum, Output linear, Output grad, Output lr, Output l1, Output l2, Output l2_shrinkage, Output lr_power, bool use_locking = false, bool multiply_linear_by_lr = false, String opName = "ApplyFtrlV2") 
        {
            OperationDescription desc = NewOperation("ApplyFtrlV2", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(linear);
            desc.AddInput(grad);
            desc.AddInput(lr);
            desc.AddInput(l1);
            desc.AddInput(l2);
            desc.AddInput(l2_shrinkage);
            desc.AddInput(lr_power);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            if (multiply_linear_by_lr != false)
                desc.SetAttr("multiply_linear_by_lr", multiply_linear_by_lr);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ApplyGradientDescent
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="alpha">Input to the operation. </param>
        /// <param name="delta">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation ApplyGradientDescent(Output var, Output alpha, Output delta, bool use_locking = false, String opName = "ApplyGradientDescent") 
        {
            OperationDescription desc = NewOperation("ApplyGradientDescent", opName);
            desc.AddInput(var);
            desc.AddInput(alpha);
            desc.AddInput(delta);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ApplyMomentum
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="momentum">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="use_nesterov">use nesterov</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation ApplyMomentum(Output var, Output accum, Output lr, Output grad, Output momentum, bool use_locking = false, bool use_nesterov = false, String opName = "ApplyMomentum") 
        {
            OperationDescription desc = NewOperation("ApplyMomentum", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(lr);
            desc.AddInput(grad);
            desc.AddInput(momentum);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            if (use_nesterov != false)
                desc.SetAttr("use_nesterov", use_nesterov);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ApplyPowerSign
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="m">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="logbase">Input to the operation. </param>
        /// <param name="sign_decay">Input to the operation. </param>
        /// <param name="beta">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation ApplyPowerSign(Output var, Output m, Output lr, Output logbase, Output sign_decay, Output beta, Output grad, bool use_locking = false, String opName = "ApplyPowerSign") 
        {
            OperationDescription desc = NewOperation("ApplyPowerSign", opName);
            desc.AddInput(var);
            desc.AddInput(m);
            desc.AddInput(lr);
            desc.AddInput(logbase);
            desc.AddInput(sign_decay);
            desc.AddInput(beta);
            desc.AddInput(grad);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ApplyProximalAdagrad
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="l1">Input to the operation. </param>
        /// <param name="l2">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation ApplyProximalAdagrad(Output var, Output accum, Output lr, Output l1, Output l2, Output grad, bool use_locking = false, String opName = "ApplyProximalAdagrad") 
        {
            OperationDescription desc = NewOperation("ApplyProximalAdagrad", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(lr);
            desc.AddInput(l1);
            desc.AddInput(l2);
            desc.AddInput(grad);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ApplyProximalGradientDescent
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="alpha">Input to the operation. </param>
        /// <param name="l1">Input to the operation. </param>
        /// <param name="l2">Input to the operation. </param>
        /// <param name="delta">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation ApplyProximalGradientDescent(Output var, Output alpha, Output l1, Output l2, Output delta, bool use_locking = false, String opName = "ApplyProximalGradientDescent") 
        {
            OperationDescription desc = NewOperation("ApplyProximalGradientDescent", opName);
            desc.AddInput(var);
            desc.AddInput(alpha);
            desc.AddInput(l1);
            desc.AddInput(l2);
            desc.AddInput(delta);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ApplyRMSProp
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="ms">Input to the operation. </param>
        /// <param name="mom">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="rho">Input to the operation. </param>
        /// <param name="momentum">Input to the operation. </param>
        /// <param name="epsilon">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation ApplyRMSProp(Output var, Output ms, Output mom, Output lr, Output rho, Output momentum, Output epsilon, Output grad, bool use_locking = false, String opName = "ApplyRMSProp") 
        {
            OperationDescription desc = NewOperation("ApplyRMSProp", opName);
            desc.AddInput(var);
            desc.AddInput(ms);
            desc.AddInput(mom);
            desc.AddInput(lr);
            desc.AddInput(rho);
            desc.AddInput(momentum);
            desc.AddInput(epsilon);
            desc.AddInput(grad);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ApproximateEqual
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="tolerance">tolerance</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtBool).
        /// </returns>
        public Operation ApproximateEqual(Output x, Output y, float tolerance = 1E-05f, String opName = "ApproximateEqual") 
        {
            OperationDescription desc = NewOperation("ApproximateEqual", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            if (tolerance != 1E-05f)
                desc.SetAttr("tolerance", tolerance);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ApproxTopK
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="k">k</param>
        /// <param name="reduction_dimension">reduction dimension</param>
        /// <param name="recall_target">recall target</param>
        /// <param name="is_max_k">is max k</param>
        /// <param name="reduction_input_size_override">reduction input size override</param>
        /// <param name="aggregate_to_topk">aggregate to topk</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] values(type: DtInvalid).
        /// [1] indices(type: DtInt32).
        /// </returns>
        public Operation ApproxTopK(Output input, long k, long reduction_dimension = -1, float recall_target = 0.95f, bool is_max_k = true, long reduction_input_size_override = -1, bool aggregate_to_topk = true, String opName = "ApproxTopK") 
        {
            OperationDescription desc = NewOperation("ApproxTopK", opName);
            desc.AddInput(input);
            desc.SetAttr("k", k);
            if (reduction_dimension != -1)
                desc.SetAttr("reduction_dimension", reduction_dimension);
            if (recall_target != 0.95f)
                desc.SetAttr("recall_target", recall_target);
            if (is_max_k != true)
                desc.SetAttr("is_max_k", is_max_k);
            if (reduction_input_size_override != -1)
                desc.SetAttr("reduction_input_size_override", reduction_input_size_override);
            if (aggregate_to_topk != true)
                desc.SetAttr("aggregate_to_topk", aggregate_to_topk);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ArgMax
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="dimension">Input to the operation. </param>
        /// <param name="output_type">output type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation ArgMax(Output input, Output dimension, DataType? output_type = null, String opName = "ArgMax") 
        {
            OperationDescription desc = NewOperation("ArgMax", opName);
            desc.AddInput(input);
            desc.AddInput(dimension);
            if (output_type.HasValue)
                desc.SetAttr("output_type", output_type.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ArgMin
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="dimension">Input to the operation. </param>
        /// <param name="output_type">output type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation ArgMin(Output input, Output dimension, DataType? output_type = null, String opName = "ArgMin") 
        {
            OperationDescription desc = NewOperation("ArgMin", opName);
            desc.AddInput(input);
            desc.AddInput(dimension);
            if (output_type.HasValue)
                desc.SetAttr("output_type", output_type.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Asin
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Asin(Output x, String opName = "Asin") 
        {
            OperationDescription desc = NewOperation("Asin", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Asinh
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Asinh(Output x, String opName = "Asinh") 
        {
            OperationDescription desc = NewOperation("Asinh", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Assert
        /// </summary>
        /// <param name="condition">Input to the operation. </param>
        /// <param name="data">Input to the operation. </param>
        /// <param name="summarize">summarize</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation Assert(Output condition, Output data, long summarize = 3, String opName = "Assert") 
        {
            OperationDescription desc = NewOperation("Assert", opName);
            desc.AddInput(condition);
            desc.AddInput(data);
            if (summarize != 3)
                desc.SetAttr("summarize", summarize);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AssertCardinalityDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="cardinality">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation AssertCardinalityDataset(Output input_dataset, Output cardinality, DataType[] output_types, long[][] output_shapes, String opName = "AssertCardinalityDataset") 
        {
            OperationDescription desc = NewOperation("AssertCardinalityDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(cardinality);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AssertNextDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="transformations">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation AssertNextDataset(Output input_dataset, Output transformations, DataType[] output_types, long[][] output_shapes, String opName = "AssertNextDataset") 
        {
            OperationDescription desc = NewOperation("AssertNextDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(transformations);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AssertPrevDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="transformations">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation AssertPrevDataset(Output input_dataset, Output transformations, DataType[] output_types, long[][] output_shapes, String opName = "AssertPrevDataset") 
        {
            OperationDescription desc = NewOperation("AssertPrevDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(transformations);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Assign
        /// </summary>
        /// <param name="reference">Input to the operation. </param>
        /// <param name="value">Input to the operation. </param>
        /// <param name="validate_shape">validate shape</param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_ref(type: DtInvalid).
        /// </returns>
        public Operation Assign(Output reference, Output value, bool validate_shape = true, bool use_locking = true, String opName = "Assign") 
        {
            OperationDescription desc = NewOperation("Assign", opName);
            desc.AddInput(reference);
            desc.AddInput(value);
            if (validate_shape != true)
                desc.SetAttr("validate_shape", validate_shape);
            if (use_locking != true)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AssignAdd
        /// </summary>
        /// <param name="reference">Input to the operation. </param>
        /// <param name="value">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_ref(type: DtInvalid).
        /// </returns>
        public Operation AssignAdd(Output reference, Output value, bool use_locking = false, String opName = "AssignAdd") 
        {
            OperationDescription desc = NewOperation("AssignAdd", opName);
            desc.AddInput(reference);
            desc.AddInput(value);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AssignAddVariableOp
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="value">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation AssignAddVariableOp(Output resource, Output value, String opName = "AssignAddVariableOp") 
        {
            OperationDescription desc = NewOperation("AssignAddVariableOp", opName);
            desc.AddInput(resource);
            desc.AddInput(value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AssignSub
        /// </summary>
        /// <param name="reference">Input to the operation. </param>
        /// <param name="value">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_ref(type: DtInvalid).
        /// </returns>
        public Operation AssignSub(Output reference, Output value, bool use_locking = false, String opName = "AssignSub") 
        {
            OperationDescription desc = NewOperation("AssignSub", opName);
            desc.AddInput(reference);
            desc.AddInput(value);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AssignSubVariableOp
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="value">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation AssignSubVariableOp(Output resource, Output value, String opName = "AssignSubVariableOp") 
        {
            OperationDescription desc = NewOperation("AssignSubVariableOp", opName);
            desc.AddInput(resource);
            desc.AddInput(value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AssignVariableOp
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="value">Input to the operation. </param>
        /// <param name="validate_shape">validate shape</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation AssignVariableOp(Output resource, Output value, bool validate_shape = false, String opName = "AssignVariableOp") 
        {
            OperationDescription desc = NewOperation("AssignVariableOp", opName);
            desc.AddInput(resource);
            desc.AddInput(value);
            if (validate_shape != false)
                desc.SetAttr("validate_shape", validate_shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AssignVariableXlaConcatND
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="num_concats">num concats</param>
        /// <param name="paddings">paddings</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation AssignVariableXlaConcatND(Output resource, Output inputs, long[] num_concats, long[] paddings = null, String opName = "AssignVariableXlaConcatND") 
        {
            OperationDescription desc = NewOperation("AssignVariableXlaConcatND", opName);
            desc.AddInput(resource);
            desc.AddInput(inputs);
            desc.SetAttr("num_concats", num_concats);
            if (paddings != null) desc.SetAttr("paddings", paddings);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AsString
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="precision">precision</param>
        /// <param name="scientific">scientific</param>
        /// <param name="shortest">shortest</param>
        /// <param name="width">width</param>
        /// <param name="fill">fill</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtString).
        /// </returns>
        public Operation AsString(Output input, long precision = -1, bool scientific = false, bool shortest = false, long width = -1, string fill = null, String opName = "AsString") 
        {
            OperationDescription desc = NewOperation("AsString", opName);
            desc.AddInput(input);
            if (precision != -1)
                desc.SetAttr("precision", precision);
            if (scientific != false)
                desc.SetAttr("scientific", scientific);
            if (shortest != false)
                desc.SetAttr("shortest", shortest);
            if (width != -1)
                desc.SetAttr("width", width);
            if (fill != null)
                 desc.SetAttr("fill", fill);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Atan
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Atan(Output x, String opName = "Atan") 
        {
            OperationDescription desc = NewOperation("Atan", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Atan2
        /// </summary>
        /// <param name="y">Input to the operation. </param>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation Atan2(Output y, Output x, String opName = "Atan2") 
        {
            OperationDescription desc = NewOperation("Atan2", opName);
            desc.AddInput(y);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Atanh
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Atanh(Output x, String opName = "Atanh") 
        {
            OperationDescription desc = NewOperation("Atanh", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AudioSpectrogram
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="window_size">window size</param>
        /// <param name="stride">stride</param>
        /// <param name="magnitude_squared">magnitude squared</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] spectrogram(type: DtFloat).
        /// </returns>
        public Operation AudioSpectrogram(Output input, long window_size, long stride, bool magnitude_squared = false, String opName = "AudioSpectrogram") 
        {
            OperationDescription desc = NewOperation("AudioSpectrogram", opName);
            desc.AddInput(input);
            desc.SetAttr("window_size", window_size);
            desc.SetAttr("stride", stride);
            if (magnitude_squared != false)
                desc.SetAttr("magnitude_squared", magnitude_squared);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AudioSummary
        /// </summary>
        /// <param name="tag">Input to the operation. </param>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="sample_rate">sample rate</param>
        /// <param name="max_outputs">max outputs</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] summary(type: DtString).
        /// </returns>
        public Operation AudioSummary(Output tag, Output tensor, float sample_rate, long max_outputs = 3, String opName = "AudioSummary") 
        {
            OperationDescription desc = NewOperation("AudioSummary", opName);
            desc.AddInput(tag);
            desc.AddInput(tensor);
            desc.SetAttr("sample_rate", sample_rate);
            if (max_outputs != 3)
                desc.SetAttr("max_outputs", max_outputs);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AudioSummaryV2
        /// </summary>
        /// <param name="tag">Input to the operation. </param>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="sample_rate">Input to the operation. </param>
        /// <param name="max_outputs">max outputs</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] summary(type: DtString).
        /// </returns>
        public Operation AudioSummaryV2(Output tag, Output tensor, Output sample_rate, long max_outputs = 3, String opName = "AudioSummaryV2") 
        {
            OperationDescription desc = NewOperation("AudioSummaryV2", opName);
            desc.AddInput(tag);
            desc.AddInput(tensor);
            desc.AddInput(sample_rate);
            if (max_outputs != 3)
                desc.SetAttr("max_outputs", max_outputs);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AutoShardDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="num_workers">Input to the operation. </param>
        /// <param name="index">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="auto_shard_policy">auto shard policy</param>
        /// <param name="num_replicas">num replicas</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation AutoShardDataset(Output input_dataset, Output num_workers, Output index, DataType[] output_types, long[][] output_shapes, long auto_shard_policy = 0, long num_replicas = 0, String opName = "AutoShardDataset") 
        {
            OperationDescription desc = NewOperation("AutoShardDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(num_workers);
            desc.AddInput(index);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (auto_shard_policy != 0)
                desc.SetAttr("auto_shard_policy", auto_shard_policy);
            if (num_replicas != 0)
                desc.SetAttr("num_replicas", num_replicas);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AvgPool
        /// </summary>
        /// <param name="value">Input to the operation. </param>
        /// <param name="ksize">ksize</param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="data_format">data format</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation AvgPool(Output value, long[] ksize, long[] strides, string padding, string data_format = null, String opName = "AvgPool") 
        {
            OperationDescription desc = NewOperation("AvgPool", opName);
            desc.AddInput(value);
            desc.SetAttr("ksize", ksize);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AvgPool3D
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="ksize">ksize</param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="data_format">data format</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation AvgPool3D(Output input, long[] ksize, long[] strides, string padding, string data_format = null, String opName = "AvgPool3D") 
        {
            OperationDescription desc = NewOperation("AvgPool3D", opName);
            desc.AddInput(input);
            desc.SetAttr("ksize", ksize);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AvgPool3DGrad
        /// </summary>
        /// <param name="orig_input_shape">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="ksize">ksize</param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="data_format">data format</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation AvgPool3DGrad(Output orig_input_shape, Output grad, long[] ksize, long[] strides, string padding, string data_format = null, String opName = "AvgPool3DGrad") 
        {
            OperationDescription desc = NewOperation("AvgPool3DGrad", opName);
            desc.AddInput(orig_input_shape);
            desc.AddInput(grad);
            desc.SetAttr("ksize", ksize);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// AvgPoolGrad
        /// </summary>
        /// <param name="orig_input_shape">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="ksize">ksize</param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="data_format">data format</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation AvgPoolGrad(Output orig_input_shape, Output grad, long[] ksize, long[] strides, string padding, string data_format = null, String opName = "AvgPoolGrad") 
        {
            OperationDescription desc = NewOperation("AvgPoolGrad", opName);
            desc.AddInput(orig_input_shape);
            desc.AddInput(grad);
            desc.SetAttr("ksize", ksize);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BandedTriangularSolve
        /// </summary>
        /// <param name="matrix">Input to the operation. </param>
        /// <param name="rhs">Input to the operation. </param>
        /// <param name="lower">lower</param>
        /// <param name="adjoint">adjoint</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation BandedTriangularSolve(Output matrix, Output rhs, bool lower = true, bool adjoint = false, String opName = "BandedTriangularSolve") 
        {
            OperationDescription desc = NewOperation("BandedTriangularSolve", opName);
            desc.AddInput(matrix);
            desc.AddInput(rhs);
            if (lower != true)
                desc.SetAttr("lower", lower);
            if (adjoint != false)
                desc.SetAttr("adjoint", adjoint);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Barrier
        /// </summary>
        /// <param name="component_types">component types</param>
        /// <param name="shapes">shapes</param>
        /// <param name="capacity">capacity</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtString).
        /// </returns>
        public Operation Barrier(DataType[] component_types, long[][] shapes = null, long capacity = -1, string container = null, string shared_name = null, String opName = "Barrier") 
        {
            OperationDescription desc = NewOperation("Barrier", opName);
            desc.SetAttr("component_types", component_types);
            if (shapes != null) desc.SetAttrShapeList("shapes", shapes);
            if (capacity != -1)
                desc.SetAttr("capacity", capacity);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BarrierClose
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="cancel_pending_enqueues">cancel pending enqueues</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation BarrierClose(Output handle, bool cancel_pending_enqueues = false, String opName = "BarrierClose") 
        {
            OperationDescription desc = NewOperation("BarrierClose", opName);
            desc.AddInput(handle);
            if (cancel_pending_enqueues != false)
                desc.SetAttr("cancel_pending_enqueues", cancel_pending_enqueues);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BarrierIncompleteSize
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] size(type: DtInt32).
        /// </returns>
        public Operation BarrierIncompleteSize(Output handle, String opName = "BarrierIncompleteSize") 
        {
            OperationDescription desc = NewOperation("BarrierIncompleteSize", opName);
            desc.AddInput(handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BarrierInsertMany
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="keys">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="component_index">component index</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation BarrierInsertMany(Output handle, Output keys, Output values, long component_index, String opName = "BarrierInsertMany") 
        {
            OperationDescription desc = NewOperation("BarrierInsertMany", opName);
            desc.AddInput(handle);
            desc.AddInput(keys);
            desc.AddInput(values);
            desc.SetAttr("component_index", component_index);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BarrierReadySize
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] size(type: DtInt32).
        /// </returns>
        public Operation BarrierReadySize(Output handle, String opName = "BarrierReadySize") 
        {
            OperationDescription desc = NewOperation("BarrierReadySize", opName);
            desc.AddInput(handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BarrierTakeMany
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="num_elements">Input to the operation. </param>
        /// <param name="component_types">component types</param>
        /// <param name="allow_small_batch">allow small batch</param>
        /// <param name="wait_for_incomplete">wait for incomplete</param>
        /// <param name="timeout_ms">timeout ms</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] indices(type: DtInt64).
        /// [1] keys(type: DtString).
        /// [2] values(type: DtInvalid).
        /// </returns>
        public Operation BarrierTakeMany(Output handle, Output num_elements, DataType[] component_types, bool allow_small_batch = false, bool wait_for_incomplete = false, long timeout_ms = -1, String opName = "BarrierTakeMany") 
        {
            OperationDescription desc = NewOperation("BarrierTakeMany", opName);
            desc.AddInput(handle);
            desc.AddInput(num_elements);
            desc.SetAttr("component_types", component_types);
            if (allow_small_batch != false)
                desc.SetAttr("allow_small_batch", allow_small_batch);
            if (wait_for_incomplete != false)
                desc.SetAttr("wait_for_incomplete", wait_for_incomplete);
            if (timeout_ms != -1)
                desc.SetAttr("timeout_ms", timeout_ms);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Batch
        /// </summary>
        /// <param name="in_tensors">Input to the operation. </param>
        /// <param name="num_batch_threads">num batch threads</param>
        /// <param name="max_batch_size">max batch size</param>
        /// <param name="batch_timeout_micros">batch timeout micros</param>
        /// <param name="grad_timeout_micros">grad timeout micros</param>
        /// <param name="max_enqueued_batches">max enqueued batches</param>
        /// <param name="allowed_batch_sizes">allowed batch sizes</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="batching_queue">batching queue</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] batched_tensors(type: DtInvalid).
        /// [1] batch_index(type: DtInt64).
        /// [2] id(type: DtInt64).
        /// </returns>
        public Operation Batch(Output in_tensors, long num_batch_threads, long max_batch_size, long batch_timeout_micros, long grad_timeout_micros, long max_enqueued_batches = 10, long[] allowed_batch_sizes = null, string container = null, string shared_name = null, string batching_queue = null, String opName = "Batch") 
        {
            OperationDescription desc = NewOperation("Batch", opName);
            desc.AddInput(in_tensors);
            desc.SetAttr("num_batch_threads", num_batch_threads);
            desc.SetAttr("max_batch_size", max_batch_size);
            desc.SetAttr("batch_timeout_micros", batch_timeout_micros);
            desc.SetAttr("grad_timeout_micros", grad_timeout_micros);
            if (max_enqueued_batches != 10)
                desc.SetAttr("max_enqueued_batches", max_enqueued_batches);
            if (allowed_batch_sizes != null) desc.SetAttr("allowed_batch_sizes", allowed_batch_sizes);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            if (batching_queue != null)
                 desc.SetAttr("batching_queue", batching_queue);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchCholesky
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation BatchCholesky(Output input, String opName = "BatchCholesky") 
        {
            OperationDescription desc = NewOperation("BatchCholesky", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchCholeskyGrad
        /// </summary>
        /// <param name="l">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation BatchCholeskyGrad(Output l, Output grad, String opName = "BatchCholeskyGrad") 
        {
            OperationDescription desc = NewOperation("BatchCholeskyGrad", opName);
            desc.AddInput(l);
            desc.AddInput(grad);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="batch_size">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation BatchDataset(Output input_dataset, Output batch_size, DataType[] output_types, long[][] output_shapes, string metadata = null, String opName = "BatchDataset") 
        {
            OperationDescription desc = NewOperation("BatchDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(batch_size);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchDatasetV2
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="batch_size">Input to the operation. </param>
        /// <param name="drop_remainder">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="parallel_copy">parallel copy</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation BatchDatasetV2(Output input_dataset, Output batch_size, Output drop_remainder, DataType[] output_types, long[][] output_shapes, bool parallel_copy = false, string metadata = null, String opName = "BatchDatasetV2") 
        {
            OperationDescription desc = NewOperation("BatchDatasetV2", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(batch_size);
            desc.AddInput(drop_remainder);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (parallel_copy != false)
                desc.SetAttr("parallel_copy", parallel_copy);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchFFT
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtComplex64).
        /// </returns>
        public Operation BatchFFT(Output input, String opName = "BatchFFT") 
        {
            OperationDescription desc = NewOperation("BatchFFT", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchFFT2D
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtComplex64).
        /// </returns>
        public Operation BatchFFT2D(Output input, String opName = "BatchFFT2D") 
        {
            OperationDescription desc = NewOperation("BatchFFT2D", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchFFT3D
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtComplex64).
        /// </returns>
        public Operation BatchFFT3D(Output input, String opName = "BatchFFT3D") 
        {
            OperationDescription desc = NewOperation("BatchFFT3D", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchFunction
        /// </summary>
        /// <param name="in_tensors">Input to the operation. </param>
        /// <param name="captured_tensors">Input to the operation. </param>
        /// <param name="num_batch_threads">num batch threads</param>
        /// <param name="max_batch_size">max batch size</param>
        /// <param name="batch_timeout_micros">batch timeout micros</param>
        /// <param name="Tout">Tout</param>
        /// <param name="max_enqueued_batches">max enqueued batches</param>
        /// <param name="allowed_batch_sizes">allowed batch sizes</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="batching_queue">batching queue</param>
        /// <param name="low_priority_max_batch_size">low priority max batch size</param>
        /// <param name="low_priority_batch_timeout_micros">low priority batch timeout micros</param>
        /// <param name="low_priority_allowed_batch_sizes">low priority allowed batch sizes</param>
        /// <param name="low_priority_max_enqueued_batches">low priority max enqueued batches</param>
        /// <param name="mixed_priority_policy">mixed priority policy</param>
        /// <param name="enable_large_batch_splitting">enable large batch splitting</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out_tensors(type: DtInvalid).
        /// </returns>
        // The following attributes are not known: f: func
        public Operation BatchFunction(Output in_tensors, Output captured_tensors, long num_batch_threads, long max_batch_size, long batch_timeout_micros, DataType[] Tout, long max_enqueued_batches = 10, long[] allowed_batch_sizes = null, string container = null, string shared_name = null, string batching_queue = null, long low_priority_max_batch_size = 0, long low_priority_batch_timeout_micros = 0, long[] low_priority_allowed_batch_sizes = null, long low_priority_max_enqueued_batches = 0, string mixed_priority_policy = null, bool enable_large_batch_splitting = false, String opName = "BatchFunction") 
        {
            OperationDescription desc = NewOperation("BatchFunction", opName);
            desc.AddInput(in_tensors);
            desc.AddInput(captured_tensors);
            desc.SetAttr("num_batch_threads", num_batch_threads);
            desc.SetAttr("max_batch_size", max_batch_size);
            desc.SetAttr("batch_timeout_micros", batch_timeout_micros);
            desc.SetAttr("Tout", Tout);
            if (max_enqueued_batches != 10)
                desc.SetAttr("max_enqueued_batches", max_enqueued_batches);
            if (allowed_batch_sizes != null) desc.SetAttr("allowed_batch_sizes", allowed_batch_sizes);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            if (batching_queue != null)
                 desc.SetAttr("batching_queue", batching_queue);
            if (low_priority_max_batch_size != 0)
                desc.SetAttr("low_priority_max_batch_size", low_priority_max_batch_size);
            if (low_priority_batch_timeout_micros != 0)
                desc.SetAttr("low_priority_batch_timeout_micros", low_priority_batch_timeout_micros);
            if (low_priority_allowed_batch_sizes != null) desc.SetAttr("low_priority_allowed_batch_sizes", low_priority_allowed_batch_sizes);
            if (low_priority_max_enqueued_batches != 0)
                desc.SetAttr("low_priority_max_enqueued_batches", low_priority_max_enqueued_batches);
            if (mixed_priority_policy != null)
                 desc.SetAttr("mixed_priority_policy", mixed_priority_policy);
            if (enable_large_batch_splitting != false)
                desc.SetAttr("enable_large_batch_splitting", enable_large_batch_splitting);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchIFFT
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtComplex64).
        /// </returns>
        public Operation BatchIFFT(Output input, String opName = "BatchIFFT") 
        {
            OperationDescription desc = NewOperation("BatchIFFT", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchIFFT2D
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtComplex64).
        /// </returns>
        public Operation BatchIFFT2D(Output input, String opName = "BatchIFFT2D") 
        {
            OperationDescription desc = NewOperation("BatchIFFT2D", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchIFFT3D
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtComplex64).
        /// </returns>
        public Operation BatchIFFT3D(Output input, String opName = "BatchIFFT3D") 
        {
            OperationDescription desc = NewOperation("BatchIFFT3D", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchMatMul
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="adj_x">adj x</param>
        /// <param name="adj_y">adj y</param>
        /// <param name="grad_x">grad x</param>
        /// <param name="grad_y">grad y</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation BatchMatMul(Output x, Output y, bool adj_x = false, bool adj_y = false, bool grad_x = false, bool grad_y = false, String opName = "BatchMatMul") 
        {
            OperationDescription desc = NewOperation("BatchMatMul", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            if (adj_x != false)
                desc.SetAttr("adj_x", adj_x);
            if (adj_y != false)
                desc.SetAttr("adj_y", adj_y);
            if (grad_x != false)
                desc.SetAttr("grad_x", grad_x);
            if (grad_y != false)
                desc.SetAttr("grad_y", grad_y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchMatMulV2
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="adj_x">adj x</param>
        /// <param name="adj_y">adj y</param>
        /// <param name="grad_x">grad x</param>
        /// <param name="grad_y">grad y</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation BatchMatMulV2(Output x, Output y, bool adj_x = false, bool adj_y = false, bool grad_x = false, bool grad_y = false, String opName = "BatchMatMulV2") 
        {
            OperationDescription desc = NewOperation("BatchMatMulV2", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            if (adj_x != false)
                desc.SetAttr("adj_x", adj_x);
            if (adj_y != false)
                desc.SetAttr("adj_y", adj_y);
            if (grad_x != false)
                desc.SetAttr("grad_x", grad_x);
            if (grad_y != false)
                desc.SetAttr("grad_y", grad_y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchMatMulV3
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="Tout">Tout</param>
        /// <param name="adj_x">adj x</param>
        /// <param name="adj_y">adj y</param>
        /// <param name="grad_x">grad x</param>
        /// <param name="grad_y">grad y</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation BatchMatMulV3(Output x, Output y, DataType Tout, bool adj_x = false, bool adj_y = false, bool grad_x = false, bool grad_y = false, String opName = "BatchMatMulV3") 
        {
            OperationDescription desc = NewOperation("BatchMatMulV3", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            desc.SetAttr("Tout", Tout);
            if (adj_x != false)
                desc.SetAttr("adj_x", adj_x);
            if (adj_y != false)
                desc.SetAttr("adj_y", adj_y);
            if (grad_x != false)
                desc.SetAttr("grad_x", grad_x);
            if (grad_y != false)
                desc.SetAttr("grad_y", grad_y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchMatrixBandPart
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="num_lower">Input to the operation. </param>
        /// <param name="num_upper">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] band(type: DtInvalid).
        /// </returns>
        public Operation BatchMatrixBandPart(Output input, Output num_lower, Output num_upper, String opName = "BatchMatrixBandPart") 
        {
            OperationDescription desc = NewOperation("BatchMatrixBandPart", opName);
            desc.AddInput(input);
            desc.AddInput(num_lower);
            desc.AddInput(num_upper);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchMatrixDeterminant
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation BatchMatrixDeterminant(Output input, String opName = "BatchMatrixDeterminant") 
        {
            OperationDescription desc = NewOperation("BatchMatrixDeterminant", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchMatrixDiag
        /// </summary>
        /// <param name="diagonal">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation BatchMatrixDiag(Output diagonal, String opName = "BatchMatrixDiag") 
        {
            OperationDescription desc = NewOperation("BatchMatrixDiag", opName);
            desc.AddInput(diagonal);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchMatrixDiagPart
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] diagonal(type: DtInvalid).
        /// </returns>
        public Operation BatchMatrixDiagPart(Output input, String opName = "BatchMatrixDiagPart") 
        {
            OperationDescription desc = NewOperation("BatchMatrixDiagPart", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchMatrixInverse
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="adjoint">adjoint</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation BatchMatrixInverse(Output input, bool adjoint = false, String opName = "BatchMatrixInverse") 
        {
            OperationDescription desc = NewOperation("BatchMatrixInverse", opName);
            desc.AddInput(input);
            if (adjoint != false)
                desc.SetAttr("adjoint", adjoint);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchMatrixSetDiag
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="diagonal">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation BatchMatrixSetDiag(Output input, Output diagonal, String opName = "BatchMatrixSetDiag") 
        {
            OperationDescription desc = NewOperation("BatchMatrixSetDiag", opName);
            desc.AddInput(input);
            desc.AddInput(diagonal);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchMatrixSolve
        /// </summary>
        /// <param name="matrix">Input to the operation. </param>
        /// <param name="rhs">Input to the operation. </param>
        /// <param name="adjoint">adjoint</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation BatchMatrixSolve(Output matrix, Output rhs, bool adjoint = false, String opName = "BatchMatrixSolve") 
        {
            OperationDescription desc = NewOperation("BatchMatrixSolve", opName);
            desc.AddInput(matrix);
            desc.AddInput(rhs);
            if (adjoint != false)
                desc.SetAttr("adjoint", adjoint);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchMatrixSolveLs
        /// </summary>
        /// <param name="matrix">Input to the operation. </param>
        /// <param name="rhs">Input to the operation. </param>
        /// <param name="l2_regularizer">Input to the operation. </param>
        /// <param name="fast">fast</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation BatchMatrixSolveLs(Output matrix, Output rhs, Output l2_regularizer, bool fast = true, String opName = "BatchMatrixSolveLs") 
        {
            OperationDescription desc = NewOperation("BatchMatrixSolveLs", opName);
            desc.AddInput(matrix);
            desc.AddInput(rhs);
            desc.AddInput(l2_regularizer);
            if (fast != true)
                desc.SetAttr("fast", fast);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchMatrixTriangularSolve
        /// </summary>
        /// <param name="matrix">Input to the operation. </param>
        /// <param name="rhs">Input to the operation. </param>
        /// <param name="lower">lower</param>
        /// <param name="adjoint">adjoint</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation BatchMatrixTriangularSolve(Output matrix, Output rhs, bool lower = true, bool adjoint = false, String opName = "BatchMatrixTriangularSolve") 
        {
            OperationDescription desc = NewOperation("BatchMatrixTriangularSolve", opName);
            desc.AddInput(matrix);
            desc.AddInput(rhs);
            if (lower != true)
                desc.SetAttr("lower", lower);
            if (adjoint != false)
                desc.SetAttr("adjoint", adjoint);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchNormWithGlobalNormalization
        /// </summary>
        /// <param name="t">Input to the operation. </param>
        /// <param name="m">Input to the operation. </param>
        /// <param name="v">Input to the operation. </param>
        /// <param name="beta">Input to the operation. </param>
        /// <param name="gamma">Input to the operation. </param>
        /// <param name="variance_epsilon">variance epsilon</param>
        /// <param name="scale_after_normalization">scale after normalization</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] result(type: DtInvalid).
        /// </returns>
        public Operation BatchNormWithGlobalNormalization(Output t, Output m, Output v, Output beta, Output gamma, float variance_epsilon, bool scale_after_normalization, String opName = "BatchNormWithGlobalNormalization") 
        {
            OperationDescription desc = NewOperation("BatchNormWithGlobalNormalization", opName);
            desc.AddInput(t);
            desc.AddInput(m);
            desc.AddInput(v);
            desc.AddInput(beta);
            desc.AddInput(gamma);
            desc.SetAttr("variance_epsilon", variance_epsilon);
            desc.SetAttr("scale_after_normalization", scale_after_normalization);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchNormWithGlobalNormalizationGrad
        /// </summary>
        /// <param name="t">Input to the operation. </param>
        /// <param name="m">Input to the operation. </param>
        /// <param name="v">Input to the operation. </param>
        /// <param name="gamma">Input to the operation. </param>
        /// <param name="backprop">Input to the operation. </param>
        /// <param name="variance_epsilon">variance epsilon</param>
        /// <param name="scale_after_normalization">scale after normalization</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] dx(type: DtInvalid).
        /// [1] dm(type: DtInvalid).
        /// [2] dv(type: DtInvalid).
        /// [3] db(type: DtInvalid).
        /// [4] dg(type: DtInvalid).
        /// </returns>
        public Operation BatchNormWithGlobalNormalizationGrad(Output t, Output m, Output v, Output gamma, Output backprop, float variance_epsilon, bool scale_after_normalization, String opName = "BatchNormWithGlobalNormalizationGrad") 
        {
            OperationDescription desc = NewOperation("BatchNormWithGlobalNormalizationGrad", opName);
            desc.AddInput(t);
            desc.AddInput(m);
            desc.AddInput(v);
            desc.AddInput(gamma);
            desc.AddInput(backprop);
            desc.SetAttr("variance_epsilon", variance_epsilon);
            desc.SetAttr("scale_after_normalization", scale_after_normalization);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchSelfAdjointEig
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation BatchSelfAdjointEig(Output input, String opName = "BatchSelfAdjointEig") 
        {
            OperationDescription desc = NewOperation("BatchSelfAdjointEig", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchSelfAdjointEigV2
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="compute_v">compute v</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] e(type: DtInvalid).
        /// [1] v(type: DtInvalid).
        /// </returns>
        public Operation BatchSelfAdjointEigV2(Output input, bool compute_v = true, String opName = "BatchSelfAdjointEigV2") 
        {
            OperationDescription desc = NewOperation("BatchSelfAdjointEigV2", opName);
            desc.AddInput(input);
            if (compute_v != true)
                desc.SetAttr("compute_v", compute_v);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchSvd
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="compute_uv">compute uv</param>
        /// <param name="full_matrices">full matrices</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] s(type: DtInvalid).
        /// [1] u(type: DtInvalid).
        /// [2] v(type: DtInvalid).
        /// </returns>
        public Operation BatchSvd(Output input, bool compute_uv = true, bool full_matrices = false, String opName = "BatchSvd") 
        {
            OperationDescription desc = NewOperation("BatchSvd", opName);
            desc.AddInput(input);
            if (compute_uv != true)
                desc.SetAttr("compute_uv", compute_uv);
            if (full_matrices != false)
                desc.SetAttr("full_matrices", full_matrices);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchToSpace
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="crops">Input to the operation. </param>
        /// <param name="block_size">block size</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation BatchToSpace(Output input, Output crops, long block_size, String opName = "BatchToSpace") 
        {
            OperationDescription desc = NewOperation("BatchToSpace", opName);
            desc.AddInput(input);
            desc.AddInput(crops);
            desc.SetAttr("block_size", block_size);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BatchToSpaceND
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="block_shape">Input to the operation. </param>
        /// <param name="crops">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation BatchToSpaceND(Output input, Output block_shape, Output crops, String opName = "BatchToSpaceND") 
        {
            OperationDescription desc = NewOperation("BatchToSpaceND", opName);
            desc.AddInput(input);
            desc.AddInput(block_shape);
            desc.AddInput(crops);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BesselI0
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation BesselI0(Output x, String opName = "BesselI0") 
        {
            OperationDescription desc = NewOperation("BesselI0", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BesselI0e
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation BesselI0e(Output x, String opName = "BesselI0e") 
        {
            OperationDescription desc = NewOperation("BesselI0e", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BesselI1
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation BesselI1(Output x, String opName = "BesselI1") 
        {
            OperationDescription desc = NewOperation("BesselI1", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BesselI1e
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation BesselI1e(Output x, String opName = "BesselI1e") 
        {
            OperationDescription desc = NewOperation("BesselI1e", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BesselJ0
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation BesselJ0(Output x, String opName = "BesselJ0") 
        {
            OperationDescription desc = NewOperation("BesselJ0", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BesselJ1
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation BesselJ1(Output x, String opName = "BesselJ1") 
        {
            OperationDescription desc = NewOperation("BesselJ1", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BesselK0
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation BesselK0(Output x, String opName = "BesselK0") 
        {
            OperationDescription desc = NewOperation("BesselK0", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BesselK0e
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation BesselK0e(Output x, String opName = "BesselK0e") 
        {
            OperationDescription desc = NewOperation("BesselK0e", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BesselK1
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation BesselK1(Output x, String opName = "BesselK1") 
        {
            OperationDescription desc = NewOperation("BesselK1", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BesselK1e
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation BesselK1e(Output x, String opName = "BesselK1e") 
        {
            OperationDescription desc = NewOperation("BesselK1e", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BesselY0
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation BesselY0(Output x, String opName = "BesselY0") 
        {
            OperationDescription desc = NewOperation("BesselY0", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BesselY1
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation BesselY1(Output x, String opName = "BesselY1") 
        {
            OperationDescription desc = NewOperation("BesselY1", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Betainc
        /// </summary>
        /// <param name="a">Input to the operation. </param>
        /// <param name="b">Input to the operation. </param>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation Betainc(Output a, Output b, Output x, String opName = "Betainc") 
        {
            OperationDescription desc = NewOperation("Betainc", opName);
            desc.AddInput(a);
            desc.AddInput(b);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BiasAdd
        /// </summary>
        /// <param name="value">Input to the operation. </param>
        /// <param name="bias">Input to the operation. </param>
        /// <param name="data_format">data format</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation BiasAdd(Output value, Output bias, string data_format = null, String opName = "BiasAdd") 
        {
            OperationDescription desc = NewOperation("BiasAdd", opName);
            desc.AddInput(value);
            desc.AddInput(bias);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BiasAddGrad
        /// </summary>
        /// <param name="out_backprop">Input to the operation. </param>
        /// <param name="data_format">data format</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation BiasAddGrad(Output out_backprop, string data_format = null, String opName = "BiasAddGrad") 
        {
            OperationDescription desc = NewOperation("BiasAddGrad", opName);
            desc.AddInput(out_backprop);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BiasAddV1
        /// </summary>
        /// <param name="value">Input to the operation. </param>
        /// <param name="bias">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation BiasAddV1(Output value, Output bias, String opName = "BiasAddV1") 
        {
            OperationDescription desc = NewOperation("BiasAddV1", opName);
            desc.AddInput(value);
            desc.AddInput(bias);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Bincount
        /// </summary>
        /// <param name="arr">Input to the operation. </param>
        /// <param name="size">Input to the operation. </param>
        /// <param name="weights">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] bins(type: DtInvalid).
        /// </returns>
        public Operation Bincount(Output arr, Output size, Output weights, String opName = "Bincount") 
        {
            OperationDescription desc = NewOperation("Bincount", opName);
            desc.AddInput(arr);
            desc.AddInput(size);
            desc.AddInput(weights);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Bitcast
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="type">type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Bitcast(Output input, DataType type, String opName = "Bitcast") 
        {
            OperationDescription desc = NewOperation("Bitcast", opName);
            desc.AddInput(input);
            desc.SetAttr("type", type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BitwiseAnd
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation BitwiseAnd(Output x, Output y, String opName = "BitwiseAnd") 
        {
            OperationDescription desc = NewOperation("BitwiseAnd", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BitwiseOr
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation BitwiseOr(Output x, Output y, String opName = "BitwiseOr") 
        {
            OperationDescription desc = NewOperation("BitwiseOr", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BitwiseXor
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation BitwiseXor(Output x, Output y, String opName = "BitwiseXor") 
        {
            OperationDescription desc = NewOperation("BitwiseXor", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BlockLSTM
        /// </summary>
        /// <param name="seq_len_max">Input to the operation. </param>
        /// <param name="x">Input to the operation. </param>
        /// <param name="cs_prev">Input to the operation. </param>
        /// <param name="h_prev">Input to the operation. </param>
        /// <param name="w">Input to the operation. </param>
        /// <param name="wci">Input to the operation. </param>
        /// <param name="wcf">Input to the operation. </param>
        /// <param name="wco">Input to the operation. </param>
        /// <param name="b">Input to the operation. </param>
        /// <param name="forget_bias">forget bias</param>
        /// <param name="cell_clip">cell clip</param>
        /// <param name="use_peephole">use peephole</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] i(type: DtInvalid).
        /// [1] cs(type: DtInvalid).
        /// [2] f(type: DtInvalid).
        /// [3] o(type: DtInvalid).
        /// [4] ci(type: DtInvalid).
        /// [5] co(type: DtInvalid).
        /// [6] h(type: DtInvalid).
        /// </returns>
        public Operation BlockLSTM(Output seq_len_max, Output x, Output cs_prev, Output h_prev, Output w, Output wci, Output wcf, Output wco, Output b, float forget_bias = 1f, float cell_clip = 3f, bool use_peephole = false, String opName = "BlockLSTM") 
        {
            OperationDescription desc = NewOperation("BlockLSTM", opName);
            desc.AddInput(seq_len_max);
            desc.AddInput(x);
            desc.AddInput(cs_prev);
            desc.AddInput(h_prev);
            desc.AddInput(w);
            desc.AddInput(wci);
            desc.AddInput(wcf);
            desc.AddInput(wco);
            desc.AddInput(b);
            if (forget_bias != 1f)
                desc.SetAttr("forget_bias", forget_bias);
            if (cell_clip != 3f)
                desc.SetAttr("cell_clip", cell_clip);
            if (use_peephole != false)
                desc.SetAttr("use_peephole", use_peephole);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BlockLSTMGrad
        /// </summary>
        /// <param name="seq_len_max">Input to the operation. </param>
        /// <param name="x">Input to the operation. </param>
        /// <param name="cs_prev">Input to the operation. </param>
        /// <param name="h_prev">Input to the operation. </param>
        /// <param name="w">Input to the operation. </param>
        /// <param name="wci">Input to the operation. </param>
        /// <param name="wcf">Input to the operation. </param>
        /// <param name="wco">Input to the operation. </param>
        /// <param name="b">Input to the operation. </param>
        /// <param name="i">Input to the operation. </param>
        /// <param name="cs">Input to the operation. </param>
        /// <param name="f">Input to the operation. </param>
        /// <param name="o">Input to the operation. </param>
        /// <param name="ci">Input to the operation. </param>
        /// <param name="co">Input to the operation. </param>
        /// <param name="h">Input to the operation. </param>
        /// <param name="cs_grad">Input to the operation. </param>
        /// <param name="h_grad">Input to the operation. </param>
        /// <param name="use_peephole">use peephole</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] x_grad(type: DtInvalid).
        /// [1] cs_prev_grad(type: DtInvalid).
        /// [2] h_prev_grad(type: DtInvalid).
        /// [3] w_grad(type: DtInvalid).
        /// [4] wci_grad(type: DtInvalid).
        /// [5] wcf_grad(type: DtInvalid).
        /// [6] wco_grad(type: DtInvalid).
        /// [7] b_grad(type: DtInvalid).
        /// </returns>
        public Operation BlockLSTMGrad(Output seq_len_max, Output x, Output cs_prev, Output h_prev, Output w, Output wci, Output wcf, Output wco, Output b, Output i, Output cs, Output f, Output o, Output ci, Output co, Output h, Output cs_grad, Output h_grad, bool use_peephole, String opName = "BlockLSTMGrad") 
        {
            OperationDescription desc = NewOperation("BlockLSTMGrad", opName);
            desc.AddInput(seq_len_max);
            desc.AddInput(x);
            desc.AddInput(cs_prev);
            desc.AddInput(h_prev);
            desc.AddInput(w);
            desc.AddInput(wci);
            desc.AddInput(wcf);
            desc.AddInput(wco);
            desc.AddInput(b);
            desc.AddInput(i);
            desc.AddInput(cs);
            desc.AddInput(f);
            desc.AddInput(o);
            desc.AddInput(ci);
            desc.AddInput(co);
            desc.AddInput(h);
            desc.AddInput(cs_grad);
            desc.AddInput(h_grad);
            desc.SetAttr("use_peephole", use_peephole);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BlockLSTMGradV2
        /// </summary>
        /// <param name="seq_len_max">Input to the operation. </param>
        /// <param name="x">Input to the operation. </param>
        /// <param name="cs_prev">Input to the operation. </param>
        /// <param name="h_prev">Input to the operation. </param>
        /// <param name="w">Input to the operation. </param>
        /// <param name="wci">Input to the operation. </param>
        /// <param name="wcf">Input to the operation. </param>
        /// <param name="wco">Input to the operation. </param>
        /// <param name="b">Input to the operation. </param>
        /// <param name="i">Input to the operation. </param>
        /// <param name="cs">Input to the operation. </param>
        /// <param name="f">Input to the operation. </param>
        /// <param name="o">Input to the operation. </param>
        /// <param name="ci">Input to the operation. </param>
        /// <param name="co">Input to the operation. </param>
        /// <param name="h">Input to the operation. </param>
        /// <param name="cs_grad">Input to the operation. </param>
        /// <param name="h_grad">Input to the operation. </param>
        /// <param name="use_peephole">use peephole</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] x_grad(type: DtInvalid).
        /// [1] cs_prev_grad(type: DtInvalid).
        /// [2] h_prev_grad(type: DtInvalid).
        /// [3] w_grad(type: DtInvalid).
        /// [4] wci_grad(type: DtInvalid).
        /// [5] wcf_grad(type: DtInvalid).
        /// [6] wco_grad(type: DtInvalid).
        /// [7] b_grad(type: DtInvalid).
        /// </returns>
        public Operation BlockLSTMGradV2(Output seq_len_max, Output x, Output cs_prev, Output h_prev, Output w, Output wci, Output wcf, Output wco, Output b, Output i, Output cs, Output f, Output o, Output ci, Output co, Output h, Output cs_grad, Output h_grad, bool use_peephole, String opName = "BlockLSTMGradV2") 
        {
            OperationDescription desc = NewOperation("BlockLSTMGradV2", opName);
            desc.AddInput(seq_len_max);
            desc.AddInput(x);
            desc.AddInput(cs_prev);
            desc.AddInput(h_prev);
            desc.AddInput(w);
            desc.AddInput(wci);
            desc.AddInput(wcf);
            desc.AddInput(wco);
            desc.AddInput(b);
            desc.AddInput(i);
            desc.AddInput(cs);
            desc.AddInput(f);
            desc.AddInput(o);
            desc.AddInput(ci);
            desc.AddInput(co);
            desc.AddInput(h);
            desc.AddInput(cs_grad);
            desc.AddInput(h_grad);
            desc.SetAttr("use_peephole", use_peephole);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BlockLSTMV2
        /// </summary>
        /// <param name="seq_len_max">Input to the operation. </param>
        /// <param name="x">Input to the operation. </param>
        /// <param name="cs_prev">Input to the operation. </param>
        /// <param name="h_prev">Input to the operation. </param>
        /// <param name="w">Input to the operation. </param>
        /// <param name="wci">Input to the operation. </param>
        /// <param name="wcf">Input to the operation. </param>
        /// <param name="wco">Input to the operation. </param>
        /// <param name="b">Input to the operation. </param>
        /// <param name="cell_clip">cell clip</param>
        /// <param name="use_peephole">use peephole</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] i(type: DtInvalid).
        /// [1] cs(type: DtInvalid).
        /// [2] f(type: DtInvalid).
        /// [3] o(type: DtInvalid).
        /// [4] ci(type: DtInvalid).
        /// [5] co(type: DtInvalid).
        /// [6] h(type: DtInvalid).
        /// </returns>
        public Operation BlockLSTMV2(Output seq_len_max, Output x, Output cs_prev, Output h_prev, Output w, Output wci, Output wcf, Output wco, Output b, float cell_clip = 0f, bool use_peephole = false, String opName = "BlockLSTMV2") 
        {
            OperationDescription desc = NewOperation("BlockLSTMV2", opName);
            desc.AddInput(seq_len_max);
            desc.AddInput(x);
            desc.AddInput(cs_prev);
            desc.AddInput(h_prev);
            desc.AddInput(w);
            desc.AddInput(wci);
            desc.AddInput(wcf);
            desc.AddInput(wco);
            desc.AddInput(b);
            if (cell_clip != 0f)
                desc.SetAttr("cell_clip", cell_clip);
            if (use_peephole != false)
                desc.SetAttr("use_peephole", use_peephole);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BoostedTreesAggregateStats
        /// </summary>
        /// <param name="node_ids">Input to the operation. </param>
        /// <param name="gradients">Input to the operation. </param>
        /// <param name="hessians">Input to the operation. </param>
        /// <param name="feature">Input to the operation. </param>
        /// <param name="max_splits">max splits</param>
        /// <param name="num_buckets">num buckets</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] stats_summary(type: DtFloat).
        /// </returns>
        public Operation BoostedTreesAggregateStats(Output node_ids, Output gradients, Output hessians, Output feature, long max_splits, long num_buckets, String opName = "BoostedTreesAggregateStats") 
        {
            OperationDescription desc = NewOperation("BoostedTreesAggregateStats", opName);
            desc.AddInput(node_ids);
            desc.AddInput(gradients);
            desc.AddInput(hessians);
            desc.AddInput(feature);
            desc.SetAttr("max_splits", max_splits);
            desc.SetAttr("num_buckets", num_buckets);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BoostedTreesBucketize
        /// </summary>
        /// <param name="float_values">Input to the operation. </param>
        /// <param name="bucket_boundaries">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] buckets(type: DtInt32).
        /// </returns>
        public Operation BoostedTreesBucketize(Output float_values, Output bucket_boundaries, String opName = "BoostedTreesBucketize") 
        {
            OperationDescription desc = NewOperation("BoostedTreesBucketize", opName);
            desc.AddInput(float_values);
            desc.AddInput(bucket_boundaries);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BoostedTreesCalculateBestFeatureSplit
        /// </summary>
        /// <param name="node_id_range">Input to the operation. </param>
        /// <param name="stats_summary">Input to the operation. </param>
        /// <param name="l1">Input to the operation. </param>
        /// <param name="l2">Input to the operation. </param>
        /// <param name="tree_complexity">Input to the operation. </param>
        /// <param name="min_node_weight">Input to the operation. </param>
        /// <param name="logits_dimension">logits dimension</param>
        /// <param name="split_type">split type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] node_ids(type: DtInt32).
        /// [1] gains(type: DtFloat).
        /// [2] feature_dimensions(type: DtInt32).
        /// [3] thresholds(type: DtInt32).
        /// [4] left_node_contribs(type: DtFloat).
        /// [5] right_node_contribs(type: DtFloat).
        /// [6] split_with_default_directions(type: DtString).
        /// </returns>
        public Operation BoostedTreesCalculateBestFeatureSplit(Output node_id_range, Output stats_summary, Output l1, Output l2, Output tree_complexity, Output min_node_weight, long logits_dimension, string split_type = null, String opName = "BoostedTreesCalculateBestFeatureSplit") 
        {
            OperationDescription desc = NewOperation("BoostedTreesCalculateBestFeatureSplit", opName);
            desc.AddInput(node_id_range);
            desc.AddInput(stats_summary);
            desc.AddInput(l1);
            desc.AddInput(l2);
            desc.AddInput(tree_complexity);
            desc.AddInput(min_node_weight);
            desc.SetAttr("logits_dimension", logits_dimension);
            if (split_type != null)
                 desc.SetAttr("split_type", split_type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BoostedTreesCalculateBestFeatureSplitV2
        /// </summary>
        /// <param name="node_id_range">Input to the operation. </param>
        /// <param name="stats_summaries_list">Input to the operation. </param>
        /// <param name="split_types">Input to the operation. </param>
        /// <param name="candidate_feature_ids">Input to the operation. </param>
        /// <param name="l1">Input to the operation. </param>
        /// <param name="l2">Input to the operation. </param>
        /// <param name="tree_complexity">Input to the operation. </param>
        /// <param name="min_node_weight">Input to the operation. </param>
        /// <param name="logits_dimension">logits dimension</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] node_ids(type: DtInt32).
        /// [1] gains(type: DtFloat).
        /// [2] feature_ids(type: DtInt32).
        /// [3] feature_dimensions(type: DtInt32).
        /// [4] thresholds(type: DtInt32).
        /// [5] left_node_contribs(type: DtFloat).
        /// [6] right_node_contribs(type: DtFloat).
        /// [7] split_with_default_directions(type: DtString).
        /// </returns>
        public Operation BoostedTreesCalculateBestFeatureSplitV2(Output node_id_range, Output stats_summaries_list, Output split_types, Output candidate_feature_ids, Output l1, Output l2, Output tree_complexity, Output min_node_weight, long logits_dimension, String opName = "BoostedTreesCalculateBestFeatureSplitV2") 
        {
            OperationDescription desc = NewOperation("BoostedTreesCalculateBestFeatureSplitV2", opName);
            desc.AddInput(node_id_range);
            desc.AddInput(stats_summaries_list);
            desc.AddInput(split_types);
            desc.AddInput(candidate_feature_ids);
            desc.AddInput(l1);
            desc.AddInput(l2);
            desc.AddInput(tree_complexity);
            desc.AddInput(min_node_weight);
            desc.SetAttr("logits_dimension", logits_dimension);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BoostedTreesCalculateBestGainsPerFeature
        /// </summary>
        /// <param name="node_id_range">Input to the operation. </param>
        /// <param name="stats_summary_list">Input to the operation. </param>
        /// <param name="l1">Input to the operation. </param>
        /// <param name="l2">Input to the operation. </param>
        /// <param name="tree_complexity">Input to the operation. </param>
        /// <param name="min_node_weight">Input to the operation. </param>
        /// <param name="max_splits">max splits</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] node_ids_list(type: DtInt32).
        /// [1] gains_list(type: DtFloat).
        /// [2] thresholds_list(type: DtInt32).
        /// [3] left_node_contribs_list(type: DtFloat).
        /// [4] right_node_contribs_list(type: DtFloat).
        /// </returns>
        public Operation BoostedTreesCalculateBestGainsPerFeature(Output node_id_range, Output stats_summary_list, Output l1, Output l2, Output tree_complexity, Output min_node_weight, long max_splits, String opName = "BoostedTreesCalculateBestGainsPerFeature") 
        {
            OperationDescription desc = NewOperation("BoostedTreesCalculateBestGainsPerFeature", opName);
            desc.AddInput(node_id_range);
            desc.AddInput(stats_summary_list);
            desc.AddInput(l1);
            desc.AddInput(l2);
            desc.AddInput(tree_complexity);
            desc.AddInput(min_node_weight);
            desc.SetAttr("max_splits", max_splits);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BoostedTreesCenterBias
        /// </summary>
        /// <param name="tree_ensemble_handle">Input to the operation. </param>
        /// <param name="mean_gradients">Input to the operation. </param>
        /// <param name="mean_hessians">Input to the operation. </param>
        /// <param name="l1">Input to the operation. </param>
        /// <param name="l2">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] continue_centering(type: DtBool).
        /// </returns>
        public Operation BoostedTreesCenterBias(Output tree_ensemble_handle, Output mean_gradients, Output mean_hessians, Output l1, Output l2, String opName = "BoostedTreesCenterBias") 
        {
            OperationDescription desc = NewOperation("BoostedTreesCenterBias", opName);
            desc.AddInput(tree_ensemble_handle);
            desc.AddInput(mean_gradients);
            desc.AddInput(mean_hessians);
            desc.AddInput(l1);
            desc.AddInput(l2);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BoostedTreesCreateEnsemble
        /// </summary>
        /// <param name="tree_ensemble_handle">Input to the operation. </param>
        /// <param name="stamp_token">Input to the operation. </param>
        /// <param name="tree_ensemble_serialized">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation BoostedTreesCreateEnsemble(Output tree_ensemble_handle, Output stamp_token, Output tree_ensemble_serialized, String opName = "BoostedTreesCreateEnsemble") 
        {
            OperationDescription desc = NewOperation("BoostedTreesCreateEnsemble", opName);
            desc.AddInput(tree_ensemble_handle);
            desc.AddInput(stamp_token);
            desc.AddInput(tree_ensemble_serialized);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BoostedTreesCreateQuantileStreamResource
        /// </summary>
        /// <param name="quantile_stream_resource_handle">Input to the operation. </param>
        /// <param name="epsilon">Input to the operation. </param>
        /// <param name="num_streams">Input to the operation. </param>
        /// <param name="max_elements">max elements</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation BoostedTreesCreateQuantileStreamResource(Output quantile_stream_resource_handle, Output epsilon, Output num_streams, long max_elements = 1099511627776, String opName = "BoostedTreesCreateQuantileStreamResource") 
        {
            OperationDescription desc = NewOperation("BoostedTreesCreateQuantileStreamResource", opName);
            desc.AddInput(quantile_stream_resource_handle);
            desc.AddInput(epsilon);
            desc.AddInput(num_streams);
            if (max_elements != 1099511627776)
                desc.SetAttr("max_elements", max_elements);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BoostedTreesDeserializeEnsemble
        /// </summary>
        /// <param name="tree_ensemble_handle">Input to the operation. </param>
        /// <param name="stamp_token">Input to the operation. </param>
        /// <param name="tree_ensemble_serialized">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation BoostedTreesDeserializeEnsemble(Output tree_ensemble_handle, Output stamp_token, Output tree_ensemble_serialized, String opName = "BoostedTreesDeserializeEnsemble") 
        {
            OperationDescription desc = NewOperation("BoostedTreesDeserializeEnsemble", opName);
            desc.AddInput(tree_ensemble_handle);
            desc.AddInput(stamp_token);
            desc.AddInput(tree_ensemble_serialized);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BoostedTreesEnsembleResourceHandleOp
        /// </summary>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] resource(type: DtResource).
        /// </returns>
        public Operation BoostedTreesEnsembleResourceHandleOp(string container = null, string shared_name = null, String opName = "BoostedTreesEnsembleResourceHandleOp") 
        {
            OperationDescription desc = NewOperation("BoostedTreesEnsembleResourceHandleOp", opName);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BoostedTreesExampleDebugOutputs
        /// </summary>
        /// <param name="tree_ensemble_handle">Input to the operation. </param>
        /// <param name="bucketized_features">Input to the operation. </param>
        /// <param name="logits_dimension">logits dimension</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] examples_debug_outputs_serialized(type: DtString).
        /// </returns>
        public Operation BoostedTreesExampleDebugOutputs(Output tree_ensemble_handle, Output bucketized_features, long logits_dimension, String opName = "BoostedTreesExampleDebugOutputs") 
        {
            OperationDescription desc = NewOperation("BoostedTreesExampleDebugOutputs", opName);
            desc.AddInput(tree_ensemble_handle);
            desc.AddInput(bucketized_features);
            desc.SetAttr("logits_dimension", logits_dimension);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BoostedTreesFlushQuantileSummaries
        /// </summary>
        /// <param name="quantile_stream_resource_handle">Input to the operation. </param>
        /// <param name="num_features">num features</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] summaries(type: DtFloat).
        /// </returns>
        public Operation BoostedTreesFlushQuantileSummaries(Output quantile_stream_resource_handle, long num_features, String opName = "BoostedTreesFlushQuantileSummaries") 
        {
            OperationDescription desc = NewOperation("BoostedTreesFlushQuantileSummaries", opName);
            desc.AddInput(quantile_stream_resource_handle);
            desc.SetAttr("num_features", num_features);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BoostedTreesGetEnsembleStates
        /// </summary>
        /// <param name="tree_ensemble_handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] stamp_token(type: DtInt64).
        /// [1] num_trees(type: DtInt32).
        /// [2] num_finalized_trees(type: DtInt32).
        /// [3] num_attempted_layers(type: DtInt32).
        /// [4] last_layer_nodes_range(type: DtInt32).
        /// </returns>
        public Operation BoostedTreesGetEnsembleStates(Output tree_ensemble_handle, String opName = "BoostedTreesGetEnsembleStates") 
        {
            OperationDescription desc = NewOperation("BoostedTreesGetEnsembleStates", opName);
            desc.AddInput(tree_ensemble_handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BoostedTreesMakeQuantileSummaries
        /// </summary>
        /// <param name="float_values">Input to the operation. </param>
        /// <param name="example_weights">Input to the operation. </param>
        /// <param name="epsilon">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] summaries(type: DtFloat).
        /// </returns>
        public Operation BoostedTreesMakeQuantileSummaries(Output float_values, Output example_weights, Output epsilon, String opName = "BoostedTreesMakeQuantileSummaries") 
        {
            OperationDescription desc = NewOperation("BoostedTreesMakeQuantileSummaries", opName);
            desc.AddInput(float_values);
            desc.AddInput(example_weights);
            desc.AddInput(epsilon);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BoostedTreesMakeStatsSummary
        /// </summary>
        /// <param name="node_ids">Input to the operation. </param>
        /// <param name="gradients">Input to the operation. </param>
        /// <param name="hessians">Input to the operation. </param>
        /// <param name="bucketized_features_list">Input to the operation. </param>
        /// <param name="max_splits">max splits</param>
        /// <param name="num_buckets">num buckets</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] stats_summary(type: DtFloat).
        /// </returns>
        public Operation BoostedTreesMakeStatsSummary(Output node_ids, Output gradients, Output hessians, Output bucketized_features_list, long max_splits, long num_buckets, String opName = "BoostedTreesMakeStatsSummary") 
        {
            OperationDescription desc = NewOperation("BoostedTreesMakeStatsSummary", opName);
            desc.AddInput(node_ids);
            desc.AddInput(gradients);
            desc.AddInput(hessians);
            desc.AddInput(bucketized_features_list);
            desc.SetAttr("max_splits", max_splits);
            desc.SetAttr("num_buckets", num_buckets);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BoostedTreesPredict
        /// </summary>
        /// <param name="tree_ensemble_handle">Input to the operation. </param>
        /// <param name="bucketized_features">Input to the operation. </param>
        /// <param name="logits_dimension">logits dimension</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] logits(type: DtFloat).
        /// </returns>
        public Operation BoostedTreesPredict(Output tree_ensemble_handle, Output bucketized_features, long logits_dimension, String opName = "BoostedTreesPredict") 
        {
            OperationDescription desc = NewOperation("BoostedTreesPredict", opName);
            desc.AddInput(tree_ensemble_handle);
            desc.AddInput(bucketized_features);
            desc.SetAttr("logits_dimension", logits_dimension);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BoostedTreesQuantileStreamResourceAddSummaries
        /// </summary>
        /// <param name="quantile_stream_resource_handle">Input to the operation. </param>
        /// <param name="summaries">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation BoostedTreesQuantileStreamResourceAddSummaries(Output quantile_stream_resource_handle, Output summaries, String opName = "BoostedTreesQuantileStreamResourceAddSummaries") 
        {
            OperationDescription desc = NewOperation("BoostedTreesQuantileStreamResourceAddSummaries", opName);
            desc.AddInput(quantile_stream_resource_handle);
            desc.AddInput(summaries);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BoostedTreesQuantileStreamResourceDeserialize
        /// </summary>
        /// <param name="quantile_stream_resource_handle">Input to the operation. </param>
        /// <param name="bucket_boundaries">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation BoostedTreesQuantileStreamResourceDeserialize(Output quantile_stream_resource_handle, Output bucket_boundaries, String opName = "BoostedTreesQuantileStreamResourceDeserialize") 
        {
            OperationDescription desc = NewOperation("BoostedTreesQuantileStreamResourceDeserialize", opName);
            desc.AddInput(quantile_stream_resource_handle);
            desc.AddInput(bucket_boundaries);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BoostedTreesQuantileStreamResourceFlush
        /// </summary>
        /// <param name="quantile_stream_resource_handle">Input to the operation. </param>
        /// <param name="num_buckets">Input to the operation. </param>
        /// <param name="generate_quantiles">generate quantiles</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation BoostedTreesQuantileStreamResourceFlush(Output quantile_stream_resource_handle, Output num_buckets, bool generate_quantiles = false, String opName = "BoostedTreesQuantileStreamResourceFlush") 
        {
            OperationDescription desc = NewOperation("BoostedTreesQuantileStreamResourceFlush", opName);
            desc.AddInput(quantile_stream_resource_handle);
            desc.AddInput(num_buckets);
            if (generate_quantiles != false)
                desc.SetAttr("generate_quantiles", generate_quantiles);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BoostedTreesQuantileStreamResourceGetBucketBoundaries
        /// </summary>
        /// <param name="quantile_stream_resource_handle">Input to the operation. </param>
        /// <param name="num_features">num features</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] bucket_boundaries(type: DtFloat).
        /// </returns>
        public Operation BoostedTreesQuantileStreamResourceGetBucketBoundaries(Output quantile_stream_resource_handle, long num_features, String opName = "BoostedTreesQuantileStreamResourceGetBucketBoundaries") 
        {
            OperationDescription desc = NewOperation("BoostedTreesQuantileStreamResourceGetBucketBoundaries", opName);
            desc.AddInput(quantile_stream_resource_handle);
            desc.SetAttr("num_features", num_features);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BoostedTreesQuantileStreamResourceHandleOp
        /// </summary>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] resource(type: DtResource).
        /// </returns>
        public Operation BoostedTreesQuantileStreamResourceHandleOp(string container = null, string shared_name = null, String opName = "BoostedTreesQuantileStreamResourceHandleOp") 
        {
            OperationDescription desc = NewOperation("BoostedTreesQuantileStreamResourceHandleOp", opName);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BoostedTreesSerializeEnsemble
        /// </summary>
        /// <param name="tree_ensemble_handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] stamp_token(type: DtInt64).
        /// [1] tree_ensemble_serialized(type: DtString).
        /// </returns>
        public Operation BoostedTreesSerializeEnsemble(Output tree_ensemble_handle, String opName = "BoostedTreesSerializeEnsemble") 
        {
            OperationDescription desc = NewOperation("BoostedTreesSerializeEnsemble", opName);
            desc.AddInput(tree_ensemble_handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BoostedTreesSparseAggregateStats
        /// </summary>
        /// <param name="node_ids">Input to the operation. </param>
        /// <param name="gradients">Input to the operation. </param>
        /// <param name="hessians">Input to the operation. </param>
        /// <param name="feature_indices">Input to the operation. </param>
        /// <param name="feature_values">Input to the operation. </param>
        /// <param name="feature_shape">Input to the operation. </param>
        /// <param name="max_splits">max splits</param>
        /// <param name="num_buckets">num buckets</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] stats_summary_indices(type: DtInt32).
        /// [1] stats_summary_values(type: DtFloat).
        /// [2] stats_summary_shape(type: DtInt32).
        /// </returns>
        public Operation BoostedTreesSparseAggregateStats(Output node_ids, Output gradients, Output hessians, Output feature_indices, Output feature_values, Output feature_shape, long max_splits, long num_buckets, String opName = "BoostedTreesSparseAggregateStats") 
        {
            OperationDescription desc = NewOperation("BoostedTreesSparseAggregateStats", opName);
            desc.AddInput(node_ids);
            desc.AddInput(gradients);
            desc.AddInput(hessians);
            desc.AddInput(feature_indices);
            desc.AddInput(feature_values);
            desc.AddInput(feature_shape);
            desc.SetAttr("max_splits", max_splits);
            desc.SetAttr("num_buckets", num_buckets);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BoostedTreesSparseCalculateBestFeatureSplit
        /// </summary>
        /// <param name="node_id_range">Input to the operation. </param>
        /// <param name="stats_summary_indices">Input to the operation. </param>
        /// <param name="stats_summary_values">Input to the operation. </param>
        /// <param name="stats_summary_shape">Input to the operation. </param>
        /// <param name="l1">Input to the operation. </param>
        /// <param name="l2">Input to the operation. </param>
        /// <param name="tree_complexity">Input to the operation. </param>
        /// <param name="min_node_weight">Input to the operation. </param>
        /// <param name="logits_dimension">logits dimension</param>
        /// <param name="split_type">split type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] node_ids(type: DtInt32).
        /// [1] gains(type: DtFloat).
        /// [2] feature_dimensions(type: DtInt32).
        /// [3] thresholds(type: DtInt32).
        /// [4] left_node_contribs(type: DtFloat).
        /// [5] right_node_contribs(type: DtFloat).
        /// [6] split_with_default_directions(type: DtString).
        /// </returns>
        public Operation BoostedTreesSparseCalculateBestFeatureSplit(Output node_id_range, Output stats_summary_indices, Output stats_summary_values, Output stats_summary_shape, Output l1, Output l2, Output tree_complexity, Output min_node_weight, long logits_dimension, string split_type = null, String opName = "BoostedTreesSparseCalculateBestFeatureSplit") 
        {
            OperationDescription desc = NewOperation("BoostedTreesSparseCalculateBestFeatureSplit", opName);
            desc.AddInput(node_id_range);
            desc.AddInput(stats_summary_indices);
            desc.AddInput(stats_summary_values);
            desc.AddInput(stats_summary_shape);
            desc.AddInput(l1);
            desc.AddInput(l2);
            desc.AddInput(tree_complexity);
            desc.AddInput(min_node_weight);
            desc.SetAttr("logits_dimension", logits_dimension);
            if (split_type != null)
                 desc.SetAttr("split_type", split_type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BoostedTreesTrainingPredict
        /// </summary>
        /// <param name="tree_ensemble_handle">Input to the operation. </param>
        /// <param name="cached_tree_ids">Input to the operation. </param>
        /// <param name="cached_node_ids">Input to the operation. </param>
        /// <param name="bucketized_features">Input to the operation. </param>
        /// <param name="logits_dimension">logits dimension</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] partial_logits(type: DtFloat).
        /// [1] tree_ids(type: DtInt32).
        /// [2] node_ids(type: DtInt32).
        /// </returns>
        public Operation BoostedTreesTrainingPredict(Output tree_ensemble_handle, Output cached_tree_ids, Output cached_node_ids, Output bucketized_features, long logits_dimension, String opName = "BoostedTreesTrainingPredict") 
        {
            OperationDescription desc = NewOperation("BoostedTreesTrainingPredict", opName);
            desc.AddInput(tree_ensemble_handle);
            desc.AddInput(cached_tree_ids);
            desc.AddInput(cached_node_ids);
            desc.AddInput(bucketized_features);
            desc.SetAttr("logits_dimension", logits_dimension);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BoostedTreesUpdateEnsemble
        /// </summary>
        /// <param name="tree_ensemble_handle">Input to the operation. </param>
        /// <param name="feature_ids">Input to the operation. </param>
        /// <param name="node_ids">Input to the operation. </param>
        /// <param name="gains">Input to the operation. </param>
        /// <param name="thresholds">Input to the operation. </param>
        /// <param name="left_node_contribs">Input to the operation. </param>
        /// <param name="right_node_contribs">Input to the operation. </param>
        /// <param name="max_depth">Input to the operation. </param>
        /// <param name="learning_rate">Input to the operation. </param>
        /// <param name="pruning_mode">pruning mode</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation BoostedTreesUpdateEnsemble(Output tree_ensemble_handle, Output feature_ids, Output node_ids, Output gains, Output thresholds, Output left_node_contribs, Output right_node_contribs, Output max_depth, Output learning_rate, long pruning_mode, String opName = "BoostedTreesUpdateEnsemble") 
        {
            OperationDescription desc = NewOperation("BoostedTreesUpdateEnsemble", opName);
            desc.AddInput(tree_ensemble_handle);
            desc.AddInput(feature_ids);
            desc.AddInput(node_ids);
            desc.AddInput(gains);
            desc.AddInput(thresholds);
            desc.AddInput(left_node_contribs);
            desc.AddInput(right_node_contribs);
            desc.AddInput(max_depth);
            desc.AddInput(learning_rate);
            desc.SetAttr("pruning_mode", pruning_mode);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BoostedTreesUpdateEnsembleV2
        /// </summary>
        /// <param name="tree_ensemble_handle">Input to the operation. </param>
        /// <param name="feature_ids">Input to the operation. </param>
        /// <param name="dimension_ids">Input to the operation. </param>
        /// <param name="node_ids">Input to the operation. </param>
        /// <param name="gains">Input to the operation. </param>
        /// <param name="thresholds">Input to the operation. </param>
        /// <param name="left_node_contribs">Input to the operation. </param>
        /// <param name="right_node_contribs">Input to the operation. </param>
        /// <param name="split_types">Input to the operation. </param>
        /// <param name="max_depth">Input to the operation. </param>
        /// <param name="learning_rate">Input to the operation. </param>
        /// <param name="pruning_mode">Input to the operation. </param>
        /// <param name="logits_dimension">logits dimension</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation BoostedTreesUpdateEnsembleV2(Output tree_ensemble_handle, Output feature_ids, Output dimension_ids, Output node_ids, Output gains, Output thresholds, Output left_node_contribs, Output right_node_contribs, Output split_types, Output max_depth, Output learning_rate, Output pruning_mode, long logits_dimension = 1, String opName = "BoostedTreesUpdateEnsembleV2") 
        {
            OperationDescription desc = NewOperation("BoostedTreesUpdateEnsembleV2", opName);
            desc.AddInput(tree_ensemble_handle);
            desc.AddInput(feature_ids);
            desc.AddInput(dimension_ids);
            desc.AddInput(node_ids);
            desc.AddInput(gains);
            desc.AddInput(thresholds);
            desc.AddInput(left_node_contribs);
            desc.AddInput(right_node_contribs);
            desc.AddInput(split_types);
            desc.AddInput(max_depth);
            desc.AddInput(learning_rate);
            desc.AddInput(pruning_mode);
            if (logits_dimension != 1)
                desc.SetAttr("logits_dimension", logits_dimension);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BroadcastArgs
        /// </summary>
        /// <param name="s0">Input to the operation. </param>
        /// <param name="s1">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] r0(type: DtInvalid).
        /// </returns>
        public Operation BroadcastArgs(Output s0, Output s1, String opName = "BroadcastArgs") 
        {
            OperationDescription desc = NewOperation("BroadcastArgs", opName);
            desc.AddInput(s0);
            desc.AddInput(s1);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BroadcastGradientArgs
        /// </summary>
        /// <param name="s0">Input to the operation. </param>
        /// <param name="s1">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] r0(type: DtInvalid).
        /// [1] r1(type: DtInvalid).
        /// </returns>
        public Operation BroadcastGradientArgs(Output s0, Output s1, String opName = "BroadcastGradientArgs") 
        {
            OperationDescription desc = NewOperation("BroadcastGradientArgs", opName);
            desc.AddInput(s0);
            desc.AddInput(s1);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BroadcastTo
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation BroadcastTo(Output input, Output shape, String opName = "BroadcastTo") 
        {
            OperationDescription desc = NewOperation("BroadcastTo", opName);
            desc.AddInput(input);
            desc.AddInput(shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Bucketize
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="boundaries">boundaries</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInt32).
        /// </returns>
        public Operation Bucketize(Output input, float[] boundaries, String opName = "Bucketize") 
        {
            OperationDescription desc = NewOperation("Bucketize", opName);
            desc.AddInput(input);
            desc.SetAttr("boundaries", boundaries);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// BytesProducedStatsDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="tag">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation BytesProducedStatsDataset(Output input_dataset, Output tag, DataType[] output_types, long[][] output_shapes, String opName = "BytesProducedStatsDataset") 
        {
            OperationDescription desc = NewOperation("BytesProducedStatsDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(tag);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CacheDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="filename">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation CacheDataset(Output input_dataset, Output filename, DataType[] output_types, long[][] output_shapes, string metadata = null, String opName = "CacheDataset") 
        {
            OperationDescription desc = NewOperation("CacheDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(filename);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CacheDatasetV2
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="filename">Input to the operation. </param>
        /// <param name="cache">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation CacheDatasetV2(Output input_dataset, Output filename, Output cache, DataType[] output_types, long[][] output_shapes, string metadata = null, String opName = "CacheDatasetV2") 
        {
            OperationDescription desc = NewOperation("CacheDatasetV2", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(filename);
            desc.AddInput(cache);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Case
        /// </summary>
        /// <param name="branch_index">Input to the operation. </param>
        /// <param name="input">Input to the operation. </param>
        /// <param name="Tout">Tout</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        // The following attributes are not known: branches: list(func)
        public Operation Case(Output branch_index, Output input, DataType[] Tout, long[][] output_shapes = null, String opName = "Case") 
        {
            OperationDescription desc = NewOperation("Case", opName);
            desc.AddInput(branch_index);
            desc.AddInput(input);
            desc.SetAttr("Tout", Tout);
            if (output_shapes != null) desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Cast
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="DstT">DstT</param>
        /// <param name="Truncate">Truncate</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Cast(Output x, DataType DstT, bool Truncate = false, String opName = "Cast") 
        {
            OperationDescription desc = NewOperation("Cast", opName);
            desc.AddInput(x);
            desc.SetAttr("DstT", DstT);
            if (Truncate != false)
                desc.SetAttr("Truncate", Truncate);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Ceil
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Ceil(Output x, String opName = "Ceil") 
        {
            OperationDescription desc = NewOperation("Ceil", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CheckNumerics
        /// </summary>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="message">message</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation CheckNumerics(Output tensor, string message, String opName = "CheckNumerics") 
        {
            OperationDescription desc = NewOperation("CheckNumerics", opName);
            desc.AddInput(tensor);
            desc.SetAttr("message", message);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CheckNumericsV2
        /// </summary>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="message">message</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation CheckNumericsV2(Output tensor, string message, String opName = "CheckNumericsV2") 
        {
            OperationDescription desc = NewOperation("CheckNumericsV2", opName);
            desc.AddInput(tensor);
            desc.SetAttr("message", message);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Cholesky
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Cholesky(Output input, String opName = "Cholesky") 
        {
            OperationDescription desc = NewOperation("Cholesky", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CholeskyGrad
        /// </summary>
        /// <param name="l">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation CholeskyGrad(Output l, Output grad, String opName = "CholeskyGrad") 
        {
            OperationDescription desc = NewOperation("CholeskyGrad", opName);
            desc.AddInput(l);
            desc.AddInput(grad);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ChooseFastestBranchDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="ratio_numerator">Input to the operation. </param>
        /// <param name="ratio_denominator">Input to the operation. </param>
        /// <param name="other_arguments">Input to the operation. </param>
        /// <param name="num_elements_per_branch">num elements per branch</param>
        /// <param name="other_arguments_lengths">other arguments lengths</param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: branches: list(func)
        public Operation ChooseFastestBranchDataset(Output input_dataset, Output ratio_numerator, Output ratio_denominator, Output other_arguments, long num_elements_per_branch, long[] other_arguments_lengths, DataType[] output_types, long[][] output_shapes, String opName = "ChooseFastestBranchDataset") 
        {
            OperationDescription desc = NewOperation("ChooseFastestBranchDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(ratio_numerator);
            desc.AddInput(ratio_denominator);
            desc.AddInput(other_arguments);
            desc.SetAttr("num_elements_per_branch", num_elements_per_branch);
            desc.SetAttr("other_arguments_lengths", other_arguments_lengths);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ChooseFastestDataset
        /// </summary>
        /// <param name="input_datasets">Input to the operation. </param>
        /// <param name="num_experiments">num experiments</param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ChooseFastestDataset(Output input_datasets, long num_experiments, DataType[] output_types, long[][] output_shapes, String opName = "ChooseFastestDataset") 
        {
            OperationDescription desc = NewOperation("ChooseFastestDataset", opName);
            desc.AddInput(input_datasets);
            desc.SetAttr("num_experiments", num_experiments);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ClipByValue
        /// </summary>
        /// <param name="t">Input to the operation. </param>
        /// <param name="clip_value_min">Input to the operation. </param>
        /// <param name="clip_value_max">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation ClipByValue(Output t, Output clip_value_min, Output clip_value_max, String opName = "ClipByValue") 
        {
            OperationDescription desc = NewOperation("ClipByValue", opName);
            desc.AddInput(t);
            desc.AddInput(clip_value_min);
            desc.AddInput(clip_value_max);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CloseSummaryWriter
        /// </summary>
        /// <param name="writer">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation CloseSummaryWriter(Output writer, String opName = "CloseSummaryWriter") 
        {
            OperationDescription desc = NewOperation("CloseSummaryWriter", opName);
            desc.AddInput(writer);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CollateTPUEmbeddingMemory
        /// </summary>
        /// <param name="memory_configs">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] merged_memory_config(type: DtString).
        /// </returns>
        public Operation CollateTPUEmbeddingMemory(Output memory_configs, String opName = "CollateTPUEmbeddingMemory") 
        {
            OperationDescription desc = NewOperation("CollateTPUEmbeddingMemory", opName);
            desc.AddInput(memory_configs);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CollectiveAllToAllV2
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="group_size">Input to the operation. </param>
        /// <param name="group_key">Input to the operation. </param>
        /// <param name="instance_key">Input to the operation. </param>
        /// <param name="ordering_token">Input to the operation. </param>
        /// <param name="communication_hint">communication hint</param>
        /// <param name="timeout_seconds">timeout seconds</param>
        /// <param name="is_stateless">is stateless</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] data(type: DtInvalid).
        /// </returns>
        public Operation CollectiveAllToAllV2(Output input, Output group_size, Output group_key, Output instance_key, Output ordering_token, string communication_hint = null, float timeout_seconds = 0f, bool is_stateless = false, String opName = "CollectiveAllToAllV2") 
        {
            OperationDescription desc = NewOperation("CollectiveAllToAllV2", opName);
            desc.AddInput(input);
            desc.AddInput(group_size);
            desc.AddInput(group_key);
            desc.AddInput(instance_key);
            desc.AddInput(ordering_token);
            if (communication_hint != null)
                 desc.SetAttr("communication_hint", communication_hint);
            if (timeout_seconds != 0f)
                desc.SetAttr("timeout_seconds", timeout_seconds);
            if (is_stateless != false)
                desc.SetAttr("is_stateless", is_stateless);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CollectiveAllToAllV3
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="communicator">Input to the operation. </param>
        /// <param name="group_assignment">Input to the operation. </param>
        /// <param name="timeout_seconds">timeout seconds</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] data(type: DtInvalid).
        /// </returns>
        public Operation CollectiveAllToAllV3(Output input, Output communicator, Output group_assignment, float timeout_seconds = 0f, String opName = "CollectiveAllToAllV3") 
        {
            OperationDescription desc = NewOperation("CollectiveAllToAllV3", opName);
            desc.AddInput(input);
            desc.AddInput(communicator);
            desc.AddInput(group_assignment);
            if (timeout_seconds != 0f)
                desc.SetAttr("timeout_seconds", timeout_seconds);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CollectiveAssignGroupV2
        /// </summary>
        /// <param name="group_assignment">Input to the operation. </param>
        /// <param name="device_index">Input to the operation. </param>
        /// <param name="base_key">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] group_size(type: DtInt32).
        /// [1] group_key(type: DtInt32).
        /// </returns>
        public Operation CollectiveAssignGroupV2(Output group_assignment, Output device_index, Output base_key, String opName = "CollectiveAssignGroupV2") 
        {
            OperationDescription desc = NewOperation("CollectiveAssignGroupV2", opName);
            desc.AddInput(group_assignment);
            desc.AddInput(device_index);
            desc.AddInput(base_key);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CollectiveBcastRecv
        /// </summary>
        /// <param name="T">T</param>
        /// <param name="group_size">group size</param>
        /// <param name="group_key">group key</param>
        /// <param name="instance_key">instance key</param>
        /// <param name="shape">shape</param>
        /// <param name="communication_hint">communication hint</param>
        /// <param name="timeout_seconds">timeout seconds</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] data(type: DtInvalid).
        /// </returns>
        public Operation CollectiveBcastRecv(DataType T, long group_size, long group_key, long instance_key, long[] shape, string communication_hint = null, float timeout_seconds = 0f, String opName = "CollectiveBcastRecv") 
        {
            OperationDescription desc = NewOperation("CollectiveBcastRecv", opName);
            desc.SetAttr("T", T);
            desc.SetAttr("group_size", group_size);
            desc.SetAttr("group_key", group_key);
            desc.SetAttr("instance_key", instance_key);
            desc.SetAttrShape("shape", shape);
            if (communication_hint != null)
                 desc.SetAttr("communication_hint", communication_hint);
            if (timeout_seconds != 0f)
                desc.SetAttr("timeout_seconds", timeout_seconds);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CollectiveBcastRecvV2
        /// </summary>
        /// <param name="group_size">Input to the operation. </param>
        /// <param name="group_key">Input to the operation. </param>
        /// <param name="instance_key">Input to the operation. </param>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="T">T</param>
        /// <param name="communication_hint">communication hint</param>
        /// <param name="timeout_seconds">timeout seconds</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] data(type: DtInvalid).
        /// </returns>
        public Operation CollectiveBcastRecvV2(Output group_size, Output group_key, Output instance_key, Output shape, DataType T, string communication_hint = null, float timeout_seconds = 0f, String opName = "CollectiveBcastRecvV2") 
        {
            OperationDescription desc = NewOperation("CollectiveBcastRecvV2", opName);
            desc.AddInput(group_size);
            desc.AddInput(group_key);
            desc.AddInput(instance_key);
            desc.AddInput(shape);
            desc.SetAttr("T", T);
            if (communication_hint != null)
                 desc.SetAttr("communication_hint", communication_hint);
            if (timeout_seconds != 0f)
                desc.SetAttr("timeout_seconds", timeout_seconds);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CollectiveBcastSend
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="group_size">group size</param>
        /// <param name="group_key">group key</param>
        /// <param name="instance_key">instance key</param>
        /// <param name="shape">shape</param>
        /// <param name="communication_hint">communication hint</param>
        /// <param name="timeout_seconds">timeout seconds</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] data(type: DtInvalid).
        /// </returns>
        public Operation CollectiveBcastSend(Output input, long group_size, long group_key, long instance_key, long[] shape, string communication_hint = null, float timeout_seconds = 0f, String opName = "CollectiveBcastSend") 
        {
            OperationDescription desc = NewOperation("CollectiveBcastSend", opName);
            desc.AddInput(input);
            desc.SetAttr("group_size", group_size);
            desc.SetAttr("group_key", group_key);
            desc.SetAttr("instance_key", instance_key);
            desc.SetAttrShape("shape", shape);
            if (communication_hint != null)
                 desc.SetAttr("communication_hint", communication_hint);
            if (timeout_seconds != 0f)
                desc.SetAttr("timeout_seconds", timeout_seconds);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CollectiveBcastSendV2
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="group_size">Input to the operation. </param>
        /// <param name="group_key">Input to the operation. </param>
        /// <param name="instance_key">Input to the operation. </param>
        /// <param name="communication_hint">communication hint</param>
        /// <param name="timeout_seconds">timeout seconds</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] data(type: DtInvalid).
        /// </returns>
        public Operation CollectiveBcastSendV2(Output input, Output group_size, Output group_key, Output instance_key, string communication_hint = null, float timeout_seconds = 0f, String opName = "CollectiveBcastSendV2") 
        {
            OperationDescription desc = NewOperation("CollectiveBcastSendV2", opName);
            desc.AddInput(input);
            desc.AddInput(group_size);
            desc.AddInput(group_key);
            desc.AddInput(instance_key);
            if (communication_hint != null)
                 desc.SetAttr("communication_hint", communication_hint);
            if (timeout_seconds != 0f)
                desc.SetAttr("timeout_seconds", timeout_seconds);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CollectiveGather
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="group_size">group size</param>
        /// <param name="group_key">group key</param>
        /// <param name="instance_key">instance key</param>
        /// <param name="shape">shape</param>
        /// <param name="communication_hint">communication hint</param>
        /// <param name="timeout_seconds">timeout seconds</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] data(type: DtInvalid).
        /// </returns>
        public Operation CollectiveGather(Output input, long group_size, long group_key, long instance_key, long[] shape, string communication_hint = null, float timeout_seconds = 0f, String opName = "CollectiveGather") 
        {
            OperationDescription desc = NewOperation("CollectiveGather", opName);
            desc.AddInput(input);
            desc.SetAttr("group_size", group_size);
            desc.SetAttr("group_key", group_key);
            desc.SetAttr("instance_key", instance_key);
            desc.SetAttrShape("shape", shape);
            if (communication_hint != null)
                 desc.SetAttr("communication_hint", communication_hint);
            if (timeout_seconds != 0f)
                desc.SetAttr("timeout_seconds", timeout_seconds);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CollectiveGatherV2
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="group_size">Input to the operation. </param>
        /// <param name="group_key">Input to the operation. </param>
        /// <param name="instance_key">Input to the operation. </param>
        /// <param name="ordering_token">Input to the operation. </param>
        /// <param name="communication_hint">communication hint</param>
        /// <param name="timeout_seconds">timeout seconds</param>
        /// <param name="is_stateless">is stateless</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] data(type: DtInvalid).
        /// </returns>
        public Operation CollectiveGatherV2(Output input, Output group_size, Output group_key, Output instance_key, Output ordering_token, string communication_hint = null, float timeout_seconds = 0f, bool is_stateless = false, String opName = "CollectiveGatherV2") 
        {
            OperationDescription desc = NewOperation("CollectiveGatherV2", opName);
            desc.AddInput(input);
            desc.AddInput(group_size);
            desc.AddInput(group_key);
            desc.AddInput(instance_key);
            desc.AddInput(ordering_token);
            if (communication_hint != null)
                 desc.SetAttr("communication_hint", communication_hint);
            if (timeout_seconds != 0f)
                desc.SetAttr("timeout_seconds", timeout_seconds);
            if (is_stateless != false)
                desc.SetAttr("is_stateless", is_stateless);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CollectiveInitializeCommunicator
        /// </summary>
        /// <param name="group_key">Input to the operation. </param>
        /// <param name="rank">Input to the operation. </param>
        /// <param name="group_size">Input to the operation. </param>
        /// <param name="communication_hint">communication hint</param>
        /// <param name="timeout_seconds">timeout seconds</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] communicator(type: DtResource).
        /// </returns>
        public Operation CollectiveInitializeCommunicator(Output group_key, Output rank, Output group_size, string communication_hint = null, float timeout_seconds = 0f, String opName = "CollectiveInitializeCommunicator") 
        {
            OperationDescription desc = NewOperation("CollectiveInitializeCommunicator", opName);
            desc.AddInput(group_key);
            desc.AddInput(rank);
            desc.AddInput(group_size);
            if (communication_hint != null)
                 desc.SetAttr("communication_hint", communication_hint);
            if (timeout_seconds != 0f)
                desc.SetAttr("timeout_seconds", timeout_seconds);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CollectivePermute
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="source_target_pairs">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation CollectivePermute(Output input, Output source_target_pairs, String opName = "CollectivePermute") 
        {
            OperationDescription desc = NewOperation("CollectivePermute", opName);
            desc.AddInput(input);
            desc.AddInput(source_target_pairs);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CollectiveReduce
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="group_size">group size</param>
        /// <param name="group_key">group key</param>
        /// <param name="instance_key">instance key</param>
        /// <param name="merge_op">merge op</param>
        /// <param name="final_op">final op</param>
        /// <param name="subdiv_offsets">subdiv offsets</param>
        /// <param name="wait_for">wait for</param>
        /// <param name="communication_hint">communication hint</param>
        /// <param name="timeout_seconds">timeout seconds</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] data(type: DtInvalid).
        /// </returns>
        public Operation CollectiveReduce(Output input, long group_size, long group_key, long instance_key, string merge_op, string final_op, long[] subdiv_offsets, long[] wait_for = null, string communication_hint = null, float timeout_seconds = 0f, String opName = "CollectiveReduce") 
        {
            OperationDescription desc = NewOperation("CollectiveReduce", opName);
            desc.AddInput(input);
            desc.SetAttr("group_size", group_size);
            desc.SetAttr("group_key", group_key);
            desc.SetAttr("instance_key", instance_key);
            desc.SetAttr("merge_op", merge_op);
            desc.SetAttr("final_op", final_op);
            desc.SetAttr("subdiv_offsets", subdiv_offsets);
            if (wait_for != null) desc.SetAttr("wait_for", wait_for);
            if (communication_hint != null)
                 desc.SetAttr("communication_hint", communication_hint);
            if (timeout_seconds != 0f)
                desc.SetAttr("timeout_seconds", timeout_seconds);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CollectiveReduceScatterV2
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="group_size">Input to the operation. </param>
        /// <param name="group_key">Input to the operation. </param>
        /// <param name="instance_key">Input to the operation. </param>
        /// <param name="ordering_token">Input to the operation. </param>
        /// <param name="merge_op">merge op</param>
        /// <param name="final_op">final op</param>
        /// <param name="communication_hint">communication hint</param>
        /// <param name="timeout_seconds">timeout seconds</param>
        /// <param name="is_stateless">is stateless</param>
        /// <param name="max_subdivs_per_device">max subdivs per device</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] data(type: DtInvalid).
        /// </returns>
        public Operation CollectiveReduceScatterV2(Output input, Output group_size, Output group_key, Output instance_key, Output ordering_token, string merge_op, string final_op, string communication_hint = null, float timeout_seconds = 0f, bool is_stateless = false, long max_subdivs_per_device = -1, String opName = "CollectiveReduceScatterV2") 
        {
            OperationDescription desc = NewOperation("CollectiveReduceScatterV2", opName);
            desc.AddInput(input);
            desc.AddInput(group_size);
            desc.AddInput(group_key);
            desc.AddInput(instance_key);
            desc.AddInput(ordering_token);
            desc.SetAttr("merge_op", merge_op);
            desc.SetAttr("final_op", final_op);
            if (communication_hint != null)
                 desc.SetAttr("communication_hint", communication_hint);
            if (timeout_seconds != 0f)
                desc.SetAttr("timeout_seconds", timeout_seconds);
            if (is_stateless != false)
                desc.SetAttr("is_stateless", is_stateless);
            if (max_subdivs_per_device != -1)
                desc.SetAttr("max_subdivs_per_device", max_subdivs_per_device);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CollectiveReduceV2
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="group_size">Input to the operation. </param>
        /// <param name="group_key">Input to the operation. </param>
        /// <param name="instance_key">Input to the operation. </param>
        /// <param name="ordering_token">Input to the operation. </param>
        /// <param name="merge_op">merge op</param>
        /// <param name="final_op">final op</param>
        /// <param name="communication_hint">communication hint</param>
        /// <param name="timeout_seconds">timeout seconds</param>
        /// <param name="is_stateless">is stateless</param>
        /// <param name="max_subdivs_per_device">max subdivs per device</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] data(type: DtInvalid).
        /// </returns>
        public Operation CollectiveReduceV2(Output input, Output group_size, Output group_key, Output instance_key, Output ordering_token, string merge_op, string final_op, string communication_hint = null, float timeout_seconds = 0f, bool is_stateless = false, long max_subdivs_per_device = -1, String opName = "CollectiveReduceV2") 
        {
            OperationDescription desc = NewOperation("CollectiveReduceV2", opName);
            desc.AddInput(input);
            desc.AddInput(group_size);
            desc.AddInput(group_key);
            desc.AddInput(instance_key);
            desc.AddInput(ordering_token);
            desc.SetAttr("merge_op", merge_op);
            desc.SetAttr("final_op", final_op);
            if (communication_hint != null)
                 desc.SetAttr("communication_hint", communication_hint);
            if (timeout_seconds != 0f)
                desc.SetAttr("timeout_seconds", timeout_seconds);
            if (is_stateless != false)
                desc.SetAttr("is_stateless", is_stateless);
            if (max_subdivs_per_device != -1)
                desc.SetAttr("max_subdivs_per_device", max_subdivs_per_device);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CollectiveReduceV3
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="communicator">Input to the operation. </param>
        /// <param name="group_assignment">Input to the operation. </param>
        /// <param name="reduction">reduction</param>
        /// <param name="timeout_seconds">timeout seconds</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] data(type: DtInvalid).
        /// </returns>
        public Operation CollectiveReduceV3(Output input, Output communicator, Output group_assignment, string reduction, float timeout_seconds = 0f, String opName = "CollectiveReduceV3") 
        {
            OperationDescription desc = NewOperation("CollectiveReduceV3", opName);
            desc.AddInput(input);
            desc.AddInput(communicator);
            desc.AddInput(group_assignment);
            desc.SetAttr("reduction", reduction);
            if (timeout_seconds != 0f)
                desc.SetAttr("timeout_seconds", timeout_seconds);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CombinedNonMaxSuppression
        /// </summary>
        /// <param name="boxes">Input to the operation. </param>
        /// <param name="scores">Input to the operation. </param>
        /// <param name="max_output_size_per_class">Input to the operation. </param>
        /// <param name="max_total_size">Input to the operation. </param>
        /// <param name="iou_threshold">Input to the operation. </param>
        /// <param name="score_threshold">Input to the operation. </param>
        /// <param name="pad_per_class">pad per class</param>
        /// <param name="clip_boxes">clip boxes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] nmsed_boxes(type: DtFloat).
        /// [1] nmsed_scores(type: DtFloat).
        /// [2] nmsed_classes(type: DtFloat).
        /// [3] valid_detections(type: DtInt32).
        /// </returns>
        public Operation CombinedNonMaxSuppression(Output boxes, Output scores, Output max_output_size_per_class, Output max_total_size, Output iou_threshold, Output score_threshold, bool pad_per_class = false, bool clip_boxes = true, String opName = "CombinedNonMaxSuppression") 
        {
            OperationDescription desc = NewOperation("CombinedNonMaxSuppression", opName);
            desc.AddInput(boxes);
            desc.AddInput(scores);
            desc.AddInput(max_output_size_per_class);
            desc.AddInput(max_total_size);
            desc.AddInput(iou_threshold);
            desc.AddInput(score_threshold);
            if (pad_per_class != false)
                desc.SetAttr("pad_per_class", pad_per_class);
            if (clip_boxes != true)
                desc.SetAttr("clip_boxes", clip_boxes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Complex
        /// </summary>
        /// <param name="real">Input to the operation. </param>
        /// <param name="imag">Input to the operation. </param>
        /// <param name="Tout">Tout</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation Complex(Output real, Output imag, DataType? Tout = null, String opName = "Complex") 
        {
            OperationDescription desc = NewOperation("Complex", opName);
            desc.AddInput(real);
            desc.AddInput(imag);
            if (Tout.HasValue)
                desc.SetAttr("Tout", Tout.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ComplexAbs
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="Tout">Tout</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation ComplexAbs(Output x, DataType? Tout = null, String opName = "ComplexAbs") 
        {
            OperationDescription desc = NewOperation("ComplexAbs", opName);
            desc.AddInput(x);
            if (Tout.HasValue)
                desc.SetAttr("Tout", Tout.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CompositeTensorVariantFromComponents
        /// </summary>
        /// <param name="components">Input to the operation. </param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] encoded(type: DtVariant).
        /// </returns>
        public Operation CompositeTensorVariantFromComponents(Output components, string metadata, String opName = "CompositeTensorVariantFromComponents") 
        {
            OperationDescription desc = NewOperation("CompositeTensorVariantFromComponents", opName);
            desc.AddInput(components);
            desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CompositeTensorVariantToComponents
        /// </summary>
        /// <param name="encoded">Input to the operation. </param>
        /// <param name="metadata">metadata</param>
        /// <param name="Tcomponents">Tcomponents</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] components(type: DtInvalid).
        /// </returns>
        public Operation CompositeTensorVariantToComponents(Output encoded, string metadata, DataType[] Tcomponents, String opName = "CompositeTensorVariantToComponents") 
        {
            OperationDescription desc = NewOperation("CompositeTensorVariantToComponents", opName);
            desc.AddInput(encoded);
            desc.SetAttr("metadata", metadata);
            desc.SetAttr("Tcomponents", Tcomponents);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CompressElement
        /// </summary>
        /// <param name="components">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] compressed(type: DtVariant).
        /// </returns>
        public Operation CompressElement(Output components, String opName = "CompressElement") 
        {
            OperationDescription desc = NewOperation("CompressElement", opName);
            desc.AddInput(components);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ComputeAccidentalHits
        /// </summary>
        /// <param name="true_classes">Input to the operation. </param>
        /// <param name="sampled_candidates">Input to the operation. </param>
        /// <param name="num_true">num true</param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] indices(type: DtInt32).
        /// [1] ids(type: DtInt64).
        /// [2] weights(type: DtFloat).
        /// </returns>
        public Operation ComputeAccidentalHits(Output true_classes, Output sampled_candidates, long num_true, long seed = 0, long seed2 = 0, String opName = "ComputeAccidentalHits") 
        {
            OperationDescription desc = NewOperation("ComputeAccidentalHits", opName);
            desc.AddInput(true_classes);
            desc.AddInput(sampled_candidates);
            desc.SetAttr("num_true", num_true);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ComputeBatchSize
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] batch_size(type: DtInt64).
        /// </returns>
        public Operation ComputeBatchSize(Output input_dataset, String opName = "ComputeBatchSize") 
        {
            OperationDescription desc = NewOperation("ComputeBatchSize", opName);
            desc.AddInput(input_dataset);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ComputeDedupDataSize
        /// </summary>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] num_elements(type: DtInt32).
        /// </returns>
        public Operation ComputeDedupDataSize(string config, String opName = "ComputeDedupDataSize") 
        {
            OperationDescription desc = NewOperation("ComputeDedupDataSize", opName);
            desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ComputeDedupDataSizeV2
        /// </summary>
        /// <param name="config">config</param>
        /// <param name="embedding_partitions">embedding partitions</param>
        /// <param name="hbm_buffers_config">hbm buffers config</param>
        /// <param name="tpu_topology">tpu topology</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] num_elements(type: DtInt32).
        /// </returns>
        public Operation ComputeDedupDataSizeV2(string config, string embedding_partitions, string hbm_buffers_config, string tpu_topology, String opName = "ComputeDedupDataSizeV2") 
        {
            OperationDescription desc = NewOperation("ComputeDedupDataSizeV2", opName);
            desc.SetAttr("config", config);
            desc.SetAttr("embedding_partitions", embedding_partitions);
            desc.SetAttr("hbm_buffers_config", hbm_buffers_config);
            desc.SetAttr("tpu_topology", tpu_topology);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ComputeDedupDataTupleMask
        /// </summary>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_shape(type: DtInt32).
        /// </returns>
        public Operation ComputeDedupDataTupleMask(string config, String opName = "ComputeDedupDataTupleMask") 
        {
            OperationDescription desc = NewOperation("ComputeDedupDataTupleMask", opName);
            desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ComputeDedupDataTupleMaskV2
        /// </summary>
        /// <param name="config">config</param>
        /// <param name="embedding_partitions">embedding partitions</param>
        /// <param name="hbm_buffers_config">hbm buffers config</param>
        /// <param name="tpu_topology">tpu topology</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_shape(type: DtInt32).
        /// </returns>
        public Operation ComputeDedupDataTupleMaskV2(string config, string embedding_partitions, string hbm_buffers_config, string tpu_topology, String opName = "ComputeDedupDataTupleMaskV2") 
        {
            OperationDescription desc = NewOperation("ComputeDedupDataTupleMaskV2", opName);
            desc.SetAttr("config", config);
            desc.SetAttr("embedding_partitions", embedding_partitions);
            desc.SetAttr("hbm_buffers_config", hbm_buffers_config);
            desc.SetAttr("tpu_topology", tpu_topology);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Concat
        /// </summary>
        /// <param name="concat_dim">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Concat(Output concat_dim, Output values, String opName = "Concat") 
        {
            OperationDescription desc = NewOperation("Concat", opName);
            desc.AddInput(concat_dim);
            desc.AddInput(values);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ConcatenateDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="another_dataset">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ConcatenateDataset(Output input_dataset, Output another_dataset, DataType[] output_types, long[][] output_shapes, string metadata = null, String opName = "ConcatenateDataset") 
        {
            OperationDescription desc = NewOperation("ConcatenateDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(another_dataset);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ConcatOffset
        /// </summary>
        /// <param name="concat_dim">Input to the operation. </param>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] offset(type: DtInvalid).
        /// </returns>
        public Operation ConcatOffset(Output concat_dim, Output shape, String opName = "ConcatOffset") 
        {
            OperationDescription desc = NewOperation("ConcatOffset", opName);
            desc.AddInput(concat_dim);
            desc.AddInput(shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ConcatV2
        /// </summary>
        /// <param name="values">Input to the operation. </param>
        /// <param name="axis">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation ConcatV2(Output values, Output axis, String opName = "ConcatV2") 
        {
            OperationDescription desc = NewOperation("ConcatV2", opName);
            desc.AddInput(values);
            desc.AddInput(axis);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ConditionalAccumulator
        /// </summary>
        /// <param name="dtype">dtype</param>
        /// <param name="shape">shape</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="reduction_type">reduction type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtString).
        /// </returns>
        public Operation ConditionalAccumulator(DataType dtype, long[] shape, string container = null, string shared_name = null, string reduction_type = null, String opName = "ConditionalAccumulator") 
        {
            OperationDescription desc = NewOperation("ConditionalAccumulator", opName);
            desc.SetAttr("dtype", dtype);
            desc.SetAttrShape("shape", shape);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            if (reduction_type != null)
                 desc.SetAttr("reduction_type", reduction_type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ConfigureAndInitializeGlobalTPU
        /// </summary>
        /// <param name="use_tfrt_host_runtime">use tfrt host runtime</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInt32).
        /// </returns>
        public Operation ConfigureAndInitializeGlobalTPU(bool use_tfrt_host_runtime = true, String opName = "ConfigureAndInitializeGlobalTPU") 
        {
            OperationDescription desc = NewOperation("ConfigureAndInitializeGlobalTPU", opName);
            if (use_tfrt_host_runtime != true)
                desc.SetAttr("use_tfrt_host_runtime", use_tfrt_host_runtime);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ConfigureDistributedTPU
        /// </summary>
        /// <param name="embedding_config">embedding config</param>
        /// <param name="tpu_embedding_config">tpu embedding config</param>
        /// <param name="is_global_init">is global init</param>
        /// <param name="enable_whole_mesh_compilations">enable whole mesh compilations</param>
        /// <param name="compilation_failure_closes_chips">compilation failure closes chips</param>
        /// <param name="tpu_cancellation_closes_chips">tpu cancellation closes chips</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] topology(type: DtString).
        /// </returns>
        public Operation ConfigureDistributedTPU(string embedding_config = null, string tpu_embedding_config = null, bool is_global_init = false, bool enable_whole_mesh_compilations = false, bool compilation_failure_closes_chips = true, long tpu_cancellation_closes_chips = 0, String opName = "ConfigureDistributedTPU") 
        {
            OperationDescription desc = NewOperation("ConfigureDistributedTPU", opName);
            if (embedding_config != null)
                 desc.SetAttr("embedding_config", embedding_config);
            if (tpu_embedding_config != null)
                 desc.SetAttr("tpu_embedding_config", tpu_embedding_config);
            if (is_global_init != false)
                desc.SetAttr("is_global_init", is_global_init);
            if (enable_whole_mesh_compilations != false)
                desc.SetAttr("enable_whole_mesh_compilations", enable_whole_mesh_compilations);
            if (compilation_failure_closes_chips != true)
                desc.SetAttr("compilation_failure_closes_chips", compilation_failure_closes_chips);
            if (tpu_cancellation_closes_chips != 0)
                desc.SetAttr("tpu_cancellation_closes_chips", tpu_cancellation_closes_chips);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ConfigureTPUEmbedding
        /// </summary>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ConfigureTPUEmbedding(string config, String opName = "ConfigureTPUEmbedding") 
        {
            OperationDescription desc = NewOperation("ConfigureTPUEmbedding", opName);
            desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ConfigureTPUEmbeddingHost
        /// </summary>
        /// <param name="common_config">Input to the operation. </param>
        /// <param name="memory_config">Input to the operation. </param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] network_config(type: DtString).
        /// </returns>
        public Operation ConfigureTPUEmbeddingHost(Output common_config, Output memory_config, string config, String opName = "ConfigureTPUEmbeddingHost") 
        {
            OperationDescription desc = NewOperation("ConfigureTPUEmbeddingHost", opName);
            desc.AddInput(common_config);
            desc.AddInput(memory_config);
            desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ConfigureTPUEmbeddingMemory
        /// </summary>
        /// <param name="common_config">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] memory_config(type: DtString).
        /// </returns>
        public Operation ConfigureTPUEmbeddingMemory(Output common_config, String opName = "ConfigureTPUEmbeddingMemory") 
        {
            OperationDescription desc = NewOperation("ConfigureTPUEmbeddingMemory", opName);
            desc.AddInput(common_config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Conj
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Conj(Output input, String opName = "Conj") 
        {
            OperationDescription desc = NewOperation("Conj", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ConjugateTranspose
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="perm">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation ConjugateTranspose(Output x, Output perm, String opName = "ConjugateTranspose") 
        {
            OperationDescription desc = NewOperation("ConjugateTranspose", opName);
            desc.AddInput(x);
            desc.AddInput(perm);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ConnectTPUEmbeddingHosts
        /// </summary>
        /// <param name="network_configs">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ConnectTPUEmbeddingHosts(Output network_configs, String opName = "ConnectTPUEmbeddingHosts") 
        {
            OperationDescription desc = NewOperation("ConnectTPUEmbeddingHosts", opName);
            desc.AddInput(network_configs);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Const
        /// </summary>
        /// <param name="value">value</param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Const(Tensor value, DataType dtype, String opName = "Const") 
        {
            OperationDescription desc = NewOperation("Const", opName);
            desc.SetAttr("value", value);
            desc.SetAttr("dtype", dtype);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ConsumeMutexLock
        /// </summary>
        /// <param name="mutex_lock">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ConsumeMutexLock(Output mutex_lock, String opName = "ConsumeMutexLock") 
        {
            OperationDescription desc = NewOperation("ConsumeMutexLock", opName);
            desc.AddInput(mutex_lock);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ControlTrigger
        /// </summary>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ControlTrigger(String opName = "ControlTrigger") 
        {
            OperationDescription desc = NewOperation("ControlTrigger", opName);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Conv
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="explicit_paddings">explicit paddings</param>
        /// <param name="data_format">data format</param>
        /// <param name="dilations">dilations</param>
        /// <param name="batch_dims">batch dims</param>
        /// <param name="groups">groups</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Conv(Output input, Output filter, long[] strides, string padding, long[] explicit_paddings = null, string data_format = null, long[] dilations = null, long batch_dims = 1, long groups = 1, String opName = "Conv") 
        {
            OperationDescription desc = NewOperation("Conv", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (explicit_paddings != null) desc.SetAttr("explicit_paddings", explicit_paddings);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            if (batch_dims != 1)
                desc.SetAttr("batch_dims", batch_dims);
            if (groups != 1)
                desc.SetAttr("groups", groups);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Conv2D
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="use_cudnn_on_gpu">use cudnn on gpu</param>
        /// <param name="explicit_paddings">explicit paddings</param>
        /// <param name="data_format">data format</param>
        /// <param name="dilations">dilations</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Conv2D(Output input, Output filter, long[] strides, string padding, bool use_cudnn_on_gpu = true, long[] explicit_paddings = null, string data_format = null, long[] dilations = null, String opName = "Conv2D") 
        {
            OperationDescription desc = NewOperation("Conv2D", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (use_cudnn_on_gpu != true)
                desc.SetAttr("use_cudnn_on_gpu", use_cudnn_on_gpu);
            if (explicit_paddings != null) desc.SetAttr("explicit_paddings", explicit_paddings);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Conv2DBackpropFilter
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter_sizes">Input to the operation. </param>
        /// <param name="out_backprop">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="use_cudnn_on_gpu">use cudnn on gpu</param>
        /// <param name="explicit_paddings">explicit paddings</param>
        /// <param name="data_format">data format</param>
        /// <param name="dilations">dilations</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Conv2DBackpropFilter(Output input, Output filter_sizes, Output out_backprop, long[] strides, string padding, bool use_cudnn_on_gpu = true, long[] explicit_paddings = null, string data_format = null, long[] dilations = null, String opName = "Conv2DBackpropFilter") 
        {
            OperationDescription desc = NewOperation("Conv2DBackpropFilter", opName);
            desc.AddInput(input);
            desc.AddInput(filter_sizes);
            desc.AddInput(out_backprop);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (use_cudnn_on_gpu != true)
                desc.SetAttr("use_cudnn_on_gpu", use_cudnn_on_gpu);
            if (explicit_paddings != null) desc.SetAttr("explicit_paddings", explicit_paddings);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Conv2DBackpropFilterV2
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="out_backprop">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="use_cudnn_on_gpu">use cudnn on gpu</param>
        /// <param name="explicit_paddings">explicit paddings</param>
        /// <param name="data_format">data format</param>
        /// <param name="dilations">dilations</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Conv2DBackpropFilterV2(Output input, Output filter, Output out_backprop, long[] strides, string padding, bool use_cudnn_on_gpu = true, long[] explicit_paddings = null, string data_format = null, long[] dilations = null, String opName = "Conv2DBackpropFilterV2") 
        {
            OperationDescription desc = NewOperation("Conv2DBackpropFilterV2", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.AddInput(out_backprop);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (use_cudnn_on_gpu != true)
                desc.SetAttr("use_cudnn_on_gpu", use_cudnn_on_gpu);
            if (explicit_paddings != null) desc.SetAttr("explicit_paddings", explicit_paddings);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Conv2DBackpropInput
        /// </summary>
        /// <param name="input_sizes">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="out_backprop">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="use_cudnn_on_gpu">use cudnn on gpu</param>
        /// <param name="explicit_paddings">explicit paddings</param>
        /// <param name="data_format">data format</param>
        /// <param name="dilations">dilations</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Conv2DBackpropInput(Output input_sizes, Output filter, Output out_backprop, long[] strides, string padding, bool use_cudnn_on_gpu = true, long[] explicit_paddings = null, string data_format = null, long[] dilations = null, String opName = "Conv2DBackpropInput") 
        {
            OperationDescription desc = NewOperation("Conv2DBackpropInput", opName);
            desc.AddInput(input_sizes);
            desc.AddInput(filter);
            desc.AddInput(out_backprop);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (use_cudnn_on_gpu != true)
                desc.SetAttr("use_cudnn_on_gpu", use_cudnn_on_gpu);
            if (explicit_paddings != null) desc.SetAttr("explicit_paddings", explicit_paddings);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Conv2DBackpropInputV2
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="out_backprop">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="use_cudnn_on_gpu">use cudnn on gpu</param>
        /// <param name="explicit_paddings">explicit paddings</param>
        /// <param name="data_format">data format</param>
        /// <param name="dilations">dilations</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Conv2DBackpropInputV2(Output input, Output filter, Output out_backprop, long[] strides, string padding, bool use_cudnn_on_gpu = true, long[] explicit_paddings = null, string data_format = null, long[] dilations = null, String opName = "Conv2DBackpropInputV2") 
        {
            OperationDescription desc = NewOperation("Conv2DBackpropInputV2", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.AddInput(out_backprop);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (use_cudnn_on_gpu != true)
                desc.SetAttr("use_cudnn_on_gpu", use_cudnn_on_gpu);
            if (explicit_paddings != null) desc.SetAttr("explicit_paddings", explicit_paddings);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Conv3D
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="data_format">data format</param>
        /// <param name="dilations">dilations</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Conv3D(Output input, Output filter, long[] strides, string padding, string data_format = null, long[] dilations = null, String opName = "Conv3D") 
        {
            OperationDescription desc = NewOperation("Conv3D", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Conv3DBackpropFilter
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="out_backprop">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="dilations">dilations</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Conv3DBackpropFilter(Output input, Output filter, Output out_backprop, long[] strides, string padding, long[] dilations = null, String opName = "Conv3DBackpropFilter") 
        {
            OperationDescription desc = NewOperation("Conv3DBackpropFilter", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.AddInput(out_backprop);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Conv3DBackpropFilterV2
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter_sizes">Input to the operation. </param>
        /// <param name="out_backprop">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="data_format">data format</param>
        /// <param name="dilations">dilations</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Conv3DBackpropFilterV2(Output input, Output filter_sizes, Output out_backprop, long[] strides, string padding, string data_format = null, long[] dilations = null, String opName = "Conv3DBackpropFilterV2") 
        {
            OperationDescription desc = NewOperation("Conv3DBackpropFilterV2", opName);
            desc.AddInput(input);
            desc.AddInput(filter_sizes);
            desc.AddInput(out_backprop);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Conv3DBackpropInput
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="out_backprop">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="dilations">dilations</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Conv3DBackpropInput(Output input, Output filter, Output out_backprop, long[] strides, string padding, long[] dilations = null, String opName = "Conv3DBackpropInput") 
        {
            OperationDescription desc = NewOperation("Conv3DBackpropInput", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.AddInput(out_backprop);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Conv3DBackpropInputV2
        /// </summary>
        /// <param name="input_sizes">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="out_backprop">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="data_format">data format</param>
        /// <param name="dilations">dilations</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Conv3DBackpropInputV2(Output input_sizes, Output filter, Output out_backprop, long[] strides, string padding, string data_format = null, long[] dilations = null, String opName = "Conv3DBackpropInputV2") 
        {
            OperationDescription desc = NewOperation("Conv3DBackpropInputV2", opName);
            desc.AddInput(input_sizes);
            desc.AddInput(filter);
            desc.AddInput(out_backprop);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ConvertToCooTensor
        /// </summary>
        /// <param name="indices_or_row_splits">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="weights">Input to the operation. </param>
        /// <param name="sample_count">sample count</param>
        /// <param name="combiner">combiner</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] row_ids(type: DtInt32).
        /// [1] col_ids(type: DtInt32).
        /// [2] gains(type: DtFloat).
        /// </returns>
        public Operation ConvertToCooTensor(Output indices_or_row_splits, Output values, Output weights, long sample_count, string combiner, String opName = "ConvertToCooTensor") 
        {
            OperationDescription desc = NewOperation("ConvertToCooTensor", opName);
            desc.AddInput(indices_or_row_splits);
            desc.AddInput(values);
            desc.AddInput(weights);
            desc.SetAttr("sample_count", sample_count);
            desc.SetAttr("combiner", combiner);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ConvertToListOfSparseCoreCooTensors
        /// </summary>
        /// <param name="indices_or_row_splits">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="weights">Input to the operation. </param>
        /// <param name="sample_count">sample count</param>
        /// <param name="num_sc_per_chip">num sc per chip</param>
        /// <param name="row_offset">row offset</param>
        /// <param name="col_offset">col offset</param>
        /// <param name="col_shift">col shift</param>
        /// <param name="num_sc_shards">num sc shards</param>
        /// <param name="stacked_table_sample_count">stacked table sample count</param>
        /// <param name="combiner">combiner</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] row_ids_list(type: DtInt32).
        /// [1] col_ids_list(type: DtInt32).
        /// [2] gains_list(type: DtFloat).
        /// </returns>
        public Operation ConvertToListOfSparseCoreCooTensors(Output indices_or_row_splits, Output values, Output weights, long sample_count, long num_sc_per_chip, long row_offset, long col_offset, long col_shift, long num_sc_shards, long stacked_table_sample_count, string combiner, String opName = "ConvertToListOfSparseCoreCooTensors") 
        {
            OperationDescription desc = NewOperation("ConvertToListOfSparseCoreCooTensors", opName);
            desc.AddInput(indices_or_row_splits);
            desc.AddInput(values);
            desc.AddInput(weights);
            desc.SetAttr("sample_count", sample_count);
            desc.SetAttr("num_sc_per_chip", num_sc_per_chip);
            desc.SetAttr("row_offset", row_offset);
            desc.SetAttr("col_offset", col_offset);
            desc.SetAttr("col_shift", col_shift);
            desc.SetAttr("num_sc_shards", num_sc_shards);
            desc.SetAttr("stacked_table_sample_count", stacked_table_sample_count);
            desc.SetAttr("combiner", combiner);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ConvertToSparseCoreCsrWrappedCooTensor
        /// </summary>
        /// <param name="sorted_row_ids_list">Input to the operation. </param>
        /// <param name="sorted_col_ids_list">Input to the operation. </param>
        /// <param name="sorted_gains_list">Input to the operation. </param>
        /// <param name="id_counts_list">Input to the operation. </param>
        /// <param name="splits">Input to the operation. </param>
        /// <param name="sample_count_per_sc">sample count per sc</param>
        /// <param name="num_replica">num replica</param>
        /// <param name="max_minibatches_per_sc">max minibatches per sc</param>
        /// <param name="max_ids_per_chip_per_sample">max ids per chip per sample</param>
        /// <param name="table_vocab_size">table vocab size</param>
        /// <param name="feature_width">feature width</param>
        /// <param name="table_name">table name</param>
        /// <param name="allow_id_dropping">allow id dropping</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] row_pointers(type: DtInt32).
        /// [1] sorted_sample_ids(type: DtInt32).
        /// [2] sorted_token_ids(type: DtInt32).
        /// [3] sorted_gains(type: DtFloat).
        /// [4] row_pointers_unpadded_size(type: DtInt32).
        /// [5] ids_unpadded_size(type: DtInt32).
        /// [6] num_minibatches_per_sc(type: DtInt32).
        /// </returns>
        public Operation ConvertToSparseCoreCsrWrappedCooTensor(Output sorted_row_ids_list, Output sorted_col_ids_list, Output sorted_gains_list, Output id_counts_list, Output splits, long sample_count_per_sc, long num_replica, long max_minibatches_per_sc, long max_ids_per_chip_per_sample, long table_vocab_size, long feature_width, string table_name, bool allow_id_dropping, String opName = "ConvertToSparseCoreCsrWrappedCooTensor") 
        {
            OperationDescription desc = NewOperation("ConvertToSparseCoreCsrWrappedCooTensor", opName);
            desc.AddInput(sorted_row_ids_list);
            desc.AddInput(sorted_col_ids_list);
            desc.AddInput(sorted_gains_list);
            desc.AddInput(id_counts_list);
            desc.AddInput(splits);
            desc.SetAttr("sample_count_per_sc", sample_count_per_sc);
            desc.SetAttr("num_replica", num_replica);
            desc.SetAttr("max_minibatches_per_sc", max_minibatches_per_sc);
            desc.SetAttr("max_ids_per_chip_per_sample", max_ids_per_chip_per_sample);
            desc.SetAttr("table_vocab_size", table_vocab_size);
            desc.SetAttr("feature_width", feature_width);
            desc.SetAttr("table_name", table_name);
            desc.SetAttr("allow_id_dropping", allow_id_dropping);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Copy
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="tensor_name">tensor name</param>
        /// <param name="debug_ops_spec">debug ops spec</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Copy(Output input, string tensor_name = null, string[] debug_ops_spec = null, String opName = "Copy") 
        {
            OperationDescription desc = NewOperation("Copy", opName);
            desc.AddInput(input);
            if (tensor_name != null)
                 desc.SetAttr("tensor_name", tensor_name);
            if (debug_ops_spec != null) desc.SetAttr("debug_ops_spec", debug_ops_spec);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CopyHost
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="tensor_name">tensor name</param>
        /// <param name="debug_ops_spec">debug ops spec</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation CopyHost(Output input, string tensor_name = null, string[] debug_ops_spec = null, String opName = "CopyHost") 
        {
            OperationDescription desc = NewOperation("CopyHost", opName);
            desc.AddInput(input);
            if (tensor_name != null)
                 desc.SetAttr("tensor_name", tensor_name);
            if (debug_ops_spec != null) desc.SetAttr("debug_ops_spec", debug_ops_spec);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CopyToMesh
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="mesh">mesh</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation CopyToMesh(Output input, string mesh, String opName = "CopyToMesh") 
        {
            OperationDescription desc = NewOperation("CopyToMesh", opName);
            desc.AddInput(input);
            desc.SetAttr("mesh", mesh);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CopyToMeshGrad
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="forward_input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation CopyToMeshGrad(Output input, Output forward_input, String opName = "CopyToMeshGrad") 
        {
            OperationDescription desc = NewOperation("CopyToMeshGrad", opName);
            desc.AddInput(input);
            desc.AddInput(forward_input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Cos
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Cos(Output x, String opName = "Cos") 
        {
            OperationDescription desc = NewOperation("Cos", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Cosh
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Cosh(Output x, String opName = "Cosh") 
        {
            OperationDescription desc = NewOperation("Cosh", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CountUpTo
        /// </summary>
        /// <param name="reference">Input to the operation. </param>
        /// <param name="limit">limit</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation CountUpTo(Output reference, long limit, String opName = "CountUpTo") 
        {
            OperationDescription desc = NewOperation("CountUpTo", opName);
            desc.AddInput(reference);
            desc.SetAttr("limit", limit);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CreateSummaryDbWriter
        /// </summary>
        /// <param name="writer">Input to the operation. </param>
        /// <param name="db_uri">Input to the operation. </param>
        /// <param name="experiment_name">Input to the operation. </param>
        /// <param name="run_name">Input to the operation. </param>
        /// <param name="user_name">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation CreateSummaryDbWriter(Output writer, Output db_uri, Output experiment_name, Output run_name, Output user_name, String opName = "CreateSummaryDbWriter") 
        {
            OperationDescription desc = NewOperation("CreateSummaryDbWriter", opName);
            desc.AddInput(writer);
            desc.AddInput(db_uri);
            desc.AddInput(experiment_name);
            desc.AddInput(run_name);
            desc.AddInput(user_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CreateSummaryFileWriter
        /// </summary>
        /// <param name="writer">Input to the operation. </param>
        /// <param name="logdir">Input to the operation. </param>
        /// <param name="max_queue">Input to the operation. </param>
        /// <param name="flush_millis">Input to the operation. </param>
        /// <param name="filename_suffix">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation CreateSummaryFileWriter(Output writer, Output logdir, Output max_queue, Output flush_millis, Output filename_suffix, String opName = "CreateSummaryFileWriter") 
        {
            OperationDescription desc = NewOperation("CreateSummaryFileWriter", opName);
            desc.AddInput(writer);
            desc.AddInput(logdir);
            desc.AddInput(max_queue);
            desc.AddInput(flush_millis);
            desc.AddInput(filename_suffix);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CropAndResize
        /// </summary>
        /// <param name="image">Input to the operation. </param>
        /// <param name="boxes">Input to the operation. </param>
        /// <param name="box_ind">Input to the operation. </param>
        /// <param name="crop_size">Input to the operation. </param>
        /// <param name="method">method</param>
        /// <param name="extrapolation_value">extrapolation value</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] crops(type: DtFloat).
        /// </returns>
        public Operation CropAndResize(Output image, Output boxes, Output box_ind, Output crop_size, string method = null, float extrapolation_value = 0f, String opName = "CropAndResize") 
        {
            OperationDescription desc = NewOperation("CropAndResize", opName);
            desc.AddInput(image);
            desc.AddInput(boxes);
            desc.AddInput(box_ind);
            desc.AddInput(crop_size);
            if (method != null)
                 desc.SetAttr("method", method);
            if (extrapolation_value != 0f)
                desc.SetAttr("extrapolation_value", extrapolation_value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CropAndResizeGradBoxes
        /// </summary>
        /// <param name="grads">Input to the operation. </param>
        /// <param name="image">Input to the operation. </param>
        /// <param name="boxes">Input to the operation. </param>
        /// <param name="box_ind">Input to the operation. </param>
        /// <param name="method">method</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtFloat).
        /// </returns>
        public Operation CropAndResizeGradBoxes(Output grads, Output image, Output boxes, Output box_ind, string method = null, String opName = "CropAndResizeGradBoxes") 
        {
            OperationDescription desc = NewOperation("CropAndResizeGradBoxes", opName);
            desc.AddInput(grads);
            desc.AddInput(image);
            desc.AddInput(boxes);
            desc.AddInput(box_ind);
            if (method != null)
                 desc.SetAttr("method", method);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CropAndResizeGradImage
        /// </summary>
        /// <param name="grads">Input to the operation. </param>
        /// <param name="boxes">Input to the operation. </param>
        /// <param name="box_ind">Input to the operation. </param>
        /// <param name="image_size">Input to the operation. </param>
        /// <param name="T">T</param>
        /// <param name="method">method</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation CropAndResizeGradImage(Output grads, Output boxes, Output box_ind, Output image_size, DataType T, string method = null, String opName = "CropAndResizeGradImage") 
        {
            OperationDescription desc = NewOperation("CropAndResizeGradImage", opName);
            desc.AddInput(grads);
            desc.AddInput(boxes);
            desc.AddInput(box_ind);
            desc.AddInput(image_size);
            desc.SetAttr("T", T);
            if (method != null)
                 desc.SetAttr("method", method);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Cross
        /// </summary>
        /// <param name="a">Input to the operation. </param>
        /// <param name="b">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] product(type: DtInvalid).
        /// </returns>
        public Operation Cross(Output a, Output b, String opName = "Cross") 
        {
            OperationDescription desc = NewOperation("Cross", opName);
            desc.AddInput(a);
            desc.AddInput(b);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CrossReplicaSum
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="group_assignment">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation CrossReplicaSum(Output input, Output group_assignment, String opName = "CrossReplicaSum") 
        {
            OperationDescription desc = NewOperation("CrossReplicaSum", opName);
            desc.AddInput(input);
            desc.AddInput(group_assignment);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CSRSparseMatrixComponents
        /// </summary>
        /// <param name="csr_sparse_matrix">Input to the operation. </param>
        /// <param name="index">Input to the operation. </param>
        /// <param name="type">type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] row_ptrs(type: DtInt32).
        /// [1] col_inds(type: DtInt32).
        /// [2] values(type: DtInvalid).
        /// </returns>
        public Operation CSRSparseMatrixComponents(Output csr_sparse_matrix, Output index, DataType type, String opName = "CSRSparseMatrixComponents") 
        {
            OperationDescription desc = NewOperation("CSRSparseMatrixComponents", opName);
            desc.AddInput(csr_sparse_matrix);
            desc.AddInput(index);
            desc.SetAttr("type", type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CSRSparseMatrixToDense
        /// </summary>
        /// <param name="sparse_input">Input to the operation. </param>
        /// <param name="type">type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] dense_output(type: DtInvalid).
        /// </returns>
        public Operation CSRSparseMatrixToDense(Output sparse_input, DataType type, String opName = "CSRSparseMatrixToDense") 
        {
            OperationDescription desc = NewOperation("CSRSparseMatrixToDense", opName);
            desc.AddInput(sparse_input);
            desc.SetAttr("type", type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CSRSparseMatrixToSparseTensor
        /// </summary>
        /// <param name="sparse_matrix">Input to the operation. </param>
        /// <param name="type">type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] indices(type: DtInt64).
        /// [1] values(type: DtInvalid).
        /// [2] dense_shape(type: DtInt64).
        /// </returns>
        public Operation CSRSparseMatrixToSparseTensor(Output sparse_matrix, DataType type, String opName = "CSRSparseMatrixToSparseTensor") 
        {
            OperationDescription desc = NewOperation("CSRSparseMatrixToSparseTensor", opName);
            desc.AddInput(sparse_matrix);
            desc.SetAttr("type", type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CSVDataset
        /// </summary>
        /// <param name="filenames">Input to the operation. </param>
        /// <param name="compression_type">Input to the operation. </param>
        /// <param name="buffer_size">Input to the operation. </param>
        /// <param name="header">Input to the operation. </param>
        /// <param name="field_delim">Input to the operation. </param>
        /// <param name="use_quote_delim">Input to the operation. </param>
        /// <param name="na_value">Input to the operation. </param>
        /// <param name="select_cols">Input to the operation. </param>
        /// <param name="record_defaults">Input to the operation. </param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation CSVDataset(Output filenames, Output compression_type, Output buffer_size, Output header, Output field_delim, Output use_quote_delim, Output na_value, Output select_cols, Output record_defaults, long[][] output_shapes, String opName = "CSVDataset") 
        {
            OperationDescription desc = NewOperation("CSVDataset", opName);
            desc.AddInput(filenames);
            desc.AddInput(compression_type);
            desc.AddInput(buffer_size);
            desc.AddInput(header);
            desc.AddInput(field_delim);
            desc.AddInput(use_quote_delim);
            desc.AddInput(na_value);
            desc.AddInput(select_cols);
            desc.AddInput(record_defaults);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CSVDatasetV2
        /// </summary>
        /// <param name="filenames">Input to the operation. </param>
        /// <param name="compression_type">Input to the operation. </param>
        /// <param name="buffer_size">Input to the operation. </param>
        /// <param name="header">Input to the operation. </param>
        /// <param name="field_delim">Input to the operation. </param>
        /// <param name="use_quote_delim">Input to the operation. </param>
        /// <param name="na_value">Input to the operation. </param>
        /// <param name="select_cols">Input to the operation. </param>
        /// <param name="record_defaults">Input to the operation. </param>
        /// <param name="exclude_cols">Input to the operation. </param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation CSVDatasetV2(Output filenames, Output compression_type, Output buffer_size, Output header, Output field_delim, Output use_quote_delim, Output na_value, Output select_cols, Output record_defaults, Output exclude_cols, long[][] output_shapes, String opName = "CSVDatasetV2") 
        {
            OperationDescription desc = NewOperation("CSVDatasetV2", opName);
            desc.AddInput(filenames);
            desc.AddInput(compression_type);
            desc.AddInput(buffer_size);
            desc.AddInput(header);
            desc.AddInput(field_delim);
            desc.AddInput(use_quote_delim);
            desc.AddInput(na_value);
            desc.AddInput(select_cols);
            desc.AddInput(record_defaults);
            desc.AddInput(exclude_cols);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CTCBeamSearchDecoder
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="sequence_length">Input to the operation. </param>
        /// <param name="beam_width">beam width</param>
        /// <param name="top_paths">top paths</param>
        /// <param name="merge_repeated">merge repeated</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] decoded_indices(type: DtInt64).
        /// [1] decoded_values(type: DtInt64).
        /// [2] decoded_shape(type: DtInt64).
        /// [3] log_probability(type: DtInvalid).
        /// </returns>
        public Operation CTCBeamSearchDecoder(Output inputs, Output sequence_length, long beam_width, long top_paths, bool merge_repeated = true, String opName = "CTCBeamSearchDecoder") 
        {
            OperationDescription desc = NewOperation("CTCBeamSearchDecoder", opName);
            desc.AddInput(inputs);
            desc.AddInput(sequence_length);
            desc.SetAttr("beam_width", beam_width);
            desc.SetAttr("top_paths", top_paths);
            if (merge_repeated != true)
                desc.SetAttr("merge_repeated", merge_repeated);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CTCGreedyDecoder
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="sequence_length">Input to the operation. </param>
        /// <param name="merge_repeated">merge repeated</param>
        /// <param name="blank_index">blank index</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] decoded_indices(type: DtInt64).
        /// [1] decoded_values(type: DtInt64).
        /// [2] decoded_shape(type: DtInt64).
        /// [3] log_probability(type: DtInvalid).
        /// </returns>
        public Operation CTCGreedyDecoder(Output inputs, Output sequence_length, bool merge_repeated = false, long blank_index = -1, String opName = "CTCGreedyDecoder") 
        {
            OperationDescription desc = NewOperation("CTCGreedyDecoder", opName);
            desc.AddInput(inputs);
            desc.AddInput(sequence_length);
            if (merge_repeated != false)
                desc.SetAttr("merge_repeated", merge_repeated);
            if (blank_index != -1)
                desc.SetAttr("blank_index", blank_index);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CTCLoss
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="labels_indices">Input to the operation. </param>
        /// <param name="labels_values">Input to the operation. </param>
        /// <param name="sequence_length">Input to the operation. </param>
        /// <param name="preprocess_collapse_repeated">preprocess collapse repeated</param>
        /// <param name="ctc_merge_repeated">ctc merge repeated</param>
        /// <param name="ignore_longer_outputs_than_inputs">ignore longer outputs than inputs</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] loss(type: DtInvalid).
        /// [1] gradient(type: DtInvalid).
        /// </returns>
        public Operation CTCLoss(Output inputs, Output labels_indices, Output labels_values, Output sequence_length, bool preprocess_collapse_repeated = false, bool ctc_merge_repeated = true, bool ignore_longer_outputs_than_inputs = false, String opName = "CTCLoss") 
        {
            OperationDescription desc = NewOperation("CTCLoss", opName);
            desc.AddInput(inputs);
            desc.AddInput(labels_indices);
            desc.AddInput(labels_values);
            desc.AddInput(sequence_length);
            if (preprocess_collapse_repeated != false)
                desc.SetAttr("preprocess_collapse_repeated", preprocess_collapse_repeated);
            if (ctc_merge_repeated != true)
                desc.SetAttr("ctc_merge_repeated", ctc_merge_repeated);
            if (ignore_longer_outputs_than_inputs != false)
                desc.SetAttr("ignore_longer_outputs_than_inputs", ignore_longer_outputs_than_inputs);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CTCLossV2
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="labels_indices">Input to the operation. </param>
        /// <param name="labels_values">Input to the operation. </param>
        /// <param name="sequence_length">Input to the operation. </param>
        /// <param name="preprocess_collapse_repeated">preprocess collapse repeated</param>
        /// <param name="ctc_merge_repeated">ctc merge repeated</param>
        /// <param name="ignore_longer_outputs_than_inputs">ignore longer outputs than inputs</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] loss(type: DtFloat).
        /// [1] gradient(type: DtFloat).
        /// </returns>
        public Operation CTCLossV2(Output inputs, Output labels_indices, Output labels_values, Output sequence_length, bool preprocess_collapse_repeated = false, bool ctc_merge_repeated = true, bool ignore_longer_outputs_than_inputs = false, String opName = "CTCLossV2") 
        {
            OperationDescription desc = NewOperation("CTCLossV2", opName);
            desc.AddInput(inputs);
            desc.AddInput(labels_indices);
            desc.AddInput(labels_values);
            desc.AddInput(sequence_length);
            if (preprocess_collapse_repeated != false)
                desc.SetAttr("preprocess_collapse_repeated", preprocess_collapse_repeated);
            if (ctc_merge_repeated != true)
                desc.SetAttr("ctc_merge_repeated", ctc_merge_repeated);
            if (ignore_longer_outputs_than_inputs != false)
                desc.SetAttr("ignore_longer_outputs_than_inputs", ignore_longer_outputs_than_inputs);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CudnnRNN
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="input_h">Input to the operation. </param>
        /// <param name="input_c">Input to the operation. </param>
        /// <param name="parameters">Input to the operation. </param>
        /// <param name="rnn_mode">rnn mode</param>
        /// <param name="input_mode">input mode</param>
        /// <param name="direction">direction</param>
        /// <param name="dropout">dropout</param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="is_training">is training</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] output_h(type: DtInvalid).
        /// [2] output_c(type: DtInvalid).
        /// [3] reserve_space(type: DtInvalid).
        /// </returns>
        public Operation CudnnRNN(Output input, Output input_h, Output input_c, Output parameters, string rnn_mode = null, string input_mode = null, string direction = null, float dropout = 0f, long seed = 0, long seed2 = 0, bool is_training = true, String opName = "CudnnRNN") 
        {
            OperationDescription desc = NewOperation("CudnnRNN", opName);
            desc.AddInput(input);
            desc.AddInput(input_h);
            desc.AddInput(input_c);
            desc.AddInput(parameters);
            if (rnn_mode != null)
                 desc.SetAttr("rnn_mode", rnn_mode);
            if (input_mode != null)
                 desc.SetAttr("input_mode", input_mode);
            if (direction != null)
                 desc.SetAttr("direction", direction);
            if (dropout != 0f)
                desc.SetAttr("dropout", dropout);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            if (is_training != true)
                desc.SetAttr("is_training", is_training);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CudnnRNNBackprop
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="input_h">Input to the operation. </param>
        /// <param name="input_c">Input to the operation. </param>
        /// <param name="parameters">Input to the operation. </param>
        /// <param name="output">Input to the operation. </param>
        /// <param name="output_h">Input to the operation. </param>
        /// <param name="output_c">Input to the operation. </param>
        /// <param name="output_backprop">Input to the operation. </param>
        /// <param name="output_h_backprop">Input to the operation. </param>
        /// <param name="output_c_backprop">Input to the operation. </param>
        /// <param name="reserve_space">Input to the operation. </param>
        /// <param name="rnn_mode">rnn mode</param>
        /// <param name="input_mode">input mode</param>
        /// <param name="direction">direction</param>
        /// <param name="dropout">dropout</param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] input_backprop(type: DtInvalid).
        /// [1] input_h_backprop(type: DtInvalid).
        /// [2] input_c_backprop(type: DtInvalid).
        /// [3] params_backprop(type: DtInvalid).
        /// </returns>
        public Operation CudnnRNNBackprop(Output input, Output input_h, Output input_c, Output parameters, Output output, Output output_h, Output output_c, Output output_backprop, Output output_h_backprop, Output output_c_backprop, Output reserve_space, string rnn_mode = null, string input_mode = null, string direction = null, float dropout = 0f, long seed = 0, long seed2 = 0, String opName = "CudnnRNNBackprop") 
        {
            OperationDescription desc = NewOperation("CudnnRNNBackprop", opName);
            desc.AddInput(input);
            desc.AddInput(input_h);
            desc.AddInput(input_c);
            desc.AddInput(parameters);
            desc.AddInput(output);
            desc.AddInput(output_h);
            desc.AddInput(output_c);
            desc.AddInput(output_backprop);
            desc.AddInput(output_h_backprop);
            desc.AddInput(output_c_backprop);
            desc.AddInput(reserve_space);
            if (rnn_mode != null)
                 desc.SetAttr("rnn_mode", rnn_mode);
            if (input_mode != null)
                 desc.SetAttr("input_mode", input_mode);
            if (direction != null)
                 desc.SetAttr("direction", direction);
            if (dropout != 0f)
                desc.SetAttr("dropout", dropout);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CudnnRNNBackpropV2
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="input_h">Input to the operation. </param>
        /// <param name="input_c">Input to the operation. </param>
        /// <param name="parameters">Input to the operation. </param>
        /// <param name="output">Input to the operation. </param>
        /// <param name="output_h">Input to the operation. </param>
        /// <param name="output_c">Input to the operation. </param>
        /// <param name="output_backprop">Input to the operation. </param>
        /// <param name="output_h_backprop">Input to the operation. </param>
        /// <param name="output_c_backprop">Input to the operation. </param>
        /// <param name="reserve_space">Input to the operation. </param>
        /// <param name="host_reserved">Input to the operation. </param>
        /// <param name="rnn_mode">rnn mode</param>
        /// <param name="input_mode">input mode</param>
        /// <param name="direction">direction</param>
        /// <param name="dropout">dropout</param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] input_backprop(type: DtInvalid).
        /// [1] input_h_backprop(type: DtInvalid).
        /// [2] input_c_backprop(type: DtInvalid).
        /// [3] params_backprop(type: DtInvalid).
        /// </returns>
        public Operation CudnnRNNBackpropV2(Output input, Output input_h, Output input_c, Output parameters, Output output, Output output_h, Output output_c, Output output_backprop, Output output_h_backprop, Output output_c_backprop, Output reserve_space, Output host_reserved, string rnn_mode = null, string input_mode = null, string direction = null, float dropout = 0f, long seed = 0, long seed2 = 0, String opName = "CudnnRNNBackpropV2") 
        {
            OperationDescription desc = NewOperation("CudnnRNNBackpropV2", opName);
            desc.AddInput(input);
            desc.AddInput(input_h);
            desc.AddInput(input_c);
            desc.AddInput(parameters);
            desc.AddInput(output);
            desc.AddInput(output_h);
            desc.AddInput(output_c);
            desc.AddInput(output_backprop);
            desc.AddInput(output_h_backprop);
            desc.AddInput(output_c_backprop);
            desc.AddInput(reserve_space);
            desc.AddInput(host_reserved);
            if (rnn_mode != null)
                 desc.SetAttr("rnn_mode", rnn_mode);
            if (input_mode != null)
                 desc.SetAttr("input_mode", input_mode);
            if (direction != null)
                 desc.SetAttr("direction", direction);
            if (dropout != 0f)
                desc.SetAttr("dropout", dropout);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CudnnRNNBackpropV3
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="input_h">Input to the operation. </param>
        /// <param name="input_c">Input to the operation. </param>
        /// <param name="parameters">Input to the operation. </param>
        /// <param name="sequence_lengths">Input to the operation. </param>
        /// <param name="output">Input to the operation. </param>
        /// <param name="output_h">Input to the operation. </param>
        /// <param name="output_c">Input to the operation. </param>
        /// <param name="output_backprop">Input to the operation. </param>
        /// <param name="output_h_backprop">Input to the operation. </param>
        /// <param name="output_c_backprop">Input to the operation. </param>
        /// <param name="reserve_space">Input to the operation. </param>
        /// <param name="host_reserved">Input to the operation. </param>
        /// <param name="rnn_mode">rnn mode</param>
        /// <param name="input_mode">input mode</param>
        /// <param name="direction">direction</param>
        /// <param name="dropout">dropout</param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="num_proj">num proj</param>
        /// <param name="time_major">time major</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] input_backprop(type: DtInvalid).
        /// [1] input_h_backprop(type: DtInvalid).
        /// [2] input_c_backprop(type: DtInvalid).
        /// [3] params_backprop(type: DtInvalid).
        /// </returns>
        public Operation CudnnRNNBackpropV3(Output input, Output input_h, Output input_c, Output parameters, Output sequence_lengths, Output output, Output output_h, Output output_c, Output output_backprop, Output output_h_backprop, Output output_c_backprop, Output reserve_space, Output host_reserved, string rnn_mode = null, string input_mode = null, string direction = null, float dropout = 0f, long seed = 0, long seed2 = 0, long num_proj = 0, bool time_major = true, String opName = "CudnnRNNBackpropV3") 
        {
            OperationDescription desc = NewOperation("CudnnRNNBackpropV3", opName);
            desc.AddInput(input);
            desc.AddInput(input_h);
            desc.AddInput(input_c);
            desc.AddInput(parameters);
            desc.AddInput(sequence_lengths);
            desc.AddInput(output);
            desc.AddInput(output_h);
            desc.AddInput(output_c);
            desc.AddInput(output_backprop);
            desc.AddInput(output_h_backprop);
            desc.AddInput(output_c_backprop);
            desc.AddInput(reserve_space);
            desc.AddInput(host_reserved);
            if (rnn_mode != null)
                 desc.SetAttr("rnn_mode", rnn_mode);
            if (input_mode != null)
                 desc.SetAttr("input_mode", input_mode);
            if (direction != null)
                 desc.SetAttr("direction", direction);
            if (dropout != 0f)
                desc.SetAttr("dropout", dropout);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            if (num_proj != 0)
                desc.SetAttr("num_proj", num_proj);
            if (time_major != true)
                desc.SetAttr("time_major", time_major);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CudnnRNNCanonicalToParams
        /// </summary>
        /// <param name="num_layers">Input to the operation. </param>
        /// <param name="num_units">Input to the operation. </param>
        /// <param name="input_size">Input to the operation. </param>
        /// <param name="weights">Input to the operation. </param>
        /// <param name="biases">Input to the operation. </param>
        /// <param name="rnn_mode">rnn mode</param>
        /// <param name="input_mode">input mode</param>
        /// <param name="direction">direction</param>
        /// <param name="dropout">dropout</param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] params(type: DtInvalid).
        /// </returns>
        public Operation CudnnRNNCanonicalToParams(Output num_layers, Output num_units, Output input_size, Output weights, Output biases, string rnn_mode = null, string input_mode = null, string direction = null, float dropout = 0f, long seed = 0, long seed2 = 0, String opName = "CudnnRNNCanonicalToParams") 
        {
            OperationDescription desc = NewOperation("CudnnRNNCanonicalToParams", opName);
            desc.AddInput(num_layers);
            desc.AddInput(num_units);
            desc.AddInput(input_size);
            desc.AddInput(weights);
            desc.AddInput(biases);
            if (rnn_mode != null)
                 desc.SetAttr("rnn_mode", rnn_mode);
            if (input_mode != null)
                 desc.SetAttr("input_mode", input_mode);
            if (direction != null)
                 desc.SetAttr("direction", direction);
            if (dropout != 0f)
                desc.SetAttr("dropout", dropout);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CudnnRNNCanonicalToParamsV2
        /// </summary>
        /// <param name="num_layers">Input to the operation. </param>
        /// <param name="num_units">Input to the operation. </param>
        /// <param name="input_size">Input to the operation. </param>
        /// <param name="weights">Input to the operation. </param>
        /// <param name="biases">Input to the operation. </param>
        /// <param name="rnn_mode">rnn mode</param>
        /// <param name="input_mode">input mode</param>
        /// <param name="direction">direction</param>
        /// <param name="dropout">dropout</param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="num_proj">num proj</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] params(type: DtInvalid).
        /// </returns>
        public Operation CudnnRNNCanonicalToParamsV2(Output num_layers, Output num_units, Output input_size, Output weights, Output biases, string rnn_mode = null, string input_mode = null, string direction = null, float dropout = 0f, long seed = 0, long seed2 = 0, long num_proj = 0, String opName = "CudnnRNNCanonicalToParamsV2") 
        {
            OperationDescription desc = NewOperation("CudnnRNNCanonicalToParamsV2", opName);
            desc.AddInput(num_layers);
            desc.AddInput(num_units);
            desc.AddInput(input_size);
            desc.AddInput(weights);
            desc.AddInput(biases);
            if (rnn_mode != null)
                 desc.SetAttr("rnn_mode", rnn_mode);
            if (input_mode != null)
                 desc.SetAttr("input_mode", input_mode);
            if (direction != null)
                 desc.SetAttr("direction", direction);
            if (dropout != 0f)
                desc.SetAttr("dropout", dropout);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            if (num_proj != 0)
                desc.SetAttr("num_proj", num_proj);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CudnnRNNParamsSize
        /// </summary>
        /// <param name="num_layers">Input to the operation. </param>
        /// <param name="num_units">Input to the operation. </param>
        /// <param name="input_size">Input to the operation. </param>
        /// <param name="T">T</param>
        /// <param name="S">S</param>
        /// <param name="rnn_mode">rnn mode</param>
        /// <param name="input_mode">input mode</param>
        /// <param name="direction">direction</param>
        /// <param name="dropout">dropout</param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="num_proj">num proj</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] params_size(type: DtInvalid).
        /// </returns>
        public Operation CudnnRNNParamsSize(Output num_layers, Output num_units, Output input_size, DataType T, DataType S, string rnn_mode = null, string input_mode = null, string direction = null, float dropout = 0f, long seed = 0, long seed2 = 0, long num_proj = 0, String opName = "CudnnRNNParamsSize") 
        {
            OperationDescription desc = NewOperation("CudnnRNNParamsSize", opName);
            desc.AddInput(num_layers);
            desc.AddInput(num_units);
            desc.AddInput(input_size);
            desc.SetAttr("T", T);
            desc.SetAttr("S", S);
            if (rnn_mode != null)
                 desc.SetAttr("rnn_mode", rnn_mode);
            if (input_mode != null)
                 desc.SetAttr("input_mode", input_mode);
            if (direction != null)
                 desc.SetAttr("direction", direction);
            if (dropout != 0f)
                desc.SetAttr("dropout", dropout);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            if (num_proj != 0)
                desc.SetAttr("num_proj", num_proj);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CudnnRNNParamsToCanonical
        /// </summary>
        /// <param name="num_layers">Input to the operation. </param>
        /// <param name="num_units">Input to the operation. </param>
        /// <param name="input_size">Input to the operation. </param>
        /// <param name="parameters">Input to the operation. </param>
        /// <param name="num_params">num params</param>
        /// <param name="rnn_mode">rnn mode</param>
        /// <param name="input_mode">input mode</param>
        /// <param name="direction">direction</param>
        /// <param name="dropout">dropout</param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] weights(type: DtInvalid).
        /// [1] biases(type: DtInvalid).
        /// </returns>
        public Operation CudnnRNNParamsToCanonical(Output num_layers, Output num_units, Output input_size, Output parameters, long num_params, string rnn_mode = null, string input_mode = null, string direction = null, float dropout = 0f, long seed = 0, long seed2 = 0, String opName = "CudnnRNNParamsToCanonical") 
        {
            OperationDescription desc = NewOperation("CudnnRNNParamsToCanonical", opName);
            desc.AddInput(num_layers);
            desc.AddInput(num_units);
            desc.AddInput(input_size);
            desc.AddInput(parameters);
            desc.SetAttr("num_params", num_params);
            if (rnn_mode != null)
                 desc.SetAttr("rnn_mode", rnn_mode);
            if (input_mode != null)
                 desc.SetAttr("input_mode", input_mode);
            if (direction != null)
                 desc.SetAttr("direction", direction);
            if (dropout != 0f)
                desc.SetAttr("dropout", dropout);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CudnnRNNParamsToCanonicalV2
        /// </summary>
        /// <param name="num_layers">Input to the operation. </param>
        /// <param name="num_units">Input to the operation. </param>
        /// <param name="input_size">Input to the operation. </param>
        /// <param name="parameters">Input to the operation. </param>
        /// <param name="num_params_weights">num params weights</param>
        /// <param name="num_params_biases">num params biases</param>
        /// <param name="rnn_mode">rnn mode</param>
        /// <param name="input_mode">input mode</param>
        /// <param name="direction">direction</param>
        /// <param name="dropout">dropout</param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="num_proj">num proj</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] weights(type: DtInvalid).
        /// [1] biases(type: DtInvalid).
        /// </returns>
        public Operation CudnnRNNParamsToCanonicalV2(Output num_layers, Output num_units, Output input_size, Output parameters, long num_params_weights, long num_params_biases, string rnn_mode = null, string input_mode = null, string direction = null, float dropout = 0f, long seed = 0, long seed2 = 0, long num_proj = 0, String opName = "CudnnRNNParamsToCanonicalV2") 
        {
            OperationDescription desc = NewOperation("CudnnRNNParamsToCanonicalV2", opName);
            desc.AddInput(num_layers);
            desc.AddInput(num_units);
            desc.AddInput(input_size);
            desc.AddInput(parameters);
            desc.SetAttr("num_params_weights", num_params_weights);
            desc.SetAttr("num_params_biases", num_params_biases);
            if (rnn_mode != null)
                 desc.SetAttr("rnn_mode", rnn_mode);
            if (input_mode != null)
                 desc.SetAttr("input_mode", input_mode);
            if (direction != null)
                 desc.SetAttr("direction", direction);
            if (dropout != 0f)
                desc.SetAttr("dropout", dropout);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            if (num_proj != 0)
                desc.SetAttr("num_proj", num_proj);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CudnnRNNV2
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="input_h">Input to the operation. </param>
        /// <param name="input_c">Input to the operation. </param>
        /// <param name="parameters">Input to the operation. </param>
        /// <param name="rnn_mode">rnn mode</param>
        /// <param name="input_mode">input mode</param>
        /// <param name="direction">direction</param>
        /// <param name="dropout">dropout</param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="is_training">is training</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] output_h(type: DtInvalid).
        /// [2] output_c(type: DtInvalid).
        /// [3] reserve_space(type: DtInvalid).
        /// [4] host_reserved(type: DtInt8).
        /// </returns>
        public Operation CudnnRNNV2(Output input, Output input_h, Output input_c, Output parameters, string rnn_mode = null, string input_mode = null, string direction = null, float dropout = 0f, long seed = 0, long seed2 = 0, bool is_training = true, String opName = "CudnnRNNV2") 
        {
            OperationDescription desc = NewOperation("CudnnRNNV2", opName);
            desc.AddInput(input);
            desc.AddInput(input_h);
            desc.AddInput(input_c);
            desc.AddInput(parameters);
            if (rnn_mode != null)
                 desc.SetAttr("rnn_mode", rnn_mode);
            if (input_mode != null)
                 desc.SetAttr("input_mode", input_mode);
            if (direction != null)
                 desc.SetAttr("direction", direction);
            if (dropout != 0f)
                desc.SetAttr("dropout", dropout);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            if (is_training != true)
                desc.SetAttr("is_training", is_training);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CudnnRNNV3
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="input_h">Input to the operation. </param>
        /// <param name="input_c">Input to the operation. </param>
        /// <param name="parameters">Input to the operation. </param>
        /// <param name="sequence_lengths">Input to the operation. </param>
        /// <param name="rnn_mode">rnn mode</param>
        /// <param name="input_mode">input mode</param>
        /// <param name="direction">direction</param>
        /// <param name="dropout">dropout</param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="num_proj">num proj</param>
        /// <param name="is_training">is training</param>
        /// <param name="time_major">time major</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] output_h(type: DtInvalid).
        /// [2] output_c(type: DtInvalid).
        /// [3] reserve_space(type: DtInvalid).
        /// [4] host_reserved(type: DtInt8).
        /// </returns>
        public Operation CudnnRNNV3(Output input, Output input_h, Output input_c, Output parameters, Output sequence_lengths, string rnn_mode = null, string input_mode = null, string direction = null, float dropout = 0f, long seed = 0, long seed2 = 0, long num_proj = 0, bool is_training = true, bool time_major = true, String opName = "CudnnRNNV3") 
        {
            OperationDescription desc = NewOperation("CudnnRNNV3", opName);
            desc.AddInput(input);
            desc.AddInput(input_h);
            desc.AddInput(input_c);
            desc.AddInput(parameters);
            desc.AddInput(sequence_lengths);
            if (rnn_mode != null)
                 desc.SetAttr("rnn_mode", rnn_mode);
            if (input_mode != null)
                 desc.SetAttr("input_mode", input_mode);
            if (direction != null)
                 desc.SetAttr("direction", direction);
            if (dropout != 0f)
                desc.SetAttr("dropout", dropout);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            if (num_proj != 0)
                desc.SetAttr("num_proj", num_proj);
            if (is_training != true)
                desc.SetAttr("is_training", is_training);
            if (time_major != true)
                desc.SetAttr("time_major", time_major);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Cumprod
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="axis">Input to the operation. </param>
        /// <param name="exclusive">exclusive</param>
        /// <param name="reverse">reverse</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation Cumprod(Output x, Output axis, bool exclusive = false, bool reverse = false, String opName = "Cumprod") 
        {
            OperationDescription desc = NewOperation("Cumprod", opName);
            desc.AddInput(x);
            desc.AddInput(axis);
            if (exclusive != false)
                desc.SetAttr("exclusive", exclusive);
            if (reverse != false)
                desc.SetAttr("reverse", reverse);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Cumsum
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="axis">Input to the operation. </param>
        /// <param name="exclusive">exclusive</param>
        /// <param name="reverse">reverse</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation Cumsum(Output x, Output axis, bool exclusive = false, bool reverse = false, String opName = "Cumsum") 
        {
            OperationDescription desc = NewOperation("Cumsum", opName);
            desc.AddInput(x);
            desc.AddInput(axis);
            if (exclusive != false)
                desc.SetAttr("exclusive", exclusive);
            if (reverse != false)
                desc.SetAttr("reverse", reverse);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// CumulativeLogsumexp
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="axis">Input to the operation. </param>
        /// <param name="exclusive">exclusive</param>
        /// <param name="reverse">reverse</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation CumulativeLogsumexp(Output x, Output axis, bool exclusive = false, bool reverse = false, String opName = "CumulativeLogsumexp") 
        {
            OperationDescription desc = NewOperation("CumulativeLogsumexp", opName);
            desc.AddInput(x);
            desc.AddInput(axis);
            if (exclusive != false)
                desc.SetAttr("exclusive", exclusive);
            if (reverse != false)
                desc.SetAttr("reverse", reverse);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DataFormatDimMap
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="src_format">src format</param>
        /// <param name="dst_format">dst format</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation DataFormatDimMap(Output x, string src_format = null, string dst_format = null, String opName = "DataFormatDimMap") 
        {
            OperationDescription desc = NewOperation("DataFormatDimMap", opName);
            desc.AddInput(x);
            if (src_format != null)
                 desc.SetAttr("src_format", src_format);
            if (dst_format != null)
                 desc.SetAttr("dst_format", dst_format);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DataFormatVecPermute
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="src_format">src format</param>
        /// <param name="dst_format">dst format</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation DataFormatVecPermute(Output x, string src_format = null, string dst_format = null, String opName = "DataFormatVecPermute") 
        {
            OperationDescription desc = NewOperation("DataFormatVecPermute", opName);
            desc.AddInput(x);
            if (src_format != null)
                 desc.SetAttr("src_format", src_format);
            if (dst_format != null)
                 desc.SetAttr("dst_format", dst_format);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DataServiceDataset
        /// </summary>
        /// <param name="dataset_id">Input to the operation. </param>
        /// <param name="processing_mode">Input to the operation. </param>
        /// <param name="address">Input to the operation. </param>
        /// <param name="protocol">Input to the operation. </param>
        /// <param name="job_name">Input to the operation. </param>
        /// <param name="max_outstanding_requests">Input to the operation. </param>
        /// <param name="iteration_counter">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="task_refresh_interval_hint_ms">task refresh interval hint ms</param>
        /// <param name="data_transfer_protocol">data transfer protocol</param>
        /// <param name="target_workers">target workers</param>
        /// <param name="cross_trainer_cache_options">cross trainer cache options</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation DataServiceDataset(Output dataset_id, Output processing_mode, Output address, Output protocol, Output job_name, Output max_outstanding_requests, Output iteration_counter, DataType[] output_types, long[][] output_shapes, long task_refresh_interval_hint_ms = -1, string data_transfer_protocol = null, string target_workers = null, string cross_trainer_cache_options = null, String opName = "DataServiceDataset") 
        {
            OperationDescription desc = NewOperation("DataServiceDataset", opName);
            desc.AddInput(dataset_id);
            desc.AddInput(processing_mode);
            desc.AddInput(address);
            desc.AddInput(protocol);
            desc.AddInput(job_name);
            desc.AddInput(max_outstanding_requests);
            desc.AddInput(iteration_counter);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (task_refresh_interval_hint_ms != -1)
                desc.SetAttr("task_refresh_interval_hint_ms", task_refresh_interval_hint_ms);
            if (data_transfer_protocol != null)
                 desc.SetAttr("data_transfer_protocol", data_transfer_protocol);
            if (target_workers != null)
                 desc.SetAttr("target_workers", target_workers);
            if (cross_trainer_cache_options != null)
                 desc.SetAttr("cross_trainer_cache_options", cross_trainer_cache_options);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DataServiceDatasetV2
        /// </summary>
        /// <param name="dataset_id">Input to the operation. </param>
        /// <param name="processing_mode">Input to the operation. </param>
        /// <param name="address">Input to the operation. </param>
        /// <param name="protocol">Input to the operation. </param>
        /// <param name="job_name">Input to the operation. </param>
        /// <param name="consumer_index">Input to the operation. </param>
        /// <param name="num_consumers">Input to the operation. </param>
        /// <param name="max_outstanding_requests">Input to the operation. </param>
        /// <param name="iteration_counter">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="task_refresh_interval_hint_ms">task refresh interval hint ms</param>
        /// <param name="data_transfer_protocol">data transfer protocol</param>
        /// <param name="target_workers">target workers</param>
        /// <param name="cross_trainer_cache_options">cross trainer cache options</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation DataServiceDatasetV2(Output dataset_id, Output processing_mode, Output address, Output protocol, Output job_name, Output consumer_index, Output num_consumers, Output max_outstanding_requests, Output iteration_counter, DataType[] output_types, long[][] output_shapes, long task_refresh_interval_hint_ms = -1, string data_transfer_protocol = null, string target_workers = null, string cross_trainer_cache_options = null, String opName = "DataServiceDatasetV2") 
        {
            OperationDescription desc = NewOperation("DataServiceDatasetV2", opName);
            desc.AddInput(dataset_id);
            desc.AddInput(processing_mode);
            desc.AddInput(address);
            desc.AddInput(protocol);
            desc.AddInput(job_name);
            desc.AddInput(consumer_index);
            desc.AddInput(num_consumers);
            desc.AddInput(max_outstanding_requests);
            desc.AddInput(iteration_counter);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (task_refresh_interval_hint_ms != -1)
                desc.SetAttr("task_refresh_interval_hint_ms", task_refresh_interval_hint_ms);
            if (data_transfer_protocol != null)
                 desc.SetAttr("data_transfer_protocol", data_transfer_protocol);
            if (target_workers != null)
                 desc.SetAttr("target_workers", target_workers);
            if (cross_trainer_cache_options != null)
                 desc.SetAttr("cross_trainer_cache_options", cross_trainer_cache_options);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DataServiceDatasetV3
        /// </summary>
        /// <param name="dataset_id">Input to the operation. </param>
        /// <param name="processing_mode">Input to the operation. </param>
        /// <param name="address">Input to the operation. </param>
        /// <param name="protocol">Input to the operation. </param>
        /// <param name="job_name">Input to the operation. </param>
        /// <param name="consumer_index">Input to the operation. </param>
        /// <param name="num_consumers">Input to the operation. </param>
        /// <param name="max_outstanding_requests">Input to the operation. </param>
        /// <param name="iteration_counter">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="task_refresh_interval_hint_ms">task refresh interval hint ms</param>
        /// <param name="data_transfer_protocol">data transfer protocol</param>
        /// <param name="target_workers">target workers</param>
        /// <param name="uncompress">uncompress</param>
        /// <param name="cross_trainer_cache_options">cross trainer cache options</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: uncompress_fn: func
        public Operation DataServiceDatasetV3(Output dataset_id, Output processing_mode, Output address, Output protocol, Output job_name, Output consumer_index, Output num_consumers, Output max_outstanding_requests, Output iteration_counter, DataType[] output_types, long[][] output_shapes, long task_refresh_interval_hint_ms = -1, string data_transfer_protocol = null, string target_workers = null, bool uncompress = false, string cross_trainer_cache_options = null, String opName = "DataServiceDatasetV3") 
        {
            OperationDescription desc = NewOperation("DataServiceDatasetV3", opName);
            desc.AddInput(dataset_id);
            desc.AddInput(processing_mode);
            desc.AddInput(address);
            desc.AddInput(protocol);
            desc.AddInput(job_name);
            desc.AddInput(consumer_index);
            desc.AddInput(num_consumers);
            desc.AddInput(max_outstanding_requests);
            desc.AddInput(iteration_counter);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (task_refresh_interval_hint_ms != -1)
                desc.SetAttr("task_refresh_interval_hint_ms", task_refresh_interval_hint_ms);
            if (data_transfer_protocol != null)
                 desc.SetAttr("data_transfer_protocol", data_transfer_protocol);
            if (target_workers != null)
                 desc.SetAttr("target_workers", target_workers);
            if (uncompress != false)
                desc.SetAttr("uncompress", uncompress);
            if (cross_trainer_cache_options != null)
                 desc.SetAttr("cross_trainer_cache_options", cross_trainer_cache_options);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DataServiceDatasetV4
        /// </summary>
        /// <param name="dataset_id">Input to the operation. </param>
        /// <param name="processing_mode">Input to the operation. </param>
        /// <param name="address">Input to the operation. </param>
        /// <param name="protocol">Input to the operation. </param>
        /// <param name="job_name">Input to the operation. </param>
        /// <param name="consumer_index">Input to the operation. </param>
        /// <param name="num_consumers">Input to the operation. </param>
        /// <param name="max_outstanding_requests">Input to the operation. </param>
        /// <param name="iteration_counter">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="task_refresh_interval_hint_ms">task refresh interval hint ms</param>
        /// <param name="data_transfer_protocol">data transfer protocol</param>
        /// <param name="target_workers">target workers</param>
        /// <param name="uncompress">uncompress</param>
        /// <param name="cross_trainer_cache_options">cross trainer cache options</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: uncompress_fn: func
        public Operation DataServiceDatasetV4(Output dataset_id, Output processing_mode, Output address, Output protocol, Output job_name, Output consumer_index, Output num_consumers, Output max_outstanding_requests, Output iteration_counter, DataType[] output_types, long[][] output_shapes, long task_refresh_interval_hint_ms = -1, string data_transfer_protocol = null, string target_workers = null, bool uncompress = false, string cross_trainer_cache_options = null, String opName = "DataServiceDatasetV4") 
        {
            OperationDescription desc = NewOperation("DataServiceDatasetV4", opName);
            desc.AddInput(dataset_id);
            desc.AddInput(processing_mode);
            desc.AddInput(address);
            desc.AddInput(protocol);
            desc.AddInput(job_name);
            desc.AddInput(consumer_index);
            desc.AddInput(num_consumers);
            desc.AddInput(max_outstanding_requests);
            desc.AddInput(iteration_counter);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (task_refresh_interval_hint_ms != -1)
                desc.SetAttr("task_refresh_interval_hint_ms", task_refresh_interval_hint_ms);
            if (data_transfer_protocol != null)
                 desc.SetAttr("data_transfer_protocol", data_transfer_protocol);
            if (target_workers != null)
                 desc.SetAttr("target_workers", target_workers);
            if (uncompress != false)
                desc.SetAttr("uncompress", uncompress);
            if (cross_trainer_cache_options != null)
                 desc.SetAttr("cross_trainer_cache_options", cross_trainer_cache_options);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DatasetCardinality
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="cardinality_options">cardinality options</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] cardinality(type: DtInt64).
        /// </returns>
        public Operation DatasetCardinality(Output input_dataset, string cardinality_options = null, String opName = "DatasetCardinality") 
        {
            OperationDescription desc = NewOperation("DatasetCardinality", opName);
            desc.AddInput(input_dataset);
            if (cardinality_options != null)
                 desc.SetAttr("cardinality_options", cardinality_options);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DatasetFingerprint
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] fingerprint(type: DtUint64).
        /// </returns>
        public Operation DatasetFingerprint(Output input_dataset, String opName = "DatasetFingerprint") 
        {
            OperationDescription desc = NewOperation("DatasetFingerprint", opName);
            desc.AddInput(input_dataset);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DatasetFromGraph
        /// </summary>
        /// <param name="graph_def">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation DatasetFromGraph(Output graph_def, String opName = "DatasetFromGraph") 
        {
            OperationDescription desc = NewOperation("DatasetFromGraph", opName);
            desc.AddInput(graph_def);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DatasetToGraph
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="stateful_whitelist">stateful whitelist</param>
        /// <param name="allow_stateful">allow stateful</param>
        /// <param name="strip_device_assignment">strip device assignment</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] graph(type: DtString).
        /// </returns>
        public Operation DatasetToGraph(Output input_dataset, string[] stateful_whitelist = null, bool allow_stateful = false, bool strip_device_assignment = false, String opName = "DatasetToGraph") 
        {
            OperationDescription desc = NewOperation("DatasetToGraph", opName);
            desc.AddInput(input_dataset);
            if (stateful_whitelist != null) desc.SetAttr("stateful_whitelist", stateful_whitelist);
            if (allow_stateful != false)
                desc.SetAttr("allow_stateful", allow_stateful);
            if (strip_device_assignment != false)
                desc.SetAttr("strip_device_assignment", strip_device_assignment);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DatasetToGraphV2
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="external_state_policy">external state policy</param>
        /// <param name="strip_device_assignment">strip device assignment</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] graph(type: DtString).
        /// </returns>
        public Operation DatasetToGraphV2(Output input_dataset, long external_state_policy = 0, bool strip_device_assignment = false, String opName = "DatasetToGraphV2") 
        {
            OperationDescription desc = NewOperation("DatasetToGraphV2", opName);
            desc.AddInput(input_dataset);
            if (external_state_policy != 0)
                desc.SetAttr("external_state_policy", external_state_policy);
            if (strip_device_assignment != false)
                desc.SetAttr("strip_device_assignment", strip_device_assignment);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DatasetToSingleElement
        /// </summary>
        /// <param name="dataset">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] components(type: DtInvalid).
        /// </returns>
        public Operation DatasetToSingleElement(Output dataset, DataType[] output_types, long[][] output_shapes, string metadata = null, String opName = "DatasetToSingleElement") 
        {
            OperationDescription desc = NewOperation("DatasetToSingleElement", opName);
            desc.AddInput(dataset);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DatasetToTFRecord
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="filename">Input to the operation. </param>
        /// <param name="compression_type">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation DatasetToTFRecord(Output input_dataset, Output filename, Output compression_type, String opName = "DatasetToTFRecord") 
        {
            OperationDescription desc = NewOperation("DatasetToTFRecord", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(filename);
            desc.AddInput(compression_type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Dawsn
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Dawsn(Output x, String opName = "Dawsn") 
        {
            OperationDescription desc = NewOperation("Dawsn", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DebugGradientIdentity
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation DebugGradientIdentity(Output input, String opName = "DebugGradientIdentity") 
        {
            OperationDescription desc = NewOperation("DebugGradientIdentity", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DebugGradientRefIdentity
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation DebugGradientRefIdentity(Output input, String opName = "DebugGradientRefIdentity") 
        {
            OperationDescription desc = NewOperation("DebugGradientRefIdentity", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DebugIdentity
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="device_name">device name</param>
        /// <param name="tensor_name">tensor name</param>
        /// <param name="debug_urls">debug urls</param>
        /// <param name="gated_grpc">gated grpc</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation DebugIdentity(Output input, string device_name = null, string tensor_name = null, string[] debug_urls = null, bool gated_grpc = false, String opName = "DebugIdentity") 
        {
            OperationDescription desc = NewOperation("DebugIdentity", opName);
            desc.AddInput(input);
            if (device_name != null)
                 desc.SetAttr("device_name", device_name);
            if (tensor_name != null)
                 desc.SetAttr("tensor_name", tensor_name);
            if (debug_urls != null) desc.SetAttr("debug_urls", debug_urls);
            if (gated_grpc != false)
                desc.SetAttr("gated_grpc", gated_grpc);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DebugIdentityV2
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="tfdbg_context_id">tfdbg context id</param>
        /// <param name="op_name">op name</param>
        /// <param name="output_slot">output slot</param>
        /// <param name="tensor_debug_mode">tensor debug mode</param>
        /// <param name="debug_urls">debug urls</param>
        /// <param name="circular_buffer_size">circular buffer size</param>
        /// <param name="tfdbg_run_id">tfdbg run id</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation DebugIdentityV2(Output input, string tfdbg_context_id = null, string op_name = null, long output_slot = -1, long tensor_debug_mode = -1, string[] debug_urls = null, long circular_buffer_size = 1000, string tfdbg_run_id = null, String opName = "DebugIdentityV2") 
        {
            OperationDescription desc = NewOperation("DebugIdentityV2", opName);
            desc.AddInput(input);
            if (tfdbg_context_id != null)
                 desc.SetAttr("tfdbg_context_id", tfdbg_context_id);
            if (op_name != null)
                 desc.SetAttr("op_name", op_name);
            if (output_slot != -1)
                desc.SetAttr("output_slot", output_slot);
            if (tensor_debug_mode != -1)
                desc.SetAttr("tensor_debug_mode", tensor_debug_mode);
            if (debug_urls != null) desc.SetAttr("debug_urls", debug_urls);
            if (circular_buffer_size != 1000)
                desc.SetAttr("circular_buffer_size", circular_buffer_size);
            if (tfdbg_run_id != null)
                 desc.SetAttr("tfdbg_run_id", tfdbg_run_id);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DebugIdentityV3
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="device_name">device name</param>
        /// <param name="tensor_name">tensor name</param>
        /// <param name="io_of_node">io of node</param>
        /// <param name="is_input">is input</param>
        /// <param name="io_index">io index</param>
        /// <param name="debug_urls">debug urls</param>
        /// <param name="gated_grpc">gated grpc</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation DebugIdentityV3(Output input, string device_name = null, string tensor_name = null, string io_of_node = null, bool is_input = false, long io_index = -1, string[] debug_urls = null, bool gated_grpc = false, String opName = "DebugIdentityV3") 
        {
            OperationDescription desc = NewOperation("DebugIdentityV3", opName);
            desc.AddInput(input);
            if (device_name != null)
                 desc.SetAttr("device_name", device_name);
            if (tensor_name != null)
                 desc.SetAttr("tensor_name", tensor_name);
            if (io_of_node != null)
                 desc.SetAttr("io_of_node", io_of_node);
            if (is_input != false)
                desc.SetAttr("is_input", is_input);
            if (io_index != -1)
                desc.SetAttr("io_index", io_index);
            if (debug_urls != null) desc.SetAttr("debug_urls", debug_urls);
            if (gated_grpc != false)
                desc.SetAttr("gated_grpc", gated_grpc);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DebugNanCount
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="device_name">device name</param>
        /// <param name="tensor_name">tensor name</param>
        /// <param name="debug_urls">debug urls</param>
        /// <param name="gated_grpc">gated grpc</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInt64).
        /// </returns>
        public Operation DebugNanCount(Output input, string device_name = null, string tensor_name = null, string[] debug_urls = null, bool gated_grpc = false, String opName = "DebugNanCount") 
        {
            OperationDescription desc = NewOperation("DebugNanCount", opName);
            desc.AddInput(input);
            if (device_name != null)
                 desc.SetAttr("device_name", device_name);
            if (tensor_name != null)
                 desc.SetAttr("tensor_name", tensor_name);
            if (debug_urls != null) desc.SetAttr("debug_urls", debug_urls);
            if (gated_grpc != false)
                desc.SetAttr("gated_grpc", gated_grpc);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DebugNumericSummary
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="device_name">device name</param>
        /// <param name="tensor_name">tensor name</param>
        /// <param name="debug_urls">debug urls</param>
        /// <param name="lower_bound">lower bound</param>
        /// <param name="upper_bound">upper bound</param>
        /// <param name="mute_if_healthy">mute if healthy</param>
        /// <param name="gated_grpc">gated grpc</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtDouble).
        /// </returns>
        public Operation DebugNumericSummary(Output input, string device_name = null, string tensor_name = null, string[] debug_urls = null, float lower_bound = Single.NegativeInfinity, float upper_bound = Single.PositiveInfinity, bool mute_if_healthy = false, bool gated_grpc = false, String opName = "DebugNumericSummary") 
        {
            OperationDescription desc = NewOperation("DebugNumericSummary", opName);
            desc.AddInput(input);
            if (device_name != null)
                 desc.SetAttr("device_name", device_name);
            if (tensor_name != null)
                 desc.SetAttr("tensor_name", tensor_name);
            if (debug_urls != null) desc.SetAttr("debug_urls", debug_urls);
            if (lower_bound != Single.NegativeInfinity)
                desc.SetAttr("lower_bound", lower_bound);
            if (upper_bound != Single.PositiveInfinity)
                desc.SetAttr("upper_bound", upper_bound);
            if (mute_if_healthy != false)
                desc.SetAttr("mute_if_healthy", mute_if_healthy);
            if (gated_grpc != false)
                desc.SetAttr("gated_grpc", gated_grpc);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DebugNumericSummaryV2
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="output_dtype">output dtype</param>
        /// <param name="tensor_debug_mode">tensor debug mode</param>
        /// <param name="tensor_id">tensor id</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation DebugNumericSummaryV2(Output input, DataType? output_dtype = null, long tensor_debug_mode = -1, long tensor_id = -1, String opName = "DebugNumericSummaryV2") 
        {
            OperationDescription desc = NewOperation("DebugNumericSummaryV2", opName);
            desc.AddInput(input);
            if (output_dtype.HasValue)
                desc.SetAttr("output_dtype", output_dtype.Value);
            if (tensor_debug_mode != -1)
                desc.SetAttr("tensor_debug_mode", tensor_debug_mode);
            if (tensor_id != -1)
                desc.SetAttr("tensor_id", tensor_id);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DecodeAndCropJpeg
        /// </summary>
        /// <param name="contents">Input to the operation. </param>
        /// <param name="crop_window">Input to the operation. </param>
        /// <param name="channels">channels</param>
        /// <param name="ratio">ratio</param>
        /// <param name="fancy_upscaling">fancy upscaling</param>
        /// <param name="try_recover_truncated">try recover truncated</param>
        /// <param name="acceptable_fraction">acceptable fraction</param>
        /// <param name="dct_method">dct method</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] image(type: DtUint8).
        /// </returns>
        public Operation DecodeAndCropJpeg(Output contents, Output crop_window, long channels = 0, long ratio = 1, bool fancy_upscaling = true, bool try_recover_truncated = false, float acceptable_fraction = 1f, string dct_method = null, String opName = "DecodeAndCropJpeg") 
        {
            OperationDescription desc = NewOperation("DecodeAndCropJpeg", opName);
            desc.AddInput(contents);
            desc.AddInput(crop_window);
            if (channels != 0)
                desc.SetAttr("channels", channels);
            if (ratio != 1)
                desc.SetAttr("ratio", ratio);
            if (fancy_upscaling != true)
                desc.SetAttr("fancy_upscaling", fancy_upscaling);
            if (try_recover_truncated != false)
                desc.SetAttr("try_recover_truncated", try_recover_truncated);
            if (acceptable_fraction != 1f)
                desc.SetAttr("acceptable_fraction", acceptable_fraction);
            if (dct_method != null)
                 desc.SetAttr("dct_method", dct_method);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DecodeBase64
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtString).
        /// </returns>
        public Operation DecodeBase64(Output input, String opName = "DecodeBase64") 
        {
            OperationDescription desc = NewOperation("DecodeBase64", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DecodeBmp
        /// </summary>
        /// <param name="contents">Input to the operation. </param>
        /// <param name="channels">channels</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] image(type: DtUint8).
        /// </returns>
        public Operation DecodeBmp(Output contents, long channels = 0, String opName = "DecodeBmp") 
        {
            OperationDescription desc = NewOperation("DecodeBmp", opName);
            desc.AddInput(contents);
            if (channels != 0)
                desc.SetAttr("channels", channels);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DecodeCompressed
        /// </summary>
        /// <param name="bytes">Input to the operation. </param>
        /// <param name="compression_type">compression type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtString).
        /// </returns>
        public Operation DecodeCompressed(Output bytes, string compression_type = null, String opName = "DecodeCompressed") 
        {
            OperationDescription desc = NewOperation("DecodeCompressed", opName);
            desc.AddInput(bytes);
            if (compression_type != null)
                 desc.SetAttr("compression_type", compression_type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DecodeCSV
        /// </summary>
        /// <param name="records">Input to the operation. </param>
        /// <param name="record_defaults">Input to the operation. </param>
        /// <param name="field_delim">field delim</param>
        /// <param name="use_quote_delim">use quote delim</param>
        /// <param name="na_value">na value</param>
        /// <param name="select_cols">select cols</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation DecodeCSV(Output records, Output record_defaults, string field_delim = null, bool use_quote_delim = true, string na_value = null, long[] select_cols = null, String opName = "DecodeCSV") 
        {
            OperationDescription desc = NewOperation("DecodeCSV", opName);
            desc.AddInput(records);
            desc.AddInput(record_defaults);
            if (field_delim != null)
                 desc.SetAttr("field_delim", field_delim);
            if (use_quote_delim != true)
                desc.SetAttr("use_quote_delim", use_quote_delim);
            if (na_value != null)
                 desc.SetAttr("na_value", na_value);
            if (select_cols != null) desc.SetAttr("select_cols", select_cols);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DecodeGif
        /// </summary>
        /// <param name="contents">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] image(type: DtUint8).
        /// </returns>
        public Operation DecodeGif(Output contents, String opName = "DecodeGif") 
        {
            OperationDescription desc = NewOperation("DecodeGif", opName);
            desc.AddInput(contents);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DecodeImage
        /// </summary>
        /// <param name="contents">Input to the operation. </param>
        /// <param name="channels">channels</param>
        /// <param name="dtype">dtype</param>
        /// <param name="expand_animations">expand animations</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] image(type: DtInvalid).
        /// </returns>
        public Operation DecodeImage(Output contents, long channels = 0, DataType? dtype = null, bool expand_animations = true, String opName = "DecodeImage") 
        {
            OperationDescription desc = NewOperation("DecodeImage", opName);
            desc.AddInput(contents);
            if (channels != 0)
                desc.SetAttr("channels", channels);
            if (dtype.HasValue)
                desc.SetAttr("dtype", dtype.Value);
            if (expand_animations != true)
                desc.SetAttr("expand_animations", expand_animations);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DecodeJpeg
        /// </summary>
        /// <param name="contents">Input to the operation. </param>
        /// <param name="channels">channels</param>
        /// <param name="ratio">ratio</param>
        /// <param name="fancy_upscaling">fancy upscaling</param>
        /// <param name="try_recover_truncated">try recover truncated</param>
        /// <param name="acceptable_fraction">acceptable fraction</param>
        /// <param name="dct_method">dct method</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] image(type: DtUint8).
        /// </returns>
        public Operation DecodeJpeg(Output contents, long channels = 0, long ratio = 1, bool fancy_upscaling = true, bool try_recover_truncated = false, float acceptable_fraction = 1f, string dct_method = null, String opName = "DecodeJpeg") 
        {
            OperationDescription desc = NewOperation("DecodeJpeg", opName);
            desc.AddInput(contents);
            if (channels != 0)
                desc.SetAttr("channels", channels);
            if (ratio != 1)
                desc.SetAttr("ratio", ratio);
            if (fancy_upscaling != true)
                desc.SetAttr("fancy_upscaling", fancy_upscaling);
            if (try_recover_truncated != false)
                desc.SetAttr("try_recover_truncated", try_recover_truncated);
            if (acceptable_fraction != 1f)
                desc.SetAttr("acceptable_fraction", acceptable_fraction);
            if (dct_method != null)
                 desc.SetAttr("dct_method", dct_method);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DecodeJSONExample
        /// </summary>
        /// <param name="json_examples">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] binary_examples(type: DtString).
        /// </returns>
        public Operation DecodeJSONExample(Output json_examples, String opName = "DecodeJSONExample") 
        {
            OperationDescription desc = NewOperation("DecodeJSONExample", opName);
            desc.AddInput(json_examples);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DecodePaddedRaw
        /// </summary>
        /// <param name="input_bytes">Input to the operation. </param>
        /// <param name="fixed_length">Input to the operation. </param>
        /// <param name="out_type">out type</param>
        /// <param name="little_endian">little endian</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation DecodePaddedRaw(Output input_bytes, Output fixed_length, DataType out_type, bool little_endian = true, String opName = "DecodePaddedRaw") 
        {
            OperationDescription desc = NewOperation("DecodePaddedRaw", opName);
            desc.AddInput(input_bytes);
            desc.AddInput(fixed_length);
            desc.SetAttr("out_type", out_type);
            if (little_endian != true)
                desc.SetAttr("little_endian", little_endian);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DecodePng
        /// </summary>
        /// <param name="contents">Input to the operation. </param>
        /// <param name="channels">channels</param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] image(type: DtInvalid).
        /// </returns>
        public Operation DecodePng(Output contents, long channels = 0, DataType? dtype = null, String opName = "DecodePng") 
        {
            OperationDescription desc = NewOperation("DecodePng", opName);
            desc.AddInput(contents);
            if (channels != 0)
                desc.SetAttr("channels", channels);
            if (dtype.HasValue)
                desc.SetAttr("dtype", dtype.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DecodeProtoV2
        /// </summary>
        /// <param name="bytes">Input to the operation. </param>
        /// <param name="message_type">message type</param>
        /// <param name="field_names">field names</param>
        /// <param name="output_types">output types</param>
        /// <param name="descriptor_source">descriptor source</param>
        /// <param name="message_format">message format</param>
        /// <param name="sanitize">sanitize</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] sizes(type: DtInt32).
        /// [1] values(type: DtInvalid).
        /// </returns>
        public Operation DecodeProtoV2(Output bytes, string message_type, string[] field_names, DataType[] output_types, string descriptor_source = null, string message_format = null, bool sanitize = false, String opName = "DecodeProtoV2") 
        {
            OperationDescription desc = NewOperation("DecodeProtoV2", opName);
            desc.AddInput(bytes);
            desc.SetAttr("message_type", message_type);
            desc.SetAttr("field_names", field_names);
            desc.SetAttr("output_types", output_types);
            if (descriptor_source != null)
                 desc.SetAttr("descriptor_source", descriptor_source);
            if (message_format != null)
                 desc.SetAttr("message_format", message_format);
            if (sanitize != false)
                desc.SetAttr("sanitize", sanitize);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DecodeRaw
        /// </summary>
        /// <param name="bytes">Input to the operation. </param>
        /// <param name="out_type">out type</param>
        /// <param name="little_endian">little endian</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation DecodeRaw(Output bytes, DataType out_type, bool little_endian = true, String opName = "DecodeRaw") 
        {
            OperationDescription desc = NewOperation("DecodeRaw", opName);
            desc.AddInput(bytes);
            desc.SetAttr("out_type", out_type);
            if (little_endian != true)
                desc.SetAttr("little_endian", little_endian);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DecodeWav
        /// </summary>
        /// <param name="contents">Input to the operation. </param>
        /// <param name="desired_channels">desired channels</param>
        /// <param name="desired_samples">desired samples</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] audio(type: DtFloat).
        /// [1] sample_rate(type: DtInt32).
        /// </returns>
        public Operation DecodeWav(Output contents, long desired_channels = -1, long desired_samples = -1, String opName = "DecodeWav") 
        {
            OperationDescription desc = NewOperation("DecodeWav", opName);
            desc.AddInput(contents);
            if (desired_channels != -1)
                desc.SetAttr("desired_channels", desired_channels);
            if (desired_samples != -1)
                desc.SetAttr("desired_samples", desired_samples);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DeepCopy
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation DeepCopy(Output x, String opName = "DeepCopy") 
        {
            OperationDescription desc = NewOperation("DeepCopy", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DeleteIterator
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="deleter">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation DeleteIterator(Output handle, Output deleter, String opName = "DeleteIterator") 
        {
            OperationDescription desc = NewOperation("DeleteIterator", opName);
            desc.AddInput(handle);
            desc.AddInput(deleter);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DeleteMemoryCache
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="deleter">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation DeleteMemoryCache(Output handle, Output deleter, String opName = "DeleteMemoryCache") 
        {
            OperationDescription desc = NewOperation("DeleteMemoryCache", opName);
            desc.AddInput(handle);
            desc.AddInput(deleter);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DeleteMultiDeviceIterator
        /// </summary>
        /// <param name="multi_device_iterator">Input to the operation. </param>
        /// <param name="iterators">Input to the operation. </param>
        /// <param name="deleter">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation DeleteMultiDeviceIterator(Output multi_device_iterator, Output iterators, Output deleter, String opName = "DeleteMultiDeviceIterator") 
        {
            OperationDescription desc = NewOperation("DeleteMultiDeviceIterator", opName);
            desc.AddInput(multi_device_iterator);
            desc.AddInput(iterators);
            desc.AddInput(deleter);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DeleteRandomSeedGenerator
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="deleter">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation DeleteRandomSeedGenerator(Output handle, Output deleter, String opName = "DeleteRandomSeedGenerator") 
        {
            OperationDescription desc = NewOperation("DeleteRandomSeedGenerator", opName);
            desc.AddInput(handle);
            desc.AddInput(deleter);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DeleteSeedGenerator
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="deleter">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation DeleteSeedGenerator(Output handle, Output deleter, String opName = "DeleteSeedGenerator") 
        {
            OperationDescription desc = NewOperation("DeleteSeedGenerator", opName);
            desc.AddInput(handle);
            desc.AddInput(deleter);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DeleteSessionTensor
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation DeleteSessionTensor(Output handle, String opName = "DeleteSessionTensor") 
        {
            OperationDescription desc = NewOperation("DeleteSessionTensor", opName);
            desc.AddInput(handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DenseBincount
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="size">Input to the operation. </param>
        /// <param name="weights">Input to the operation. </param>
        /// <param name="binary_output">binary output</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation DenseBincount(Output input, Output size, Output weights, bool binary_output = false, String opName = "DenseBincount") 
        {
            OperationDescription desc = NewOperation("DenseBincount", opName);
            desc.AddInput(input);
            desc.AddInput(size);
            desc.AddInput(weights);
            if (binary_output != false)
                desc.SetAttr("binary_output", binary_output);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DenseCountSparseOutput
        /// </summary>
        /// <param name="values">Input to the operation. </param>
        /// <param name="weights">Input to the operation. </param>
        /// <param name="binary_output">binary output</param>
        /// <param name="minlength">minlength</param>
        /// <param name="maxlength">maxlength</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_indices(type: DtInt64).
        /// [1] output_values(type: DtInvalid).
        /// [2] output_dense_shape(type: DtInt64).
        /// </returns>
        public Operation DenseCountSparseOutput(Output values, Output weights, bool binary_output, long minlength = -1, long maxlength = -1, String opName = "DenseCountSparseOutput") 
        {
            OperationDescription desc = NewOperation("DenseCountSparseOutput", opName);
            desc.AddInput(values);
            desc.AddInput(weights);
            desc.SetAttr("binary_output", binary_output);
            if (minlength != -1)
                desc.SetAttr("minlength", minlength);
            if (maxlength != -1)
                desc.SetAttr("maxlength", maxlength);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DenseToCSRSparseMatrix
        /// </summary>
        /// <param name="dense_input">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] sparse_output(type: DtVariant).
        /// </returns>
        public Operation DenseToCSRSparseMatrix(Output dense_input, Output indices, String opName = "DenseToCSRSparseMatrix") 
        {
            OperationDescription desc = NewOperation("DenseToCSRSparseMatrix", opName);
            desc.AddInput(dense_input);
            desc.AddInput(indices);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DenseToDenseSetOperation
        /// </summary>
        /// <param name="set1">Input to the operation. </param>
        /// <param name="set2">Input to the operation. </param>
        /// <param name="set_operation">set operation</param>
        /// <param name="validate_indices">validate indices</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] result_indices(type: DtInt64).
        /// [1] result_values(type: DtInvalid).
        /// [2] result_shape(type: DtInt64).
        /// </returns>
        public Operation DenseToDenseSetOperation(Output set1, Output set2, string set_operation, bool validate_indices = true, String opName = "DenseToDenseSetOperation") 
        {
            OperationDescription desc = NewOperation("DenseToDenseSetOperation", opName);
            desc.AddInput(set1);
            desc.AddInput(set2);
            desc.SetAttr("set_operation", set_operation);
            if (validate_indices != true)
                desc.SetAttr("validate_indices", validate_indices);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DenseToSparseBatchDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="batch_size">Input to the operation. </param>
        /// <param name="row_shape">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation DenseToSparseBatchDataset(Output input_dataset, Output batch_size, Output row_shape, DataType[] output_types, long[][] output_shapes, String opName = "DenseToSparseBatchDataset") 
        {
            OperationDescription desc = NewOperation("DenseToSparseBatchDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(batch_size);
            desc.AddInput(row_shape);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DenseToSparseSetOperation
        /// </summary>
        /// <param name="set1">Input to the operation. </param>
        /// <param name="set2_indices">Input to the operation. </param>
        /// <param name="set2_values">Input to the operation. </param>
        /// <param name="set2_shape">Input to the operation. </param>
        /// <param name="set_operation">set operation</param>
        /// <param name="validate_indices">validate indices</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] result_indices(type: DtInt64).
        /// [1] result_values(type: DtInvalid).
        /// [2] result_shape(type: DtInt64).
        /// </returns>
        public Operation DenseToSparseSetOperation(Output set1, Output set2_indices, Output set2_values, Output set2_shape, string set_operation, bool validate_indices = true, String opName = "DenseToSparseSetOperation") 
        {
            OperationDescription desc = NewOperation("DenseToSparseSetOperation", opName);
            desc.AddInput(set1);
            desc.AddInput(set2_indices);
            desc.AddInput(set2_values);
            desc.AddInput(set2_shape);
            desc.SetAttr("set_operation", set_operation);
            if (validate_indices != true)
                desc.SetAttr("validate_indices", validate_indices);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DepthToSpace
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="block_size">block size</param>
        /// <param name="data_format">data format</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation DepthToSpace(Output input, long block_size, string data_format = null, String opName = "DepthToSpace") 
        {
            OperationDescription desc = NewOperation("DepthToSpace", opName);
            desc.AddInput(input);
            desc.SetAttr("block_size", block_size);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DepthwiseConv2dNative
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="explicit_paddings">explicit paddings</param>
        /// <param name="data_format">data format</param>
        /// <param name="dilations">dilations</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation DepthwiseConv2dNative(Output input, Output filter, long[] strides, string padding, long[] explicit_paddings = null, string data_format = null, long[] dilations = null, String opName = "DepthwiseConv2dNative") 
        {
            OperationDescription desc = NewOperation("DepthwiseConv2dNative", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (explicit_paddings != null) desc.SetAttr("explicit_paddings", explicit_paddings);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DepthwiseConv2dNativeBackpropFilter
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter_sizes">Input to the operation. </param>
        /// <param name="out_backprop">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="explicit_paddings">explicit paddings</param>
        /// <param name="data_format">data format</param>
        /// <param name="dilations">dilations</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation DepthwiseConv2dNativeBackpropFilter(Output input, Output filter_sizes, Output out_backprop, long[] strides, string padding, long[] explicit_paddings = null, string data_format = null, long[] dilations = null, String opName = "DepthwiseConv2dNativeBackpropFilter") 
        {
            OperationDescription desc = NewOperation("DepthwiseConv2dNativeBackpropFilter", opName);
            desc.AddInput(input);
            desc.AddInput(filter_sizes);
            desc.AddInput(out_backprop);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (explicit_paddings != null) desc.SetAttr("explicit_paddings", explicit_paddings);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DepthwiseConv2dNativeBackpropInput
        /// </summary>
        /// <param name="input_sizes">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="out_backprop">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="explicit_paddings">explicit paddings</param>
        /// <param name="data_format">data format</param>
        /// <param name="dilations">dilations</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation DepthwiseConv2dNativeBackpropInput(Output input_sizes, Output filter, Output out_backprop, long[] strides, string padding, long[] explicit_paddings = null, string data_format = null, long[] dilations = null, String opName = "DepthwiseConv2dNativeBackpropInput") 
        {
            OperationDescription desc = NewOperation("DepthwiseConv2dNativeBackpropInput", opName);
            desc.AddInput(input_sizes);
            desc.AddInput(filter);
            desc.AddInput(out_backprop);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (explicit_paddings != null) desc.SetAttr("explicit_paddings", explicit_paddings);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Dequantize
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="min_range">Input to the operation. </param>
        /// <param name="max_range">Input to the operation. </param>
        /// <param name="mode">mode</param>
        /// <param name="narrow_range">narrow range</param>
        /// <param name="axis">axis</param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Dequantize(Output input, Output min_range, Output max_range, string mode = null, bool narrow_range = false, long axis = -1, DataType? dtype = null, String opName = "Dequantize") 
        {
            OperationDescription desc = NewOperation("Dequantize", opName);
            desc.AddInput(input);
            desc.AddInput(min_range);
            desc.AddInput(max_range);
            if (mode != null)
                 desc.SetAttr("mode", mode);
            if (narrow_range != false)
                desc.SetAttr("narrow_range", narrow_range);
            if (axis != -1)
                desc.SetAttr("axis", axis);
            if (dtype.HasValue)
                desc.SetAttr("dtype", dtype.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DeserializeIterator
        /// </summary>
        /// <param name="resource_handle">Input to the operation. </param>
        /// <param name="serialized">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation DeserializeIterator(Output resource_handle, Output serialized, String opName = "DeserializeIterator") 
        {
            OperationDescription desc = NewOperation("DeserializeIterator", opName);
            desc.AddInput(resource_handle);
            desc.AddInput(serialized);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DeserializeManySparse
        /// </summary>
        /// <param name="serialized_sparse">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] sparse_indices(type: DtInt64).
        /// [1] sparse_values(type: DtInvalid).
        /// [2] sparse_shape(type: DtInt64).
        /// </returns>
        public Operation DeserializeManySparse(Output serialized_sparse, DataType dtype, String opName = "DeserializeManySparse") 
        {
            OperationDescription desc = NewOperation("DeserializeManySparse", opName);
            desc.AddInput(serialized_sparse);
            desc.SetAttr("dtype", dtype);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DeserializeSparse
        /// </summary>
        /// <param name="serialized_sparse">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] sparse_indices(type: DtInt64).
        /// [1] sparse_values(type: DtInvalid).
        /// [2] sparse_shape(type: DtInt64).
        /// </returns>
        public Operation DeserializeSparse(Output serialized_sparse, DataType dtype, String opName = "DeserializeSparse") 
        {
            OperationDescription desc = NewOperation("DeserializeSparse", opName);
            desc.AddInput(serialized_sparse);
            desc.SetAttr("dtype", dtype);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DestroyResourceOp
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="ignore_lookup_error">ignore lookup error</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation DestroyResourceOp(Output resource, bool ignore_lookup_error = true, String opName = "DestroyResourceOp") 
        {
            OperationDescription desc = NewOperation("DestroyResourceOp", opName);
            desc.AddInput(resource);
            if (ignore_lookup_error != true)
                desc.SetAttr("ignore_lookup_error", ignore_lookup_error);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DestroyTemporaryVariable
        /// </summary>
        /// <param name="reference">Input to the operation. </param>
        /// <param name="var_name">var name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] value(type: DtInvalid).
        /// </returns>
        public Operation DestroyTemporaryVariable(Output reference, string var_name, String opName = "DestroyTemporaryVariable") 
        {
            OperationDescription desc = NewOperation("DestroyTemporaryVariable", opName);
            desc.AddInput(reference);
            desc.SetAttr("var_name", var_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DeviceIndex
        /// </summary>
        /// <param name="device_names">device names</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] index(type: DtInt32).
        /// </returns>
        public Operation DeviceIndex(string[] device_names, String opName = "DeviceIndex") 
        {
            OperationDescription desc = NewOperation("DeviceIndex", opName);
            desc.SetAttr("device_names", device_names);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Diag
        /// </summary>
        /// <param name="diagonal">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Diag(Output diagonal, String opName = "Diag") 
        {
            OperationDescription desc = NewOperation("Diag", opName);
            desc.AddInput(diagonal);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DiagPart
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] diagonal(type: DtInvalid).
        /// </returns>
        public Operation DiagPart(Output input, String opName = "DiagPart") 
        {
            OperationDescription desc = NewOperation("DiagPart", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Digamma
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Digamma(Output x, String opName = "Digamma") 
        {
            OperationDescription desc = NewOperation("Digamma", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Dilation2D
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="rates">rates</param>
        /// <param name="padding">padding</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Dilation2D(Output input, Output filter, long[] strides, long[] rates, string padding, String opName = "Dilation2D") 
        {
            OperationDescription desc = NewOperation("Dilation2D", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.SetAttr("strides", strides);
            desc.SetAttr("rates", rates);
            desc.SetAttr("padding", padding);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Dilation2DBackpropFilter
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="out_backprop">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="rates">rates</param>
        /// <param name="padding">padding</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] filter_backprop(type: DtInvalid).
        /// </returns>
        public Operation Dilation2DBackpropFilter(Output input, Output filter, Output out_backprop, long[] strides, long[] rates, string padding, String opName = "Dilation2DBackpropFilter") 
        {
            OperationDescription desc = NewOperation("Dilation2DBackpropFilter", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.AddInput(out_backprop);
            desc.SetAttr("strides", strides);
            desc.SetAttr("rates", rates);
            desc.SetAttr("padding", padding);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Dilation2DBackpropInput
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="out_backprop">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="rates">rates</param>
        /// <param name="padding">padding</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] in_backprop(type: DtInvalid).
        /// </returns>
        public Operation Dilation2DBackpropInput(Output input, Output filter, Output out_backprop, long[] strides, long[] rates, string padding, String opName = "Dilation2DBackpropInput") 
        {
            OperationDescription desc = NewOperation("Dilation2DBackpropInput", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.AddInput(out_backprop);
            desc.SetAttr("strides", strides);
            desc.SetAttr("rates", rates);
            desc.SetAttr("padding", padding);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DirectedInterleaveDataset
        /// </summary>
        /// <param name="selector_input_dataset">Input to the operation. </param>
        /// <param name="data_input_datasets">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="stop_on_empty_dataset">stop on empty dataset</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation DirectedInterleaveDataset(Output selector_input_dataset, Output data_input_datasets, DataType[] output_types, long[][] output_shapes, bool stop_on_empty_dataset = false, String opName = "DirectedInterleaveDataset") 
        {
            OperationDescription desc = NewOperation("DirectedInterleaveDataset", opName);
            desc.AddInput(selector_input_dataset);
            desc.AddInput(data_input_datasets);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (stop_on_empty_dataset != false)
                desc.SetAttr("stop_on_empty_dataset", stop_on_empty_dataset);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DisableCopyOnRead
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation DisableCopyOnRead(Output resource, String opName = "DisableCopyOnRead") 
        {
            OperationDescription desc = NewOperation("DisableCopyOnRead", opName);
            desc.AddInput(resource);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DistributedSave
        /// </summary>
        /// <param name="dataset">Input to the operation. </param>
        /// <param name="directory">Input to the operation. </param>
        /// <param name="address">Input to the operation. </param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation DistributedSave(Output dataset, Output directory, Output address, string metadata = null, String opName = "DistributedSave") 
        {
            OperationDescription desc = NewOperation("DistributedSave", opName);
            desc.AddInput(dataset);
            desc.AddInput(directory);
            desc.AddInput(address);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Div
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation Div(Output x, Output y, String opName = "Div") 
        {
            OperationDescription desc = NewOperation("Div", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DivNoNan
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation DivNoNan(Output x, Output y, String opName = "DivNoNan") 
        {
            OperationDescription desc = NewOperation("DivNoNan", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DrawBoundingBoxes
        /// </summary>
        /// <param name="images">Input to the operation. </param>
        /// <param name="boxes">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation DrawBoundingBoxes(Output images, Output boxes, String opName = "DrawBoundingBoxes") 
        {
            OperationDescription desc = NewOperation("DrawBoundingBoxes", opName);
            desc.AddInput(images);
            desc.AddInput(boxes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DrawBoundingBoxesV2
        /// </summary>
        /// <param name="images">Input to the operation. </param>
        /// <param name="boxes">Input to the operation. </param>
        /// <param name="colors">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation DrawBoundingBoxesV2(Output images, Output boxes, Output colors, String opName = "DrawBoundingBoxesV2") 
        {
            OperationDescription desc = NewOperation("DrawBoundingBoxesV2", opName);
            desc.AddInput(images);
            desc.AddInput(boxes);
            desc.AddInput(colors);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DTensorRestoreV2
        /// </summary>
        /// <param name="prefix">Input to the operation. </param>
        /// <param name="tensor_names">Input to the operation. </param>
        /// <param name="shape_and_slices">Input to the operation. </param>
        /// <param name="input_shapes">input shapes</param>
        /// <param name="input_layouts">input layouts</param>
        /// <param name="dtypes">dtypes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] tensors(type: DtInvalid).
        /// </returns>
        public Operation DTensorRestoreV2(Output prefix, Output tensor_names, Output shape_and_slices, long[][] input_shapes, string[] input_layouts, DataType[] dtypes, String opName = "DTensorRestoreV2") 
        {
            OperationDescription desc = NewOperation("DTensorRestoreV2", opName);
            desc.AddInput(prefix);
            desc.AddInput(tensor_names);
            desc.AddInput(shape_and_slices);
            desc.SetAttrShapeList("input_shapes", input_shapes);
            desc.SetAttr("input_layouts", input_layouts);
            desc.SetAttr("dtypes", dtypes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DTensorSetGlobalTPUArray
        /// </summary>
        /// <param name="topology">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation DTensorSetGlobalTPUArray(Output topology, String opName = "DTensorSetGlobalTPUArray") 
        {
            OperationDescription desc = NewOperation("DTensorSetGlobalTPUArray", opName);
            desc.AddInput(topology);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DummyIterationCounter
        /// </summary>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// </returns>
        public Operation DummyIterationCounter(String opName = "DummyIterationCounter") 
        {
            OperationDescription desc = NewOperation("DummyIterationCounter", opName);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DummyMemoryCache
        /// </summary>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// </returns>
        public Operation DummyMemoryCache(String opName = "DummyMemoryCache") 
        {
            OperationDescription desc = NewOperation("DummyMemoryCache", opName);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DummySeedGenerator
        /// </summary>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// </returns>
        public Operation DummySeedGenerator(String opName = "DummySeedGenerator") 
        {
            OperationDescription desc = NewOperation("DummySeedGenerator", opName);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DynamicEnqueueTPUEmbeddingArbitraryTensorBatch
        /// </summary>
        /// <param name="sample_indices_or_row_splits">Input to the operation. </param>
        /// <param name="embedding_indices">Input to the operation. </param>
        /// <param name="aggregation_weights">Input to the operation. </param>
        /// <param name="mode_override">Input to the operation. </param>
        /// <param name="device_ordinal">Input to the operation. </param>
        /// <param name="combiners">combiners</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation DynamicEnqueueTPUEmbeddingArbitraryTensorBatch(Output sample_indices_or_row_splits, Output embedding_indices, Output aggregation_weights, Output mode_override, Output device_ordinal, string[] combiners = null, String opName = "DynamicEnqueueTPUEmbeddingArbitraryTensorBatch") 
        {
            OperationDescription desc = NewOperation("DynamicEnqueueTPUEmbeddingArbitraryTensorBatch", opName);
            desc.AddInput(sample_indices_or_row_splits);
            desc.AddInput(embedding_indices);
            desc.AddInput(aggregation_weights);
            desc.AddInput(mode_override);
            desc.AddInput(device_ordinal);
            if (combiners != null) desc.SetAttr("combiners", combiners);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DynamicEnqueueTPUEmbeddingRaggedTensorBatch
        /// </summary>
        /// <param name="sample_splits">Input to the operation. </param>
        /// <param name="embedding_indices">Input to the operation. </param>
        /// <param name="aggregation_weights">Input to the operation. </param>
        /// <param name="mode_override">Input to the operation. </param>
        /// <param name="device_ordinal">Input to the operation. </param>
        /// <param name="table_ids">table ids</param>
        /// <param name="combiners">combiners</param>
        /// <param name="max_sequence_lengths">max sequence lengths</param>
        /// <param name="num_features">num features</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation DynamicEnqueueTPUEmbeddingRaggedTensorBatch(Output sample_splits, Output embedding_indices, Output aggregation_weights, Output mode_override, Output device_ordinal, long[] table_ids, string[] combiners = null, long[] max_sequence_lengths = null, long[] num_features = null, String opName = "DynamicEnqueueTPUEmbeddingRaggedTensorBatch") 
        {
            OperationDescription desc = NewOperation("DynamicEnqueueTPUEmbeddingRaggedTensorBatch", opName);
            desc.AddInput(sample_splits);
            desc.AddInput(embedding_indices);
            desc.AddInput(aggregation_weights);
            desc.AddInput(mode_override);
            desc.AddInput(device_ordinal);
            desc.SetAttr("table_ids", table_ids);
            if (combiners != null) desc.SetAttr("combiners", combiners);
            if (max_sequence_lengths != null) desc.SetAttr("max_sequence_lengths", max_sequence_lengths);
            if (num_features != null) desc.SetAttr("num_features", num_features);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DynamicPartition
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="partitions">Input to the operation. </param>
        /// <param name="num_partitions">num partitions</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] outputs(type: DtInvalid).
        /// </returns>
        public Operation DynamicPartition(Output data, Output partitions, long num_partitions, String opName = "DynamicPartition") 
        {
            OperationDescription desc = NewOperation("DynamicPartition", opName);
            desc.AddInput(data);
            desc.AddInput(partitions);
            desc.SetAttr("num_partitions", num_partitions);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// DynamicStitch
        /// </summary>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="data">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] merged(type: DtInvalid).
        /// </returns>
        public Operation DynamicStitch(Output indices, Output data, String opName = "DynamicStitch") 
        {
            OperationDescription desc = NewOperation("DynamicStitch", opName);
            desc.AddInput(indices);
            desc.AddInput(data);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// EagerPyFunc
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="token">token</param>
        /// <param name="Tout">Tout</param>
        /// <param name="is_async">is async</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation EagerPyFunc(Output input, string token, DataType[] Tout, bool is_async = false, String opName = "EagerPyFunc") 
        {
            OperationDescription desc = NewOperation("EagerPyFunc", opName);
            desc.AddInput(input);
            desc.SetAttr("token", token);
            desc.SetAttr("Tout", Tout);
            if (is_async != false)
                desc.SetAttr("is_async", is_async);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// EditDistance
        /// </summary>
        /// <param name="hypothesis_indices">Input to the operation. </param>
        /// <param name="hypothesis_values">Input to the operation. </param>
        /// <param name="hypothesis_shape">Input to the operation. </param>
        /// <param name="truth_indices">Input to the operation. </param>
        /// <param name="truth_values">Input to the operation. </param>
        /// <param name="truth_shape">Input to the operation. </param>
        /// <param name="normalize">normalize</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtFloat).
        /// </returns>
        public Operation EditDistance(Output hypothesis_indices, Output hypothesis_values, Output hypothesis_shape, Output truth_indices, Output truth_values, Output truth_shape, bool normalize = true, String opName = "EditDistance") 
        {
            OperationDescription desc = NewOperation("EditDistance", opName);
            desc.AddInput(hypothesis_indices);
            desc.AddInput(hypothesis_values);
            desc.AddInput(hypothesis_shape);
            desc.AddInput(truth_indices);
            desc.AddInput(truth_values);
            desc.AddInput(truth_shape);
            if (normalize != true)
                desc.SetAttr("normalize", normalize);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Eig
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="Tout">Tout</param>
        /// <param name="compute_v">compute v</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] e(type: DtInvalid).
        /// [1] v(type: DtInvalid).
        /// </returns>
        public Operation Eig(Output input, DataType Tout, bool compute_v = true, String opName = "Eig") 
        {
            OperationDescription desc = NewOperation("Eig", opName);
            desc.AddInput(input);
            desc.SetAttr("Tout", Tout);
            if (compute_v != true)
                desc.SetAttr("compute_v", compute_v);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Einsum
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="equation">equation</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Einsum(Output inputs, string equation, String opName = "Einsum") 
        {
            OperationDescription desc = NewOperation("Einsum", opName);
            desc.AddInput(inputs);
            desc.SetAttr("equation", equation);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Elu
        /// </summary>
        /// <param name="features">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] activations(type: DtInvalid).
        /// </returns>
        public Operation Elu(Output features, String opName = "Elu") 
        {
            OperationDescription desc = NewOperation("Elu", opName);
            desc.AddInput(features);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// EluGrad
        /// </summary>
        /// <param name="gradients">Input to the operation. </param>
        /// <param name="outputs">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] backprops(type: DtInvalid).
        /// </returns>
        public Operation EluGrad(Output gradients, Output outputs, String opName = "EluGrad") 
        {
            OperationDescription desc = NewOperation("EluGrad", opName);
            desc.AddInput(gradients);
            desc.AddInput(outputs);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Empty
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="init">init</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Empty(Output shape, DataType dtype, bool init = false, String opName = "Empty") 
        {
            OperationDescription desc = NewOperation("Empty", opName);
            desc.AddInput(shape);
            desc.SetAttr("dtype", dtype);
            if (init != false)
                desc.SetAttr("init", init);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// EmptyTensorList
        /// </summary>
        /// <param name="element_shape">Input to the operation. </param>
        /// <param name="max_num_elements">Input to the operation. </param>
        /// <param name="element_dtype">element dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation EmptyTensorList(Output element_shape, Output max_num_elements, DataType element_dtype, String opName = "EmptyTensorList") 
        {
            OperationDescription desc = NewOperation("EmptyTensorList", opName);
            desc.AddInput(element_shape);
            desc.AddInput(max_num_elements);
            desc.SetAttr("element_dtype", element_dtype);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// EmptyTensorMap
        /// </summary>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation EmptyTensorMap(String opName = "EmptyTensorMap") 
        {
            OperationDescription desc = NewOperation("EmptyTensorMap", opName);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// EncodeBase64
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="pad">pad</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtString).
        /// </returns>
        public Operation EncodeBase64(Output input, bool pad = false, String opName = "EncodeBase64") 
        {
            OperationDescription desc = NewOperation("EncodeBase64", opName);
            desc.AddInput(input);
            if (pad != false)
                desc.SetAttr("pad", pad);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// EncodeJpeg
        /// </summary>
        /// <param name="image">Input to the operation. </param>
        /// <param name="format">format</param>
        /// <param name="quality">quality</param>
        /// <param name="progressive">progressive</param>
        /// <param name="optimize_size">optimize size</param>
        /// <param name="chroma_downsampling">chroma downsampling</param>
        /// <param name="density_unit">density unit</param>
        /// <param name="x_density">x density</param>
        /// <param name="y_density">y density</param>
        /// <param name="xmp_metadata">xmp metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] contents(type: DtString).
        /// </returns>
        public Operation EncodeJpeg(Output image, string format = null, long quality = 95, bool progressive = false, bool optimize_size = false, bool chroma_downsampling = true, string density_unit = null, long x_density = 300, long y_density = 300, string xmp_metadata = null, String opName = "EncodeJpeg") 
        {
            OperationDescription desc = NewOperation("EncodeJpeg", opName);
            desc.AddInput(image);
            if (format != null)
                 desc.SetAttr("format", format);
            if (quality != 95)
                desc.SetAttr("quality", quality);
            if (progressive != false)
                desc.SetAttr("progressive", progressive);
            if (optimize_size != false)
                desc.SetAttr("optimize_size", optimize_size);
            if (chroma_downsampling != true)
                desc.SetAttr("chroma_downsampling", chroma_downsampling);
            if (density_unit != null)
                 desc.SetAttr("density_unit", density_unit);
            if (x_density != 300)
                desc.SetAttr("x_density", x_density);
            if (y_density != 300)
                desc.SetAttr("y_density", y_density);
            if (xmp_metadata != null)
                 desc.SetAttr("xmp_metadata", xmp_metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// EncodeJpegVariableQuality
        /// </summary>
        /// <param name="images">Input to the operation. </param>
        /// <param name="quality">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] contents(type: DtString).
        /// </returns>
        public Operation EncodeJpegVariableQuality(Output images, Output quality, String opName = "EncodeJpegVariableQuality") 
        {
            OperationDescription desc = NewOperation("EncodeJpegVariableQuality", opName);
            desc.AddInput(images);
            desc.AddInput(quality);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// EncodePng
        /// </summary>
        /// <param name="image">Input to the operation. </param>
        /// <param name="compression">compression</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] contents(type: DtString).
        /// </returns>
        public Operation EncodePng(Output image, long compression = -1, String opName = "EncodePng") 
        {
            OperationDescription desc = NewOperation("EncodePng", opName);
            desc.AddInput(image);
            if (compression != -1)
                desc.SetAttr("compression", compression);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// EncodeProto
        /// </summary>
        /// <param name="sizes">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="field_names">field names</param>
        /// <param name="message_type">message type</param>
        /// <param name="descriptor_source">descriptor source</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] bytes(type: DtString).
        /// </returns>
        public Operation EncodeProto(Output sizes, Output values, string[] field_names, string message_type, string descriptor_source = null, String opName = "EncodeProto") 
        {
            OperationDescription desc = NewOperation("EncodeProto", opName);
            desc.AddInput(sizes);
            desc.AddInput(values);
            desc.SetAttr("field_names", field_names);
            desc.SetAttr("message_type", message_type);
            if (descriptor_source != null)
                 desc.SetAttr("descriptor_source", descriptor_source);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// EncodeWav
        /// </summary>
        /// <param name="audio">Input to the operation. </param>
        /// <param name="sample_rate">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] contents(type: DtString).
        /// </returns>
        public Operation EncodeWav(Output audio, Output sample_rate, String opName = "EncodeWav") 
        {
            OperationDescription desc = NewOperation("EncodeWav", opName);
            desc.AddInput(audio);
            desc.AddInput(sample_rate);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// EnqueueTPUEmbeddingArbitraryTensorBatch
        /// </summary>
        /// <param name="sample_indices_or_row_splits">Input to the operation. </param>
        /// <param name="embedding_indices">Input to the operation. </param>
        /// <param name="aggregation_weights">Input to the operation. </param>
        /// <param name="mode_override">Input to the operation. </param>
        /// <param name="device_ordinal">device ordinal</param>
        /// <param name="combiners">combiners</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation EnqueueTPUEmbeddingArbitraryTensorBatch(Output sample_indices_or_row_splits, Output embedding_indices, Output aggregation_weights, Output mode_override, long device_ordinal = -1, string[] combiners = null, String opName = "EnqueueTPUEmbeddingArbitraryTensorBatch") 
        {
            OperationDescription desc = NewOperation("EnqueueTPUEmbeddingArbitraryTensorBatch", opName);
            desc.AddInput(sample_indices_or_row_splits);
            desc.AddInput(embedding_indices);
            desc.AddInput(aggregation_weights);
            desc.AddInput(mode_override);
            if (device_ordinal != -1)
                desc.SetAttr("device_ordinal", device_ordinal);
            if (combiners != null) desc.SetAttr("combiners", combiners);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// EnqueueTPUEmbeddingBatch
        /// </summary>
        /// <param name="batch">Input to the operation. </param>
        /// <param name="mode_override">Input to the operation. </param>
        /// <param name="device_ordinal">device ordinal</param>
        /// <param name="combiners">combiners</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation EnqueueTPUEmbeddingBatch(Output batch, Output mode_override, long device_ordinal = -1, string[] combiners = null, String opName = "EnqueueTPUEmbeddingBatch") 
        {
            OperationDescription desc = NewOperation("EnqueueTPUEmbeddingBatch", opName);
            desc.AddInput(batch);
            desc.AddInput(mode_override);
            if (device_ordinal != -1)
                desc.SetAttr("device_ordinal", device_ordinal);
            if (combiners != null) desc.SetAttr("combiners", combiners);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// EnqueueTPUEmbeddingIntegerBatch
        /// </summary>
        /// <param name="batch">Input to the operation. </param>
        /// <param name="mode_override">Input to the operation. </param>
        /// <param name="device_ordinal">device ordinal</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation EnqueueTPUEmbeddingIntegerBatch(Output batch, Output mode_override, long device_ordinal = -1, String opName = "EnqueueTPUEmbeddingIntegerBatch") 
        {
            OperationDescription desc = NewOperation("EnqueueTPUEmbeddingIntegerBatch", opName);
            desc.AddInput(batch);
            desc.AddInput(mode_override);
            if (device_ordinal != -1)
                desc.SetAttr("device_ordinal", device_ordinal);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// EnqueueTPUEmbeddingRaggedTensorBatch
        /// </summary>
        /// <param name="sample_splits">Input to the operation. </param>
        /// <param name="embedding_indices">Input to the operation. </param>
        /// <param name="aggregation_weights">Input to the operation. </param>
        /// <param name="mode_override">Input to the operation. </param>
        /// <param name="table_ids">table ids</param>
        /// <param name="device_ordinal">device ordinal</param>
        /// <param name="combiners">combiners</param>
        /// <param name="max_sequence_lengths">max sequence lengths</param>
        /// <param name="num_features">num features</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation EnqueueTPUEmbeddingRaggedTensorBatch(Output sample_splits, Output embedding_indices, Output aggregation_weights, Output mode_override, long[] table_ids, long device_ordinal = -1, string[] combiners = null, long[] max_sequence_lengths = null, long[] num_features = null, String opName = "EnqueueTPUEmbeddingRaggedTensorBatch") 
        {
            OperationDescription desc = NewOperation("EnqueueTPUEmbeddingRaggedTensorBatch", opName);
            desc.AddInput(sample_splits);
            desc.AddInput(embedding_indices);
            desc.AddInput(aggregation_weights);
            desc.AddInput(mode_override);
            desc.SetAttr("table_ids", table_ids);
            if (device_ordinal != -1)
                desc.SetAttr("device_ordinal", device_ordinal);
            if (combiners != null) desc.SetAttr("combiners", combiners);
            if (max_sequence_lengths != null) desc.SetAttr("max_sequence_lengths", max_sequence_lengths);
            if (num_features != null) desc.SetAttr("num_features", num_features);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// EnqueueTPUEmbeddingSparseBatch
        /// </summary>
        /// <param name="sample_indices">Input to the operation. </param>
        /// <param name="embedding_indices">Input to the operation. </param>
        /// <param name="aggregation_weights">Input to the operation. </param>
        /// <param name="mode_override">Input to the operation. </param>
        /// <param name="device_ordinal">device ordinal</param>
        /// <param name="combiners">combiners</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation EnqueueTPUEmbeddingSparseBatch(Output sample_indices, Output embedding_indices, Output aggregation_weights, Output mode_override, long device_ordinal = -1, string[] combiners = null, String opName = "EnqueueTPUEmbeddingSparseBatch") 
        {
            OperationDescription desc = NewOperation("EnqueueTPUEmbeddingSparseBatch", opName);
            desc.AddInput(sample_indices);
            desc.AddInput(embedding_indices);
            desc.AddInput(aggregation_weights);
            desc.AddInput(mode_override);
            if (device_ordinal != -1)
                desc.SetAttr("device_ordinal", device_ordinal);
            if (combiners != null) desc.SetAttr("combiners", combiners);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// EnqueueTPUEmbeddingSparseTensorBatch
        /// </summary>
        /// <param name="sample_indices">Input to the operation. </param>
        /// <param name="embedding_indices">Input to the operation. </param>
        /// <param name="aggregation_weights">Input to the operation. </param>
        /// <param name="mode_override">Input to the operation. </param>
        /// <param name="table_ids">table ids</param>
        /// <param name="device_ordinal">device ordinal</param>
        /// <param name="combiners">combiners</param>
        /// <param name="max_sequence_lengths">max sequence lengths</param>
        /// <param name="num_features">num features</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation EnqueueTPUEmbeddingSparseTensorBatch(Output sample_indices, Output embedding_indices, Output aggregation_weights, Output mode_override, long[] table_ids, long device_ordinal = -1, string[] combiners = null, long[] max_sequence_lengths = null, long[] num_features = null, String opName = "EnqueueTPUEmbeddingSparseTensorBatch") 
        {
            OperationDescription desc = NewOperation("EnqueueTPUEmbeddingSparseTensorBatch", opName);
            desc.AddInput(sample_indices);
            desc.AddInput(embedding_indices);
            desc.AddInput(aggregation_weights);
            desc.AddInput(mode_override);
            desc.SetAttr("table_ids", table_ids);
            if (device_ordinal != -1)
                desc.SetAttr("device_ordinal", device_ordinal);
            if (combiners != null) desc.SetAttr("combiners", combiners);
            if (max_sequence_lengths != null) desc.SetAttr("max_sequence_lengths", max_sequence_lengths);
            if (num_features != null) desc.SetAttr("num_features", num_features);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// EnsureShape
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="shape">shape</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation EnsureShape(Output input, long[] shape, String opName = "EnsureShape") 
        {
            OperationDescription desc = NewOperation("EnsureShape", opName);
            desc.AddInput(input);
            desc.SetAttrShape("shape", shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Enter
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="frame_name">frame name</param>
        /// <param name="is_constant">is constant</param>
        /// <param name="parallel_iterations">parallel iterations</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Enter(Output data, string frame_name, bool is_constant = false, long parallel_iterations = 10, String opName = "Enter") 
        {
            OperationDescription desc = NewOperation("Enter", opName);
            desc.AddInput(data);
            desc.SetAttr("frame_name", frame_name);
            if (is_constant != false)
                desc.SetAttr("is_constant", is_constant);
            if (parallel_iterations != 10)
                desc.SetAttr("parallel_iterations", parallel_iterations);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Equal
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="incompatible_shape_error">incompatible shape error</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtBool).
        /// </returns>
        public Operation Equal(Output x, Output y, bool incompatible_shape_error = true, String opName = "Equal") 
        {
            OperationDescription desc = NewOperation("Equal", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            if (incompatible_shape_error != true)
                desc.SetAttr("incompatible_shape_error", incompatible_shape_error);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Erf
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Erf(Output x, String opName = "Erf") 
        {
            OperationDescription desc = NewOperation("Erf", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Erfc
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Erfc(Output x, String opName = "Erfc") 
        {
            OperationDescription desc = NewOperation("Erfc", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Erfinv
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Erfinv(Output x, String opName = "Erfinv") 
        {
            OperationDescription desc = NewOperation("Erfinv", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// EuclideanNorm
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="reduction_indices">Input to the operation. </param>
        /// <param name="keep_dims">keep dims</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation EuclideanNorm(Output input, Output reduction_indices, bool keep_dims = false, String opName = "EuclideanNorm") 
        {
            OperationDescription desc = NewOperation("EuclideanNorm", opName);
            desc.AddInput(input);
            desc.AddInput(reduction_indices);
            if (keep_dims != false)
                desc.SetAttr("keep_dims", keep_dims);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExecuteTPUEmbeddingPartitioner
        /// </summary>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] common_config(type: DtString).
        /// </returns>
        public Operation ExecuteTPUEmbeddingPartitioner(string config, String opName = "ExecuteTPUEmbeddingPartitioner") 
        {
            OperationDescription desc = NewOperation("ExecuteTPUEmbeddingPartitioner", opName);
            desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Exit
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Exit(Output data, String opName = "Exit") 
        {
            OperationDescription desc = NewOperation("Exit", opName);
            desc.AddInput(data);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Exp
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Exp(Output x, String opName = "Exp") 
        {
            OperationDescription desc = NewOperation("Exp", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExpandDims
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="dim">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation ExpandDims(Output input, Output dim, String opName = "ExpandDims") 
        {
            OperationDescription desc = NewOperation("ExpandDims", opName);
            desc.AddInput(input);
            desc.AddInput(dim);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalAssertNextDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="transformations">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ExperimentalAssertNextDataset(Output input_dataset, Output transformations, DataType[] output_types, long[][] output_shapes, String opName = "ExperimentalAssertNextDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalAssertNextDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(transformations);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalAutoShardDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="num_workers">Input to the operation. </param>
        /// <param name="index">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="auto_shard_policy">auto shard policy</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ExperimentalAutoShardDataset(Output input_dataset, Output num_workers, Output index, DataType[] output_types, long[][] output_shapes, long auto_shard_policy = 0, String opName = "ExperimentalAutoShardDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalAutoShardDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(num_workers);
            desc.AddInput(index);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (auto_shard_policy != 0)
                desc.SetAttr("auto_shard_policy", auto_shard_policy);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalBytesProducedStatsDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="tag">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ExperimentalBytesProducedStatsDataset(Output input_dataset, Output tag, DataType[] output_types, long[][] output_shapes, String opName = "ExperimentalBytesProducedStatsDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalBytesProducedStatsDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(tag);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalChooseFastestDataset
        /// </summary>
        /// <param name="input_datasets">Input to the operation. </param>
        /// <param name="num_experiments">num experiments</param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ExperimentalChooseFastestDataset(Output input_datasets, long num_experiments, DataType[] output_types, long[][] output_shapes, String opName = "ExperimentalChooseFastestDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalChooseFastestDataset", opName);
            desc.AddInput(input_datasets);
            desc.SetAttr("num_experiments", num_experiments);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalCSVDataset
        /// </summary>
        /// <param name="filenames">Input to the operation. </param>
        /// <param name="compression_type">Input to the operation. </param>
        /// <param name="buffer_size">Input to the operation. </param>
        /// <param name="header">Input to the operation. </param>
        /// <param name="field_delim">Input to the operation. </param>
        /// <param name="use_quote_delim">Input to the operation. </param>
        /// <param name="na_value">Input to the operation. </param>
        /// <param name="select_cols">Input to the operation. </param>
        /// <param name="record_defaults">Input to the operation. </param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ExperimentalCSVDataset(Output filenames, Output compression_type, Output buffer_size, Output header, Output field_delim, Output use_quote_delim, Output na_value, Output select_cols, Output record_defaults, long[][] output_shapes, String opName = "ExperimentalCSVDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalCSVDataset", opName);
            desc.AddInput(filenames);
            desc.AddInput(compression_type);
            desc.AddInput(buffer_size);
            desc.AddInput(header);
            desc.AddInput(field_delim);
            desc.AddInput(use_quote_delim);
            desc.AddInput(na_value);
            desc.AddInput(select_cols);
            desc.AddInput(record_defaults);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalDatasetCardinality
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] cardinality(type: DtInt64).
        /// </returns>
        public Operation ExperimentalDatasetCardinality(Output input_dataset, String opName = "ExperimentalDatasetCardinality") 
        {
            OperationDescription desc = NewOperation("ExperimentalDatasetCardinality", opName);
            desc.AddInput(input_dataset);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalDatasetToTFRecord
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="filename">Input to the operation. </param>
        /// <param name="compression_type">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ExperimentalDatasetToTFRecord(Output input_dataset, Output filename, Output compression_type, String opName = "ExperimentalDatasetToTFRecord") 
        {
            OperationDescription desc = NewOperation("ExperimentalDatasetToTFRecord", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(filename);
            desc.AddInput(compression_type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalDenseToSparseBatchDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="batch_size">Input to the operation. </param>
        /// <param name="row_shape">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ExperimentalDenseToSparseBatchDataset(Output input_dataset, Output batch_size, Output row_shape, DataType[] output_types, long[][] output_shapes, String opName = "ExperimentalDenseToSparseBatchDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalDenseToSparseBatchDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(batch_size);
            desc.AddInput(row_shape);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalDirectedInterleaveDataset
        /// </summary>
        /// <param name="selector_input_dataset">Input to the operation. </param>
        /// <param name="data_input_datasets">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ExperimentalDirectedInterleaveDataset(Output selector_input_dataset, Output data_input_datasets, DataType[] output_types, long[][] output_shapes, String opName = "ExperimentalDirectedInterleaveDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalDirectedInterleaveDataset", opName);
            desc.AddInput(selector_input_dataset);
            desc.AddInput(data_input_datasets);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalGroupByReducerDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="key_func_other_arguments">Input to the operation. </param>
        /// <param name="init_func_other_arguments">Input to the operation. </param>
        /// <param name="reduce_func_other_arguments">Input to the operation. </param>
        /// <param name="finalize_func_other_arguments">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: key_func: func; init_func: func; reduce_func: func; finalize_func: func
        public Operation ExperimentalGroupByReducerDataset(Output input_dataset, Output key_func_other_arguments, Output init_func_other_arguments, Output reduce_func_other_arguments, Output finalize_func_other_arguments, DataType[] output_types, long[][] output_shapes, String opName = "ExperimentalGroupByReducerDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalGroupByReducerDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(key_func_other_arguments);
            desc.AddInput(init_func_other_arguments);
            desc.AddInput(reduce_func_other_arguments);
            desc.AddInput(finalize_func_other_arguments);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalGroupByWindowDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="key_func_other_arguments">Input to the operation. </param>
        /// <param name="reduce_func_other_arguments">Input to the operation. </param>
        /// <param name="window_size_func_other_arguments">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: key_func: func; reduce_func: func; window_size_func: func
        public Operation ExperimentalGroupByWindowDataset(Output input_dataset, Output key_func_other_arguments, Output reduce_func_other_arguments, Output window_size_func_other_arguments, DataType[] output_types, long[][] output_shapes, String opName = "ExperimentalGroupByWindowDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalGroupByWindowDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(key_func_other_arguments);
            desc.AddInput(reduce_func_other_arguments);
            desc.AddInput(window_size_func_other_arguments);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalIgnoreErrorsDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="log_warning">log warning</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ExperimentalIgnoreErrorsDataset(Output input_dataset, DataType[] output_types, long[][] output_shapes, bool log_warning = false, String opName = "ExperimentalIgnoreErrorsDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalIgnoreErrorsDataset", opName);
            desc.AddInput(input_dataset);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (log_warning != false)
                desc.SetAttr("log_warning", log_warning);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalIteratorGetDevice
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] device(type: DtString).
        /// </returns>
        public Operation ExperimentalIteratorGetDevice(Output resource, String opName = "ExperimentalIteratorGetDevice") 
        {
            OperationDescription desc = NewOperation("ExperimentalIteratorGetDevice", opName);
            desc.AddInput(resource);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalLatencyStatsDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="tag">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ExperimentalLatencyStatsDataset(Output input_dataset, Output tag, DataType[] output_types, long[][] output_shapes, String opName = "ExperimentalLatencyStatsDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalLatencyStatsDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(tag);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalLMDBDataset
        /// </summary>
        /// <param name="filenames">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ExperimentalLMDBDataset(Output filenames, DataType[] output_types, long[][] output_shapes, String opName = "ExperimentalLMDBDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalLMDBDataset", opName);
            desc.AddInput(filenames);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalMapAndBatchDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="other_arguments">Input to the operation. </param>
        /// <param name="batch_size">Input to the operation. </param>
        /// <param name="num_parallel_calls">Input to the operation. </param>
        /// <param name="drop_remainder">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="preserve_cardinality">preserve cardinality</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: f: func
        public Operation ExperimentalMapAndBatchDataset(Output input_dataset, Output other_arguments, Output batch_size, Output num_parallel_calls, Output drop_remainder, DataType[] output_types, long[][] output_shapes, bool preserve_cardinality = false, String opName = "ExperimentalMapAndBatchDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalMapAndBatchDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(other_arguments);
            desc.AddInput(batch_size);
            desc.AddInput(num_parallel_calls);
            desc.AddInput(drop_remainder);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (preserve_cardinality != false)
                desc.SetAttr("preserve_cardinality", preserve_cardinality);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalMapDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="other_arguments">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="use_inter_op_parallelism">use inter op parallelism</param>
        /// <param name="preserve_cardinality">preserve cardinality</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: f: func
        public Operation ExperimentalMapDataset(Output input_dataset, Output other_arguments, DataType[] output_types, long[][] output_shapes, bool use_inter_op_parallelism = true, bool preserve_cardinality = false, String opName = "ExperimentalMapDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalMapDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(other_arguments);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (use_inter_op_parallelism != true)
                desc.SetAttr("use_inter_op_parallelism", use_inter_op_parallelism);
            if (preserve_cardinality != false)
                desc.SetAttr("preserve_cardinality", preserve_cardinality);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalMatchingFilesDataset
        /// </summary>
        /// <param name="patterns">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ExperimentalMatchingFilesDataset(Output patterns, String opName = "ExperimentalMatchingFilesDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalMatchingFilesDataset", opName);
            desc.AddInput(patterns);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalMaxIntraOpParallelismDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="max_intra_op_parallelism">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ExperimentalMaxIntraOpParallelismDataset(Output input_dataset, Output max_intra_op_parallelism, DataType[] output_types, long[][] output_shapes, String opName = "ExperimentalMaxIntraOpParallelismDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalMaxIntraOpParallelismDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(max_intra_op_parallelism);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalNonSerializableDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ExperimentalNonSerializableDataset(Output input_dataset, DataType[] output_types, long[][] output_shapes, String opName = "ExperimentalNonSerializableDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalNonSerializableDataset", opName);
            desc.AddInput(input_dataset);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalParallelInterleaveDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="other_arguments">Input to the operation. </param>
        /// <param name="cycle_length">Input to the operation. </param>
        /// <param name="block_length">Input to the operation. </param>
        /// <param name="sloppy">Input to the operation. </param>
        /// <param name="buffer_output_elements">Input to the operation. </param>
        /// <param name="prefetch_input_elements">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: f: func
        public Operation ExperimentalParallelInterleaveDataset(Output input_dataset, Output other_arguments, Output cycle_length, Output block_length, Output sloppy, Output buffer_output_elements, Output prefetch_input_elements, DataType[] output_types, long[][] output_shapes, String opName = "ExperimentalParallelInterleaveDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalParallelInterleaveDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(other_arguments);
            desc.AddInput(cycle_length);
            desc.AddInput(block_length);
            desc.AddInput(sloppy);
            desc.AddInput(buffer_output_elements);
            desc.AddInput(prefetch_input_elements);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalParseExampleDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="num_parallel_calls">Input to the operation. </param>
        /// <param name="dense_defaults">Input to the operation. </param>
        /// <param name="sparse_keys">sparse keys</param>
        /// <param name="dense_keys">dense keys</param>
        /// <param name="sparse_types">sparse types</param>
        /// <param name="dense_shapes">dense shapes</param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="sloppy">sloppy</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ExperimentalParseExampleDataset(Output input_dataset, Output num_parallel_calls, Output dense_defaults, string[] sparse_keys, string[] dense_keys, DataType[] sparse_types, long[][] dense_shapes, DataType[] output_types, long[][] output_shapes, bool sloppy = false, String opName = "ExperimentalParseExampleDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalParseExampleDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(num_parallel_calls);
            desc.AddInput(dense_defaults);
            desc.SetAttr("sparse_keys", sparse_keys);
            desc.SetAttr("dense_keys", dense_keys);
            desc.SetAttr("sparse_types", sparse_types);
            desc.SetAttrShapeList("dense_shapes", dense_shapes);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (sloppy != false)
                desc.SetAttr("sloppy", sloppy);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalPrivateThreadPoolDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="num_threads">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ExperimentalPrivateThreadPoolDataset(Output input_dataset, Output num_threads, DataType[] output_types, long[][] output_shapes, String opName = "ExperimentalPrivateThreadPoolDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalPrivateThreadPoolDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(num_threads);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalRandomDataset
        /// </summary>
        /// <param name="seed">Input to the operation. </param>
        /// <param name="seed2">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ExperimentalRandomDataset(Output seed, Output seed2, DataType[] output_types, long[][] output_shapes, String opName = "ExperimentalRandomDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalRandomDataset", opName);
            desc.AddInput(seed);
            desc.AddInput(seed2);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalRebatchDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="num_replicas">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="use_fallback">use fallback</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ExperimentalRebatchDataset(Output input_dataset, Output num_replicas, DataType[] output_types, long[][] output_shapes, bool use_fallback = true, String opName = "ExperimentalRebatchDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalRebatchDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(num_replicas);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (use_fallback != true)
                desc.SetAttr("use_fallback", use_fallback);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalScanDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="initial_state">Input to the operation. </param>
        /// <param name="other_arguments">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="preserve_cardinality">preserve cardinality</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: f: func
        public Operation ExperimentalScanDataset(Output input_dataset, Output initial_state, Output other_arguments, DataType[] output_types, long[][] output_shapes, bool preserve_cardinality = false, String opName = "ExperimentalScanDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalScanDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(initial_state);
            desc.AddInput(other_arguments);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (preserve_cardinality != false)
                desc.SetAttr("preserve_cardinality", preserve_cardinality);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalSetStatsAggregatorDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="stats_aggregator">Input to the operation. </param>
        /// <param name="tag">Input to the operation. </param>
        /// <param name="counter_prefix">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ExperimentalSetStatsAggregatorDataset(Output input_dataset, Output stats_aggregator, Output tag, Output counter_prefix, DataType[] output_types, long[][] output_shapes, String opName = "ExperimentalSetStatsAggregatorDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalSetStatsAggregatorDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(stats_aggregator);
            desc.AddInput(tag);
            desc.AddInput(counter_prefix);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalSleepDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="sleep_microseconds">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ExperimentalSleepDataset(Output input_dataset, Output sleep_microseconds, DataType[] output_types, long[][] output_shapes, String opName = "ExperimentalSleepDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalSleepDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(sleep_microseconds);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalSlidingWindowDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="window_size">Input to the operation. </param>
        /// <param name="window_shift">Input to the operation. </param>
        /// <param name="window_stride">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ExperimentalSlidingWindowDataset(Output input_dataset, Output window_size, Output window_shift, Output window_stride, DataType[] output_types, long[][] output_shapes, String opName = "ExperimentalSlidingWindowDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalSlidingWindowDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(window_size);
            desc.AddInput(window_shift);
            desc.AddInput(window_stride);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalSqlDataset
        /// </summary>
        /// <param name="driver_name">Input to the operation. </param>
        /// <param name="data_source_name">Input to the operation. </param>
        /// <param name="query">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ExperimentalSqlDataset(Output driver_name, Output data_source_name, Output query, DataType[] output_types, long[][] output_shapes, String opName = "ExperimentalSqlDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalSqlDataset", opName);
            desc.AddInput(driver_name);
            desc.AddInput(data_source_name);
            desc.AddInput(query);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalStatsAggregatorHandle
        /// </summary>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// </returns>
        public Operation ExperimentalStatsAggregatorHandle(string container = null, string shared_name = null, String opName = "ExperimentalStatsAggregatorHandle") 
        {
            OperationDescription desc = NewOperation("ExperimentalStatsAggregatorHandle", opName);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalStatsAggregatorSummary
        /// </summary>
        /// <param name="iterator">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] summary(type: DtString).
        /// </returns>
        public Operation ExperimentalStatsAggregatorSummary(Output iterator, String opName = "ExperimentalStatsAggregatorSummary") 
        {
            OperationDescription desc = NewOperation("ExperimentalStatsAggregatorSummary", opName);
            desc.AddInput(iterator);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalTakeWhileDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="other_arguments">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: predicate: func
        public Operation ExperimentalTakeWhileDataset(Output input_dataset, Output other_arguments, DataType[] output_types, long[][] output_shapes, String opName = "ExperimentalTakeWhileDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalTakeWhileDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(other_arguments);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalThreadPoolDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="thread_pool">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ExperimentalThreadPoolDataset(Output input_dataset, Output thread_pool, DataType[] output_types, long[][] output_shapes, String opName = "ExperimentalThreadPoolDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalThreadPoolDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(thread_pool);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalThreadPoolHandle
        /// </summary>
        /// <param name="num_threads">num threads</param>
        /// <param name="display_name">display name</param>
        /// <param name="max_intra_op_parallelism">max intra op parallelism</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// </returns>
        public Operation ExperimentalThreadPoolHandle(long num_threads, string display_name, long max_intra_op_parallelism = 1, string container = null, string shared_name = null, String opName = "ExperimentalThreadPoolHandle") 
        {
            OperationDescription desc = NewOperation("ExperimentalThreadPoolHandle", opName);
            desc.SetAttr("num_threads", num_threads);
            desc.SetAttr("display_name", display_name);
            if (max_intra_op_parallelism != 1)
                desc.SetAttr("max_intra_op_parallelism", max_intra_op_parallelism);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalUnbatchDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ExperimentalUnbatchDataset(Output input_dataset, DataType[] output_types, long[][] output_shapes, String opName = "ExperimentalUnbatchDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalUnbatchDataset", opName);
            desc.AddInput(input_dataset);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExperimentalUniqueDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ExperimentalUniqueDataset(Output input_dataset, DataType[] output_types, long[][] output_shapes, String opName = "ExperimentalUniqueDataset") 
        {
            OperationDescription desc = NewOperation("ExperimentalUniqueDataset", opName);
            desc.AddInput(input_dataset);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Expint
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Expint(Output x, String opName = "Expint") 
        {
            OperationDescription desc = NewOperation("Expint", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Expm1
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Expm1(Output x, String opName = "Expm1") 
        {
            OperationDescription desc = NewOperation("Expm1", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExtractGlimpse
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="size">Input to the operation. </param>
        /// <param name="offsets">Input to the operation. </param>
        /// <param name="centered">centered</param>
        /// <param name="normalized">normalized</param>
        /// <param name="uniform_noise">uniform noise</param>
        /// <param name="noise">noise</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] glimpse(type: DtFloat).
        /// </returns>
        public Operation ExtractGlimpse(Output input, Output size, Output offsets, bool centered = true, bool normalized = true, bool uniform_noise = true, string noise = null, String opName = "ExtractGlimpse") 
        {
            OperationDescription desc = NewOperation("ExtractGlimpse", opName);
            desc.AddInput(input);
            desc.AddInput(size);
            desc.AddInput(offsets);
            if (centered != true)
                desc.SetAttr("centered", centered);
            if (normalized != true)
                desc.SetAttr("normalized", normalized);
            if (uniform_noise != true)
                desc.SetAttr("uniform_noise", uniform_noise);
            if (noise != null)
                 desc.SetAttr("noise", noise);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExtractGlimpseV2
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="size">Input to the operation. </param>
        /// <param name="offsets">Input to the operation. </param>
        /// <param name="centered">centered</param>
        /// <param name="normalized">normalized</param>
        /// <param name="uniform_noise">uniform noise</param>
        /// <param name="noise">noise</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] glimpse(type: DtFloat).
        /// </returns>
        public Operation ExtractGlimpseV2(Output input, Output size, Output offsets, bool centered = true, bool normalized = true, bool uniform_noise = true, string noise = null, String opName = "ExtractGlimpseV2") 
        {
            OperationDescription desc = NewOperation("ExtractGlimpseV2", opName);
            desc.AddInput(input);
            desc.AddInput(size);
            desc.AddInput(offsets);
            if (centered != true)
                desc.SetAttr("centered", centered);
            if (normalized != true)
                desc.SetAttr("normalized", normalized);
            if (uniform_noise != true)
                desc.SetAttr("uniform_noise", uniform_noise);
            if (noise != null)
                 desc.SetAttr("noise", noise);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExtractImagePatches
        /// </summary>
        /// <param name="images">Input to the operation. </param>
        /// <param name="ksizes">ksizes</param>
        /// <param name="strides">strides</param>
        /// <param name="rates">rates</param>
        /// <param name="padding">padding</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] patches(type: DtInvalid).
        /// </returns>
        public Operation ExtractImagePatches(Output images, long[] ksizes, long[] strides, long[] rates, string padding, String opName = "ExtractImagePatches") 
        {
            OperationDescription desc = NewOperation("ExtractImagePatches", opName);
            desc.AddInput(images);
            desc.SetAttr("ksizes", ksizes);
            desc.SetAttr("strides", strides);
            desc.SetAttr("rates", rates);
            desc.SetAttr("padding", padding);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExtractJpegShape
        /// </summary>
        /// <param name="contents">Input to the operation. </param>
        /// <param name="output_type">output type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] image_shape(type: DtInvalid).
        /// </returns>
        public Operation ExtractJpegShape(Output contents, DataType? output_type = null, String opName = "ExtractJpegShape") 
        {
            OperationDescription desc = NewOperation("ExtractJpegShape", opName);
            desc.AddInput(contents);
            if (output_type.HasValue)
                desc.SetAttr("output_type", output_type.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ExtractVolumePatches
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="ksizes">ksizes</param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] patches(type: DtInvalid).
        /// </returns>
        public Operation ExtractVolumePatches(Output input, long[] ksizes, long[] strides, string padding, String opName = "ExtractVolumePatches") 
        {
            OperationDescription desc = NewOperation("ExtractVolumePatches", opName);
            desc.AddInput(input);
            desc.SetAttr("ksizes", ksizes);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Fact
        /// </summary>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] fact(type: DtString).
        /// </returns>
        public Operation Fact(String opName = "Fact") 
        {
            OperationDescription desc = NewOperation("Fact", opName);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FakeParam
        /// </summary>
        /// <param name="dtype">dtype</param>
        /// <param name="shape">shape</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation FakeParam(DataType dtype, long[] shape, String opName = "FakeParam") 
        {
            OperationDescription desc = NewOperation("FakeParam", opName);
            desc.SetAttr("dtype", dtype);
            desc.SetAttrShape("shape", shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FakeQuantWithMinMaxArgs
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="min">min</param>
        /// <param name="max">max</param>
        /// <param name="num_bits">num bits</param>
        /// <param name="narrow_range">narrow range</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] outputs(type: DtFloat).
        /// </returns>
        public Operation FakeQuantWithMinMaxArgs(Output inputs, float min = -6f, float max = 6f, long num_bits = 8, bool narrow_range = false, String opName = "FakeQuantWithMinMaxArgs") 
        {
            OperationDescription desc = NewOperation("FakeQuantWithMinMaxArgs", opName);
            desc.AddInput(inputs);
            if (min != -6f)
                desc.SetAttr("min", min);
            if (max != 6f)
                desc.SetAttr("max", max);
            if (num_bits != 8)
                desc.SetAttr("num_bits", num_bits);
            if (narrow_range != false)
                desc.SetAttr("narrow_range", narrow_range);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FakeQuantWithMinMaxArgsGradient
        /// </summary>
        /// <param name="gradients">Input to the operation. </param>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="min">min</param>
        /// <param name="max">max</param>
        /// <param name="num_bits">num bits</param>
        /// <param name="narrow_range">narrow range</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] backprops(type: DtFloat).
        /// </returns>
        public Operation FakeQuantWithMinMaxArgsGradient(Output gradients, Output inputs, float min = -6f, float max = 6f, long num_bits = 8, bool narrow_range = false, String opName = "FakeQuantWithMinMaxArgsGradient") 
        {
            OperationDescription desc = NewOperation("FakeQuantWithMinMaxArgsGradient", opName);
            desc.AddInput(gradients);
            desc.AddInput(inputs);
            if (min != -6f)
                desc.SetAttr("min", min);
            if (max != 6f)
                desc.SetAttr("max", max);
            if (num_bits != 8)
                desc.SetAttr("num_bits", num_bits);
            if (narrow_range != false)
                desc.SetAttr("narrow_range", narrow_range);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FakeQuantWithMinMaxVars
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="min">Input to the operation. </param>
        /// <param name="max">Input to the operation. </param>
        /// <param name="num_bits">num bits</param>
        /// <param name="narrow_range">narrow range</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] outputs(type: DtFloat).
        /// </returns>
        public Operation FakeQuantWithMinMaxVars(Output inputs, Output min, Output max, long num_bits = 8, bool narrow_range = false, String opName = "FakeQuantWithMinMaxVars") 
        {
            OperationDescription desc = NewOperation("FakeQuantWithMinMaxVars", opName);
            desc.AddInput(inputs);
            desc.AddInput(min);
            desc.AddInput(max);
            if (num_bits != 8)
                desc.SetAttr("num_bits", num_bits);
            if (narrow_range != false)
                desc.SetAttr("narrow_range", narrow_range);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FakeQuantWithMinMaxVarsGradient
        /// </summary>
        /// <param name="gradients">Input to the operation. </param>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="min">Input to the operation. </param>
        /// <param name="max">Input to the operation. </param>
        /// <param name="num_bits">num bits</param>
        /// <param name="narrow_range">narrow range</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] backprops_wrt_input(type: DtFloat).
        /// [1] backprop_wrt_min(type: DtFloat).
        /// [2] backprop_wrt_max(type: DtFloat).
        /// </returns>
        public Operation FakeQuantWithMinMaxVarsGradient(Output gradients, Output inputs, Output min, Output max, long num_bits = 8, bool narrow_range = false, String opName = "FakeQuantWithMinMaxVarsGradient") 
        {
            OperationDescription desc = NewOperation("FakeQuantWithMinMaxVarsGradient", opName);
            desc.AddInput(gradients);
            desc.AddInput(inputs);
            desc.AddInput(min);
            desc.AddInput(max);
            if (num_bits != 8)
                desc.SetAttr("num_bits", num_bits);
            if (narrow_range != false)
                desc.SetAttr("narrow_range", narrow_range);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FakeQuantWithMinMaxVarsPerChannel
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="min">Input to the operation. </param>
        /// <param name="max">Input to the operation. </param>
        /// <param name="num_bits">num bits</param>
        /// <param name="narrow_range">narrow range</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] outputs(type: DtFloat).
        /// </returns>
        public Operation FakeQuantWithMinMaxVarsPerChannel(Output inputs, Output min, Output max, long num_bits = 8, bool narrow_range = false, String opName = "FakeQuantWithMinMaxVarsPerChannel") 
        {
            OperationDescription desc = NewOperation("FakeQuantWithMinMaxVarsPerChannel", opName);
            desc.AddInput(inputs);
            desc.AddInput(min);
            desc.AddInput(max);
            if (num_bits != 8)
                desc.SetAttr("num_bits", num_bits);
            if (narrow_range != false)
                desc.SetAttr("narrow_range", narrow_range);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FakeQuantWithMinMaxVarsPerChannelGradient
        /// </summary>
        /// <param name="gradients">Input to the operation. </param>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="min">Input to the operation. </param>
        /// <param name="max">Input to the operation. </param>
        /// <param name="num_bits">num bits</param>
        /// <param name="narrow_range">narrow range</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] backprops_wrt_input(type: DtFloat).
        /// [1] backprop_wrt_min(type: DtFloat).
        /// [2] backprop_wrt_max(type: DtFloat).
        /// </returns>
        public Operation FakeQuantWithMinMaxVarsPerChannelGradient(Output gradients, Output inputs, Output min, Output max, long num_bits = 8, bool narrow_range = false, String opName = "FakeQuantWithMinMaxVarsPerChannelGradient") 
        {
            OperationDescription desc = NewOperation("FakeQuantWithMinMaxVarsPerChannelGradient", opName);
            desc.AddInput(gradients);
            desc.AddInput(inputs);
            desc.AddInput(min);
            desc.AddInput(max);
            if (num_bits != 8)
                desc.SetAttr("num_bits", num_bits);
            if (narrow_range != false)
                desc.SetAttr("narrow_range", narrow_range);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FakeQueue
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtString).
        /// </returns>
        public Operation FakeQueue(Output resource, String opName = "FakeQueue") 
        {
            OperationDescription desc = NewOperation("FakeQueue", opName);
            desc.AddInput(resource);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FFT
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation FFT(Output input, String opName = "FFT") 
        {
            OperationDescription desc = NewOperation("FFT", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FFT2D
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation FFT2D(Output input, String opName = "FFT2D") 
        {
            OperationDescription desc = NewOperation("FFT2D", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FFT3D
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation FFT3D(Output input, String opName = "FFT3D") 
        {
            OperationDescription desc = NewOperation("FFT3D", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FFTND
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="fft_length">Input to the operation. </param>
        /// <param name="axes">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation FFTND(Output input, Output fft_length, Output axes, String opName = "FFTND") 
        {
            OperationDescription desc = NewOperation("FFTND", opName);
            desc.AddInput(input);
            desc.AddInput(fft_length);
            desc.AddInput(axes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FIFOQueue
        /// </summary>
        /// <param name="component_types">component types</param>
        /// <param name="shapes">shapes</param>
        /// <param name="capacity">capacity</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtString).
        /// </returns>
        public Operation FIFOQueue(DataType[] component_types, long[][] shapes = null, long capacity = -1, string container = null, string shared_name = null, String opName = "FIFOQueue") 
        {
            OperationDescription desc = NewOperation("FIFOQueue", opName);
            desc.SetAttr("component_types", component_types);
            if (shapes != null) desc.SetAttrShapeList("shapes", shapes);
            if (capacity != -1)
                desc.SetAttr("capacity", capacity);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FIFOQueueV2
        /// </summary>
        /// <param name="component_types">component types</param>
        /// <param name="shapes">shapes</param>
        /// <param name="capacity">capacity</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// </returns>
        public Operation FIFOQueueV2(DataType[] component_types, long[][] shapes = null, long capacity = -1, string container = null, string shared_name = null, String opName = "FIFOQueueV2") 
        {
            OperationDescription desc = NewOperation("FIFOQueueV2", opName);
            desc.SetAttr("component_types", component_types);
            if (shapes != null) desc.SetAttrShapeList("shapes", shapes);
            if (capacity != -1)
                desc.SetAttr("capacity", capacity);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FileSystemSetConfiguration
        /// </summary>
        /// <param name="scheme">Input to the operation. </param>
        /// <param name="key">Input to the operation. </param>
        /// <param name="value">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation FileSystemSetConfiguration(Output scheme, Output key, Output value, String opName = "FileSystemSetConfiguration") 
        {
            OperationDescription desc = NewOperation("FileSystemSetConfiguration", opName);
            desc.AddInput(scheme);
            desc.AddInput(key);
            desc.AddInput(value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Fill
        /// </summary>
        /// <param name="dims">Input to the operation. </param>
        /// <param name="value">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Fill(Output dims, Output value, String opName = "Fill") 
        {
            OperationDescription desc = NewOperation("Fill", opName);
            desc.AddInput(dims);
            desc.AddInput(value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FilterByLastComponentDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtVariant).
        /// </returns>
        public Operation FilterByLastComponentDataset(Output input_dataset, DataType[] output_types, long[][] output_shapes, String opName = "FilterByLastComponentDataset") 
        {
            OperationDescription desc = NewOperation("FilterByLastComponentDataset", opName);
            desc.AddInput(input_dataset);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FilterDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="other_arguments">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: predicate: func
        public Operation FilterDataset(Output input_dataset, Output other_arguments, DataType[] output_types, long[][] output_shapes, string metadata = null, String opName = "FilterDataset") 
        {
            OperationDescription desc = NewOperation("FilterDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(other_arguments);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FinalizeDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="has_captured_ref">has captured ref</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation FinalizeDataset(Output input_dataset, DataType[] output_types, long[][] output_shapes, bool has_captured_ref = false, String opName = "FinalizeDataset") 
        {
            OperationDescription desc = NewOperation("FinalizeDataset", opName);
            desc.AddInput(input_dataset);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (has_captured_ref != false)
                desc.SetAttr("has_captured_ref", has_captured_ref);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FinalizeTPUEmbedding
        /// </summary>
        /// <param name="common_config">Input to the operation. </param>
        /// <param name="memory_config">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation FinalizeTPUEmbedding(Output common_config, Output memory_config, String opName = "FinalizeTPUEmbedding") 
        {
            OperationDescription desc = NewOperation("FinalizeTPUEmbedding", opName);
            desc.AddInput(common_config);
            desc.AddInput(memory_config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FinalizeTPUEmbeddingV2
        /// </summary>
        /// <param name="common_config">Input to the operation. </param>
        /// <param name="memory_config">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] embedding_partitions(type: DtString).
        /// [1] hbm_buffers_config(type: DtString).
        /// </returns>
        public Operation FinalizeTPUEmbeddingV2(Output common_config, Output memory_config, String opName = "FinalizeTPUEmbeddingV2") 
        {
            OperationDescription desc = NewOperation("FinalizeTPUEmbeddingV2", opName);
            desc.AddInput(common_config);
            desc.AddInput(memory_config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Fingerprint
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="method">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] fingerprint(type: DtUint8).
        /// </returns>
        public Operation Fingerprint(Output data, Output method, String opName = "Fingerprint") 
        {
            OperationDescription desc = NewOperation("Fingerprint", opName);
            desc.AddInput(data);
            desc.AddInput(method);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FixedLengthRecordDataset
        /// </summary>
        /// <param name="filenames">Input to the operation. </param>
        /// <param name="header_bytes">Input to the operation. </param>
        /// <param name="record_bytes">Input to the operation. </param>
        /// <param name="footer_bytes">Input to the operation. </param>
        /// <param name="buffer_size">Input to the operation. </param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation FixedLengthRecordDataset(Output filenames, Output header_bytes, Output record_bytes, Output footer_bytes, Output buffer_size, string metadata = null, String opName = "FixedLengthRecordDataset") 
        {
            OperationDescription desc = NewOperation("FixedLengthRecordDataset", opName);
            desc.AddInput(filenames);
            desc.AddInput(header_bytes);
            desc.AddInput(record_bytes);
            desc.AddInput(footer_bytes);
            desc.AddInput(buffer_size);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FixedLengthRecordDatasetV2
        /// </summary>
        /// <param name="filenames">Input to the operation. </param>
        /// <param name="header_bytes">Input to the operation. </param>
        /// <param name="record_bytes">Input to the operation. </param>
        /// <param name="footer_bytes">Input to the operation. </param>
        /// <param name="buffer_size">Input to the operation. </param>
        /// <param name="compression_type">Input to the operation. </param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation FixedLengthRecordDatasetV2(Output filenames, Output header_bytes, Output record_bytes, Output footer_bytes, Output buffer_size, Output compression_type, string metadata = null, String opName = "FixedLengthRecordDatasetV2") 
        {
            OperationDescription desc = NewOperation("FixedLengthRecordDatasetV2", opName);
            desc.AddInput(filenames);
            desc.AddInput(header_bytes);
            desc.AddInput(record_bytes);
            desc.AddInput(footer_bytes);
            desc.AddInput(buffer_size);
            desc.AddInput(compression_type);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FixedLengthRecordReader
        /// </summary>
        /// <param name="record_bytes">record bytes</param>
        /// <param name="header_bytes">header bytes</param>
        /// <param name="footer_bytes">footer bytes</param>
        /// <param name="hop_bytes">hop bytes</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] reader_handle(type: DtString).
        /// </returns>
        public Operation FixedLengthRecordReader(long record_bytes, long header_bytes = 0, long footer_bytes = 0, long hop_bytes = 0, string container = null, string shared_name = null, String opName = "FixedLengthRecordReader") 
        {
            OperationDescription desc = NewOperation("FixedLengthRecordReader", opName);
            desc.SetAttr("record_bytes", record_bytes);
            if (header_bytes != 0)
                desc.SetAttr("header_bytes", header_bytes);
            if (footer_bytes != 0)
                desc.SetAttr("footer_bytes", footer_bytes);
            if (hop_bytes != 0)
                desc.SetAttr("hop_bytes", hop_bytes);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FixedLengthRecordReaderV2
        /// </summary>
        /// <param name="record_bytes">record bytes</param>
        /// <param name="header_bytes">header bytes</param>
        /// <param name="footer_bytes">footer bytes</param>
        /// <param name="hop_bytes">hop bytes</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="encoding">encoding</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] reader_handle(type: DtResource).
        /// </returns>
        public Operation FixedLengthRecordReaderV2(long record_bytes, long header_bytes = 0, long footer_bytes = 0, long hop_bytes = 0, string container = null, string shared_name = null, string encoding = null, String opName = "FixedLengthRecordReaderV2") 
        {
            OperationDescription desc = NewOperation("FixedLengthRecordReaderV2", opName);
            desc.SetAttr("record_bytes", record_bytes);
            if (header_bytes != 0)
                desc.SetAttr("header_bytes", header_bytes);
            if (footer_bytes != 0)
                desc.SetAttr("footer_bytes", footer_bytes);
            if (hop_bytes != 0)
                desc.SetAttr("hop_bytes", hop_bytes);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            if (encoding != null)
                 desc.SetAttr("encoding", encoding);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FixedUnigramCandidateSampler
        /// </summary>
        /// <param name="true_classes">Input to the operation. </param>
        /// <param name="num_true">num true</param>
        /// <param name="num_sampled">num sampled</param>
        /// <param name="unique">unique</param>
        /// <param name="range_max">range max</param>
        /// <param name="vocab_file">vocab file</param>
        /// <param name="distortion">distortion</param>
        /// <param name="num_reserved_ids">num reserved ids</param>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard">shard</param>
        /// <param name="unigrams">unigrams</param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] sampled_candidates(type: DtInt64).
        /// [1] true_expected_count(type: DtFloat).
        /// [2] sampled_expected_count(type: DtFloat).
        /// </returns>
        public Operation FixedUnigramCandidateSampler(Output true_classes, long num_true, long num_sampled, bool unique, long range_max, string vocab_file = null, float distortion = 1f, long num_reserved_ids = 0, long num_shards = 1, long shard = 0, float[] unigrams = null, long seed = 0, long seed2 = 0, String opName = "FixedUnigramCandidateSampler") 
        {
            OperationDescription desc = NewOperation("FixedUnigramCandidateSampler", opName);
            desc.AddInput(true_classes);
            desc.SetAttr("num_true", num_true);
            desc.SetAttr("num_sampled", num_sampled);
            desc.SetAttr("unique", unique);
            desc.SetAttr("range_max", range_max);
            if (vocab_file != null)
                 desc.SetAttr("vocab_file", vocab_file);
            if (distortion != 1f)
                desc.SetAttr("distortion", distortion);
            if (num_reserved_ids != 0)
                desc.SetAttr("num_reserved_ids", num_reserved_ids);
            if (num_shards != 1)
                desc.SetAttr("num_shards", num_shards);
            if (shard != 0)
                desc.SetAttr("shard", shard);
            if (unigrams != null) desc.SetAttr("unigrams", unigrams);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FlatMapDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="other_arguments">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: f: func
        public Operation FlatMapDataset(Output input_dataset, Output other_arguments, DataType[] output_types, long[][] output_shapes, string metadata = null, String opName = "FlatMapDataset") 
        {
            OperationDescription desc = NewOperation("FlatMapDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(other_arguments);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Floor
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Floor(Output x, String opName = "Floor") 
        {
            OperationDescription desc = NewOperation("Floor", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FloorDiv
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation FloorDiv(Output x, Output y, String opName = "FloorDiv") 
        {
            OperationDescription desc = NewOperation("FloorDiv", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FloorMod
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation FloorMod(Output x, Output y, String opName = "FloorMod") 
        {
            OperationDescription desc = NewOperation("FloorMod", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FlushSummaryWriter
        /// </summary>
        /// <param name="writer">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation FlushSummaryWriter(Output writer, String opName = "FlushSummaryWriter") 
        {
            OperationDescription desc = NewOperation("FlushSummaryWriter", opName);
            desc.AddInput(writer);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// For
        /// </summary>
        /// <param name="start">Input to the operation. </param>
        /// <param name="limit">Input to the operation. </param>
        /// <param name="delta">Input to the operation. </param>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        // The following attributes are not known: body: func
        public Operation For(Output start, Output limit, Output delta, Output input, String opName = "For") 
        {
            OperationDescription desc = NewOperation("For", opName);
            desc.AddInput(start);
            desc.AddInput(limit);
            desc.AddInput(delta);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FractionalAvgPool
        /// </summary>
        /// <param name="value">Input to the operation. </param>
        /// <param name="pooling_ratio">pooling ratio</param>
        /// <param name="pseudo_random">pseudo random</param>
        /// <param name="overlapping">overlapping</param>
        /// <param name="deterministic">deterministic</param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] row_pooling_sequence(type: DtInt64).
        /// [2] col_pooling_sequence(type: DtInt64).
        /// </returns>
        public Operation FractionalAvgPool(Output value, float[] pooling_ratio, bool pseudo_random = false, bool overlapping = false, bool deterministic = false, long seed = 0, long seed2 = 0, String opName = "FractionalAvgPool") 
        {
            OperationDescription desc = NewOperation("FractionalAvgPool", opName);
            desc.AddInput(value);
            desc.SetAttr("pooling_ratio", pooling_ratio);
            if (pseudo_random != false)
                desc.SetAttr("pseudo_random", pseudo_random);
            if (overlapping != false)
                desc.SetAttr("overlapping", overlapping);
            if (deterministic != false)
                desc.SetAttr("deterministic", deterministic);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FractionalAvgPoolGrad
        /// </summary>
        /// <param name="orig_input_tensor_shape">Input to the operation. </param>
        /// <param name="out_backprop">Input to the operation. </param>
        /// <param name="row_pooling_sequence">Input to the operation. </param>
        /// <param name="col_pooling_sequence">Input to the operation. </param>
        /// <param name="overlapping">overlapping</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation FractionalAvgPoolGrad(Output orig_input_tensor_shape, Output out_backprop, Output row_pooling_sequence, Output col_pooling_sequence, bool overlapping = false, String opName = "FractionalAvgPoolGrad") 
        {
            OperationDescription desc = NewOperation("FractionalAvgPoolGrad", opName);
            desc.AddInput(orig_input_tensor_shape);
            desc.AddInput(out_backprop);
            desc.AddInput(row_pooling_sequence);
            desc.AddInput(col_pooling_sequence);
            if (overlapping != false)
                desc.SetAttr("overlapping", overlapping);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FractionalMaxPool
        /// </summary>
        /// <param name="value">Input to the operation. </param>
        /// <param name="pooling_ratio">pooling ratio</param>
        /// <param name="pseudo_random">pseudo random</param>
        /// <param name="overlapping">overlapping</param>
        /// <param name="deterministic">deterministic</param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] row_pooling_sequence(type: DtInt64).
        /// [2] col_pooling_sequence(type: DtInt64).
        /// </returns>
        public Operation FractionalMaxPool(Output value, float[] pooling_ratio, bool pseudo_random = false, bool overlapping = false, bool deterministic = false, long seed = 0, long seed2 = 0, String opName = "FractionalMaxPool") 
        {
            OperationDescription desc = NewOperation("FractionalMaxPool", opName);
            desc.AddInput(value);
            desc.SetAttr("pooling_ratio", pooling_ratio);
            if (pseudo_random != false)
                desc.SetAttr("pseudo_random", pseudo_random);
            if (overlapping != false)
                desc.SetAttr("overlapping", overlapping);
            if (deterministic != false)
                desc.SetAttr("deterministic", deterministic);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FractionalMaxPoolGrad
        /// </summary>
        /// <param name="orig_input">Input to the operation. </param>
        /// <param name="orig_output">Input to the operation. </param>
        /// <param name="out_backprop">Input to the operation. </param>
        /// <param name="row_pooling_sequence">Input to the operation. </param>
        /// <param name="col_pooling_sequence">Input to the operation. </param>
        /// <param name="overlapping">overlapping</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation FractionalMaxPoolGrad(Output orig_input, Output orig_output, Output out_backprop, Output row_pooling_sequence, Output col_pooling_sequence, bool overlapping = false, String opName = "FractionalMaxPoolGrad") 
        {
            OperationDescription desc = NewOperation("FractionalMaxPoolGrad", opName);
            desc.AddInput(orig_input);
            desc.AddInput(orig_output);
            desc.AddInput(out_backprop);
            desc.AddInput(row_pooling_sequence);
            desc.AddInput(col_pooling_sequence);
            if (overlapping != false)
                desc.SetAttr("overlapping", overlapping);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FresnelCos
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation FresnelCos(Output x, String opName = "FresnelCos") 
        {
            OperationDescription desc = NewOperation("FresnelCos", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FresnelSin
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation FresnelSin(Output x, String opName = "FresnelSin") 
        {
            OperationDescription desc = NewOperation("FresnelSin", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FusedBatchNorm
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="scale">Input to the operation. </param>
        /// <param name="offset">Input to the operation. </param>
        /// <param name="mean">Input to the operation. </param>
        /// <param name="variance">Input to the operation. </param>
        /// <param name="epsilon">epsilon</param>
        /// <param name="exponential_avg_factor">exponential avg factor</param>
        /// <param name="data_format">data format</param>
        /// <param name="is_training">is training</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// [1] batch_mean(type: DtInvalid).
        /// [2] batch_variance(type: DtInvalid).
        /// [3] reserve_space_1(type: DtInvalid).
        /// [4] reserve_space_2(type: DtInvalid).
        /// </returns>
        public Operation FusedBatchNorm(Output x, Output scale, Output offset, Output mean, Output variance, float epsilon = 0.0001f, float exponential_avg_factor = 1f, string data_format = null, bool is_training = true, String opName = "FusedBatchNorm") 
        {
            OperationDescription desc = NewOperation("FusedBatchNorm", opName);
            desc.AddInput(x);
            desc.AddInput(scale);
            desc.AddInput(offset);
            desc.AddInput(mean);
            desc.AddInput(variance);
            if (epsilon != 0.0001f)
                desc.SetAttr("epsilon", epsilon);
            if (exponential_avg_factor != 1f)
                desc.SetAttr("exponential_avg_factor", exponential_avg_factor);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            if (is_training != true)
                desc.SetAttr("is_training", is_training);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FusedBatchNormGrad
        /// </summary>
        /// <param name="y_backprop">Input to the operation. </param>
        /// <param name="x">Input to the operation. </param>
        /// <param name="scale">Input to the operation. </param>
        /// <param name="reserve_space_1">Input to the operation. </param>
        /// <param name="reserve_space_2">Input to the operation. </param>
        /// <param name="epsilon">epsilon</param>
        /// <param name="data_format">data format</param>
        /// <param name="is_training">is training</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] x_backprop(type: DtInvalid).
        /// [1] scale_backprop(type: DtInvalid).
        /// [2] offset_backprop(type: DtInvalid).
        /// [3] reserve_space_3(type: DtInvalid).
        /// [4] reserve_space_4(type: DtInvalid).
        /// </returns>
        public Operation FusedBatchNormGrad(Output y_backprop, Output x, Output scale, Output reserve_space_1, Output reserve_space_2, float epsilon = 0.0001f, string data_format = null, bool is_training = true, String opName = "FusedBatchNormGrad") 
        {
            OperationDescription desc = NewOperation("FusedBatchNormGrad", opName);
            desc.AddInput(y_backprop);
            desc.AddInput(x);
            desc.AddInput(scale);
            desc.AddInput(reserve_space_1);
            desc.AddInput(reserve_space_2);
            if (epsilon != 0.0001f)
                desc.SetAttr("epsilon", epsilon);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            if (is_training != true)
                desc.SetAttr("is_training", is_training);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FusedBatchNormGradV2
        /// </summary>
        /// <param name="y_backprop">Input to the operation. </param>
        /// <param name="x">Input to the operation. </param>
        /// <param name="scale">Input to the operation. </param>
        /// <param name="reserve_space_1">Input to the operation. </param>
        /// <param name="reserve_space_2">Input to the operation. </param>
        /// <param name="epsilon">epsilon</param>
        /// <param name="data_format">data format</param>
        /// <param name="is_training">is training</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] x_backprop(type: DtInvalid).
        /// [1] scale_backprop(type: DtInvalid).
        /// [2] offset_backprop(type: DtInvalid).
        /// [3] reserve_space_3(type: DtInvalid).
        /// [4] reserve_space_4(type: DtInvalid).
        /// </returns>
        public Operation FusedBatchNormGradV2(Output y_backprop, Output x, Output scale, Output reserve_space_1, Output reserve_space_2, float epsilon = 0.0001f, string data_format = null, bool is_training = true, String opName = "FusedBatchNormGradV2") 
        {
            OperationDescription desc = NewOperation("FusedBatchNormGradV2", opName);
            desc.AddInput(y_backprop);
            desc.AddInput(x);
            desc.AddInput(scale);
            desc.AddInput(reserve_space_1);
            desc.AddInput(reserve_space_2);
            if (epsilon != 0.0001f)
                desc.SetAttr("epsilon", epsilon);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            if (is_training != true)
                desc.SetAttr("is_training", is_training);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FusedBatchNormGradV3
        /// </summary>
        /// <param name="y_backprop">Input to the operation. </param>
        /// <param name="x">Input to the operation. </param>
        /// <param name="scale">Input to the operation. </param>
        /// <param name="reserve_space_1">Input to the operation. </param>
        /// <param name="reserve_space_2">Input to the operation. </param>
        /// <param name="reserve_space_3">Input to the operation. </param>
        /// <param name="epsilon">epsilon</param>
        /// <param name="data_format">data format</param>
        /// <param name="is_training">is training</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] x_backprop(type: DtInvalid).
        /// [1] scale_backprop(type: DtInvalid).
        /// [2] offset_backprop(type: DtInvalid).
        /// [3] reserve_space_4(type: DtInvalid).
        /// [4] reserve_space_5(type: DtInvalid).
        /// </returns>
        public Operation FusedBatchNormGradV3(Output y_backprop, Output x, Output scale, Output reserve_space_1, Output reserve_space_2, Output reserve_space_3, float epsilon = 0.0001f, string data_format = null, bool is_training = true, String opName = "FusedBatchNormGradV3") 
        {
            OperationDescription desc = NewOperation("FusedBatchNormGradV3", opName);
            desc.AddInput(y_backprop);
            desc.AddInput(x);
            desc.AddInput(scale);
            desc.AddInput(reserve_space_1);
            desc.AddInput(reserve_space_2);
            desc.AddInput(reserve_space_3);
            if (epsilon != 0.0001f)
                desc.SetAttr("epsilon", epsilon);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            if (is_training != true)
                desc.SetAttr("is_training", is_training);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FusedBatchNormV2
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="scale">Input to the operation. </param>
        /// <param name="offset">Input to the operation. </param>
        /// <param name="mean">Input to the operation. </param>
        /// <param name="variance">Input to the operation. </param>
        /// <param name="epsilon">epsilon</param>
        /// <param name="exponential_avg_factor">exponential avg factor</param>
        /// <param name="data_format">data format</param>
        /// <param name="is_training">is training</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// [1] batch_mean(type: DtInvalid).
        /// [2] batch_variance(type: DtInvalid).
        /// [3] reserve_space_1(type: DtInvalid).
        /// [4] reserve_space_2(type: DtInvalid).
        /// </returns>
        public Operation FusedBatchNormV2(Output x, Output scale, Output offset, Output mean, Output variance, float epsilon = 0.0001f, float exponential_avg_factor = 1f, string data_format = null, bool is_training = true, String opName = "FusedBatchNormV2") 
        {
            OperationDescription desc = NewOperation("FusedBatchNormV2", opName);
            desc.AddInput(x);
            desc.AddInput(scale);
            desc.AddInput(offset);
            desc.AddInput(mean);
            desc.AddInput(variance);
            if (epsilon != 0.0001f)
                desc.SetAttr("epsilon", epsilon);
            if (exponential_avg_factor != 1f)
                desc.SetAttr("exponential_avg_factor", exponential_avg_factor);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            if (is_training != true)
                desc.SetAttr("is_training", is_training);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FusedBatchNormV3
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="scale">Input to the operation. </param>
        /// <param name="offset">Input to the operation. </param>
        /// <param name="mean">Input to the operation. </param>
        /// <param name="variance">Input to the operation. </param>
        /// <param name="epsilon">epsilon</param>
        /// <param name="exponential_avg_factor">exponential avg factor</param>
        /// <param name="data_format">data format</param>
        /// <param name="is_training">is training</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// [1] batch_mean(type: DtInvalid).
        /// [2] batch_variance(type: DtInvalid).
        /// [3] reserve_space_1(type: DtInvalid).
        /// [4] reserve_space_2(type: DtInvalid).
        /// [5] reserve_space_3(type: DtInvalid).
        /// </returns>
        public Operation FusedBatchNormV3(Output x, Output scale, Output offset, Output mean, Output variance, float epsilon = 0.0001f, float exponential_avg_factor = 1f, string data_format = null, bool is_training = true, String opName = "FusedBatchNormV3") 
        {
            OperationDescription desc = NewOperation("FusedBatchNormV3", opName);
            desc.AddInput(x);
            desc.AddInput(scale);
            desc.AddInput(offset);
            desc.AddInput(mean);
            desc.AddInput(variance);
            if (epsilon != 0.0001f)
                desc.SetAttr("epsilon", epsilon);
            if (exponential_avg_factor != 1f)
                desc.SetAttr("exponential_avg_factor", exponential_avg_factor);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            if (is_training != true)
                desc.SetAttr("is_training", is_training);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FusedPadConv2D
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="paddings">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="mode">mode</param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation FusedPadConv2D(Output input, Output paddings, Output filter, string mode, long[] strides, string padding, String opName = "FusedPadConv2D") 
        {
            OperationDescription desc = NewOperation("FusedPadConv2D", opName);
            desc.AddInput(input);
            desc.AddInput(paddings);
            desc.AddInput(filter);
            desc.SetAttr("mode", mode);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// FusedResizeAndPadConv2D
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="size">Input to the operation. </param>
        /// <param name="paddings">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="mode">mode</param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="resize_align_corners">resize align corners</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation FusedResizeAndPadConv2D(Output input, Output size, Output paddings, Output filter, string mode, long[] strides, string padding, bool resize_align_corners = false, String opName = "FusedResizeAndPadConv2D") 
        {
            OperationDescription desc = NewOperation("FusedResizeAndPadConv2D", opName);
            desc.AddInput(input);
            desc.AddInput(size);
            desc.AddInput(paddings);
            desc.AddInput(filter);
            desc.SetAttr("mode", mode);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (resize_align_corners != false)
                desc.SetAttr("resize_align_corners", resize_align_corners);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Gather
        /// </summary>
        /// <param name="parameters">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="validate_indices">validate indices</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Gather(Output parameters, Output indices, bool validate_indices = true, String opName = "Gather") 
        {
            OperationDescription desc = NewOperation("Gather", opName);
            desc.AddInput(parameters);
            desc.AddInput(indices);
            if (validate_indices != true)
                desc.SetAttr("validate_indices", validate_indices);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// GatherNd
        /// </summary>
        /// <param name="parameters">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="bad_indices_policy">bad indices policy</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation GatherNd(Output parameters, Output indices, string bad_indices_policy = null, String opName = "GatherNd") 
        {
            OperationDescription desc = NewOperation("GatherNd", opName);
            desc.AddInput(parameters);
            desc.AddInput(indices);
            if (bad_indices_policy != null)
                 desc.SetAttr("bad_indices_policy", bad_indices_policy);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// GatherV2
        /// </summary>
        /// <param name="parameters">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="axis">Input to the operation. </param>
        /// <param name="batch_dims">batch dims</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation GatherV2(Output parameters, Output indices, Output axis, long batch_dims = 0, String opName = "GatherV2") 
        {
            OperationDescription desc = NewOperation("GatherV2", opName);
            desc.AddInput(parameters);
            desc.AddInput(indices);
            desc.AddInput(axis);
            if (batch_dims != 0)
                desc.SetAttr("batch_dims", batch_dims);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// GenerateBoundingBoxProposals
        /// </summary>
        /// <param name="scores">Input to the operation. </param>
        /// <param name="bbox_deltas">Input to the operation. </param>
        /// <param name="image_info">Input to the operation. </param>
        /// <param name="anchors">Input to the operation. </param>
        /// <param name="nms_threshold">Input to the operation. </param>
        /// <param name="pre_nms_topn">Input to the operation. </param>
        /// <param name="min_size">Input to the operation. </param>
        /// <param name="post_nms_topn">post nms topn</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] rois(type: DtFloat).
        /// [1] roi_probabilities(type: DtFloat).
        /// </returns>
        public Operation GenerateBoundingBoxProposals(Output scores, Output bbox_deltas, Output image_info, Output anchors, Output nms_threshold, Output pre_nms_topn, Output min_size, long post_nms_topn = 300, String opName = "GenerateBoundingBoxProposals") 
        {
            OperationDescription desc = NewOperation("GenerateBoundingBoxProposals", opName);
            desc.AddInput(scores);
            desc.AddInput(bbox_deltas);
            desc.AddInput(image_info);
            desc.AddInput(anchors);
            desc.AddInput(nms_threshold);
            desc.AddInput(pre_nms_topn);
            desc.AddInput(min_size);
            if (post_nms_topn != 300)
                desc.SetAttr("post_nms_topn", post_nms_topn);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// GenerateVocabRemapping
        /// </summary>
        /// <param name="new_vocab_file">Input to the operation. </param>
        /// <param name="old_vocab_file">Input to the operation. </param>
        /// <param name="new_vocab_offset">new vocab offset</param>
        /// <param name="num_new_vocab">num new vocab</param>
        /// <param name="old_vocab_size">old vocab size</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] remapping(type: DtInt64).
        /// [1] num_present(type: DtInt32).
        /// </returns>
        public Operation GenerateVocabRemapping(Output new_vocab_file, Output old_vocab_file, long new_vocab_offset, long num_new_vocab, long old_vocab_size = -1, String opName = "GenerateVocabRemapping") 
        {
            OperationDescription desc = NewOperation("GenerateVocabRemapping", opName);
            desc.AddInput(new_vocab_file);
            desc.AddInput(old_vocab_file);
            desc.SetAttr("new_vocab_offset", new_vocab_offset);
            desc.SetAttr("num_new_vocab", num_new_vocab);
            if (old_vocab_size != -1)
                desc.SetAttr("old_vocab_size", old_vocab_size);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// GeneratorDataset
        /// </summary>
        /// <param name="init_func_other_args">Input to the operation. </param>
        /// <param name="next_func_other_args">Input to the operation. </param>
        /// <param name="finalize_func_other_args">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: init_func: func; next_func: func; finalize_func: func
        public Operation GeneratorDataset(Output init_func_other_args, Output next_func_other_args, Output finalize_func_other_args, DataType[] output_types, long[][] output_shapes, string metadata = null, String opName = "GeneratorDataset") 
        {
            OperationDescription desc = NewOperation("GeneratorDataset", opName);
            desc.AddInput(init_func_other_args);
            desc.AddInput(next_func_other_args);
            desc.AddInput(finalize_func_other_args);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// GetElementAtIndex
        /// </summary>
        /// <param name="dataset">Input to the operation. </param>
        /// <param name="index">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] components(type: DtInvalid).
        /// </returns>
        public Operation GetElementAtIndex(Output dataset, Output index, DataType[] output_types, long[][] output_shapes, String opName = "GetElementAtIndex") 
        {
            OperationDescription desc = NewOperation("GetElementAtIndex", opName);
            desc.AddInput(dataset);
            desc.AddInput(index);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// GetMinibatchesInCsrWithPhysicalReplica
        /// </summary>
        /// <param name="program_key">Input to the operation. </param>
        /// <param name="row_ids">Input to the operation. </param>
        /// <param name="col_ids">Input to the operation. </param>
        /// <param name="gains">Input to the operation. </param>
        /// <param name="splits">Input to the operation. </param>
        /// <param name="id_counts">Input to the operation. </param>
        /// <param name="sample_count">sample count</param>
        /// <param name="num_replica">num replica</param>
        /// <param name="max_minibatches_per_sc">max minibatches per sc</param>
        /// <param name="max_ids_per_chip_per_sample">max ids per chip per sample</param>
        /// <param name="table_vocab_size">table vocab size</param>
        /// <param name="feature_width">feature width</param>
        /// <param name="num_sc_per_chip">num sc per chip</param>
        /// <param name="table_name">table name</param>
        /// <param name="mini_batch_in_csr">mini batch in csr</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] row_pointers(type: DtInt32).
        /// [1] sorted_sample_ids(type: DtInt32).
        /// [2] sorted_token_ids(type: DtInt32).
        /// [3] sorted_gains(type: DtFloat).
        /// [4] row_pointers_unpadded_size(type: DtInt32).
        /// [5] ids_unpadded_size(type: DtInt32).
        /// [6] num_minibatches_per_physical_sparse_core(type: DtInt32).
        /// </returns>
        public Operation GetMinibatchesInCsrWithPhysicalReplica(Output program_key, Output row_ids, Output col_ids, Output gains, Output splits, Output id_counts, long sample_count, long num_replica, long max_minibatches_per_sc, long max_ids_per_chip_per_sample, long table_vocab_size, long feature_width, long num_sc_per_chip, string table_name, string mini_batch_in_csr, String opName = "GetMinibatchesInCsrWithPhysicalReplica") 
        {
            OperationDescription desc = NewOperation("GetMinibatchesInCsrWithPhysicalReplica", opName);
            desc.AddInput(program_key);
            desc.AddInput(row_ids);
            desc.AddInput(col_ids);
            desc.AddInput(gains);
            desc.AddInput(splits);
            desc.AddInput(id_counts);
            desc.SetAttr("sample_count", sample_count);
            desc.SetAttr("num_replica", num_replica);
            desc.SetAttr("max_minibatches_per_sc", max_minibatches_per_sc);
            desc.SetAttr("max_ids_per_chip_per_sample", max_ids_per_chip_per_sample);
            desc.SetAttr("table_vocab_size", table_vocab_size);
            desc.SetAttr("feature_width", feature_width);
            desc.SetAttr("num_sc_per_chip", num_sc_per_chip);
            desc.SetAttr("table_name", table_name);
            desc.SetAttr("mini_batch_in_csr", mini_batch_in_csr);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// GetMinibatchSplitsWithPhysicalReplica
        /// </summary>
        /// <param name="program_key">Input to the operation. </param>
        /// <param name="row_ids">Input to the operation. </param>
        /// <param name="col_ids">Input to the operation. </param>
        /// <param name="gains">Input to the operation. </param>
        /// <param name="sample_count">sample count</param>
        /// <param name="num_replica">num replica</param>
        /// <param name="table_vocab_size">table vocab size</param>
        /// <param name="feature_width">feature width</param>
        /// <param name="num_sc_per_chip">num sc per chip</param>
        /// <param name="table_name">table name</param>
        /// <param name="mini_batch_splits">mini batch splits</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] sorted_row_ids(type: DtInt32).
        /// [1] sorted_col_ids(type: DtInt32).
        /// [2] sorted_gains(type: DtFloat).
        /// [3] splits(type: DtInt64).
        /// [4] id_counts(type: DtInt32).
        /// [5] max_ids(type: DtInt32).
        /// [6] max_uniques(type: DtInt32).
        /// </returns>
        public Operation GetMinibatchSplitsWithPhysicalReplica(Output program_key, Output row_ids, Output col_ids, Output gains, long sample_count, long num_replica, long table_vocab_size, long feature_width, long num_sc_per_chip, string table_name, string mini_batch_splits, String opName = "GetMinibatchSplitsWithPhysicalReplica") 
        {
            OperationDescription desc = NewOperation("GetMinibatchSplitsWithPhysicalReplica", opName);
            desc.AddInput(program_key);
            desc.AddInput(row_ids);
            desc.AddInput(col_ids);
            desc.AddInput(gains);
            desc.SetAttr("sample_count", sample_count);
            desc.SetAttr("num_replica", num_replica);
            desc.SetAttr("table_vocab_size", table_vocab_size);
            desc.SetAttr("feature_width", feature_width);
            desc.SetAttr("num_sc_per_chip", num_sc_per_chip);
            desc.SetAttr("table_name", table_name);
            desc.SetAttr("mini_batch_splits", mini_batch_splits);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// GetOptions
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] serialized_options(type: DtString).
        /// </returns>
        public Operation GetOptions(Output input_dataset, String opName = "GetOptions") 
        {
            OperationDescription desc = NewOperation("GetOptions", opName);
            desc.AddInput(input_dataset);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// GetSessionHandle
        /// </summary>
        /// <param name="value">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtString).
        /// </returns>
        public Operation GetSessionHandle(Output value, String opName = "GetSessionHandle") 
        {
            OperationDescription desc = NewOperation("GetSessionHandle", opName);
            desc.AddInput(value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// GetSessionHandleV2
        /// </summary>
        /// <param name="value">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// </returns>
        public Operation GetSessionHandleV2(Output value, String opName = "GetSessionHandleV2") 
        {
            OperationDescription desc = NewOperation("GetSessionHandleV2", opName);
            desc.AddInput(value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// GetSessionTensor
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] value(type: DtInvalid).
        /// </returns>
        public Operation GetSessionTensor(Output handle, DataType dtype, String opName = "GetSessionTensor") 
        {
            OperationDescription desc = NewOperation("GetSessionTensor", opName);
            desc.AddInput(handle);
            desc.SetAttr("dtype", dtype);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// GetStatsFromListOfSparseCoreCooTensors
        /// </summary>
        /// <param name="row_ids_list">Input to the operation. </param>
        /// <param name="col_ids_list">Input to the operation. </param>
        /// <param name="gains_list">Input to the operation. </param>
        /// <param name="sample_count_list">sample count list</param>
        /// <param name="col_offset_list">col offset list</param>
        /// <param name="num_replica">num replica</param>
        /// <param name="table_vocab_size">table vocab size</param>
        /// <param name="feature_width">feature width</param>
        /// <param name="num_sc_per_chip">num sc per chip</param>
        /// <param name="table_name">table name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] max_ids_per_sparse_core(type: DtInt32).
        /// [1] max_unique_ids_per_sparse_core(type: DtInt32).
        /// </returns>
        public Operation GetStatsFromListOfSparseCoreCooTensors(Output row_ids_list, Output col_ids_list, Output gains_list, long[] sample_count_list, long[] col_offset_list, long num_replica, long table_vocab_size, long feature_width, long num_sc_per_chip, string table_name, String opName = "GetStatsFromListOfSparseCoreCooTensors") 
        {
            OperationDescription desc = NewOperation("GetStatsFromListOfSparseCoreCooTensors", opName);
            desc.AddInput(row_ids_list);
            desc.AddInput(col_ids_list);
            desc.AddInput(gains_list);
            desc.SetAttr("sample_count_list", sample_count_list);
            desc.SetAttr("col_offset_list", col_offset_list);
            desc.SetAttr("num_replica", num_replica);
            desc.SetAttr("table_vocab_size", table_vocab_size);
            desc.SetAttr("feature_width", feature_width);
            desc.SetAttr("num_sc_per_chip", num_sc_per_chip);
            desc.SetAttr("table_name", table_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// GetTpuTaskId
        /// </summary>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] tpu_task_id(type: DtInt32).
        /// </returns>
        public Operation GetTpuTaskId(String opName = "GetTpuTaskId") 
        {
            OperationDescription desc = NewOperation("GetTpuTaskId", opName);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// GlobalIterId
        /// </summary>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] iter_id(type: DtInt64).
        /// </returns>
        public Operation GlobalIterId(String opName = "GlobalIterId") 
        {
            OperationDescription desc = NewOperation("GlobalIterId", opName);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// GlobalShuffleDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="seed">Input to the operation. </param>
        /// <param name="seed2">Input to the operation. </param>
        /// <param name="seed_generator">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="reshuffle_each_iteration">reshuffle each iteration</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation GlobalShuffleDataset(Output input_dataset, Output seed, Output seed2, Output seed_generator, DataType[] output_types, long[][] output_shapes, bool reshuffle_each_iteration = true, string metadata = null, String opName = "GlobalShuffleDataset") 
        {
            OperationDescription desc = NewOperation("GlobalShuffleDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(seed);
            desc.AddInput(seed2);
            desc.AddInput(seed_generator);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (reshuffle_each_iteration != true)
                desc.SetAttr("reshuffle_each_iteration", reshuffle_each_iteration);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Greater
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtBool).
        /// </returns>
        public Operation Greater(Output x, Output y, String opName = "Greater") 
        {
            OperationDescription desc = NewOperation("Greater", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// GreaterEqual
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtBool).
        /// </returns>
        public Operation GreaterEqual(Output x, Output y, String opName = "GreaterEqual") 
        {
            OperationDescription desc = NewOperation("GreaterEqual", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// GroupByReducerDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="key_func_other_arguments">Input to the operation. </param>
        /// <param name="init_func_other_arguments">Input to the operation. </param>
        /// <param name="reduce_func_other_arguments">Input to the operation. </param>
        /// <param name="finalize_func_other_arguments">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: key_func: func; init_func: func; reduce_func: func; finalize_func: func
        public Operation GroupByReducerDataset(Output input_dataset, Output key_func_other_arguments, Output init_func_other_arguments, Output reduce_func_other_arguments, Output finalize_func_other_arguments, DataType[] output_types, long[][] output_shapes, String opName = "GroupByReducerDataset") 
        {
            OperationDescription desc = NewOperation("GroupByReducerDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(key_func_other_arguments);
            desc.AddInput(init_func_other_arguments);
            desc.AddInput(reduce_func_other_arguments);
            desc.AddInput(finalize_func_other_arguments);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// GroupByWindowDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="key_func_other_arguments">Input to the operation. </param>
        /// <param name="reduce_func_other_arguments">Input to the operation. </param>
        /// <param name="window_size_func_other_arguments">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: key_func: func; reduce_func: func; window_size_func: func
        public Operation GroupByWindowDataset(Output input_dataset, Output key_func_other_arguments, Output reduce_func_other_arguments, Output window_size_func_other_arguments, DataType[] output_types, long[][] output_shapes, string metadata = null, String opName = "GroupByWindowDataset") 
        {
            OperationDescription desc = NewOperation("GroupByWindowDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(key_func_other_arguments);
            desc.AddInput(reduce_func_other_arguments);
            desc.AddInput(window_size_func_other_arguments);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// GRUBlockCell
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="h_prev">Input to the operation. </param>
        /// <param name="w_ru">Input to the operation. </param>
        /// <param name="w_c">Input to the operation. </param>
        /// <param name="b_ru">Input to the operation. </param>
        /// <param name="b_c">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] r(type: DtInvalid).
        /// [1] u(type: DtInvalid).
        /// [2] c(type: DtInvalid).
        /// [3] h(type: DtInvalid).
        /// </returns>
        public Operation GRUBlockCell(Output x, Output h_prev, Output w_ru, Output w_c, Output b_ru, Output b_c, String opName = "GRUBlockCell") 
        {
            OperationDescription desc = NewOperation("GRUBlockCell", opName);
            desc.AddInput(x);
            desc.AddInput(h_prev);
            desc.AddInput(w_ru);
            desc.AddInput(w_c);
            desc.AddInput(b_ru);
            desc.AddInput(b_c);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// GRUBlockCellGrad
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="h_prev">Input to the operation. </param>
        /// <param name="w_ru">Input to the operation. </param>
        /// <param name="w_c">Input to the operation. </param>
        /// <param name="b_ru">Input to the operation. </param>
        /// <param name="b_c">Input to the operation. </param>
        /// <param name="r">Input to the operation. </param>
        /// <param name="u">Input to the operation. </param>
        /// <param name="c">Input to the operation. </param>
        /// <param name="d_h">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] d_x(type: DtInvalid).
        /// [1] d_h_prev(type: DtInvalid).
        /// [2] d_c_bar(type: DtInvalid).
        /// [3] d_r_bar_u_bar(type: DtInvalid).
        /// </returns>
        public Operation GRUBlockCellGrad(Output x, Output h_prev, Output w_ru, Output w_c, Output b_ru, Output b_c, Output r, Output u, Output c, Output d_h, String opName = "GRUBlockCellGrad") 
        {
            OperationDescription desc = NewOperation("GRUBlockCellGrad", opName);
            desc.AddInput(x);
            desc.AddInput(h_prev);
            desc.AddInput(w_ru);
            desc.AddInput(w_c);
            desc.AddInput(b_ru);
            desc.AddInput(b_c);
            desc.AddInput(r);
            desc.AddInput(u);
            desc.AddInput(c);
            desc.AddInput(d_h);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// GuaranteeConst
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation GuaranteeConst(Output input, String opName = "GuaranteeConst") 
        {
            OperationDescription desc = NewOperation("GuaranteeConst", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// HashTable
        /// </summary>
        /// <param name="key_dtype">key dtype</param>
        /// <param name="value_dtype">value dtype</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="use_node_name_sharing">use node name sharing</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] table_handle(type: DtString).
        /// </returns>
        public Operation HashTable(DataType key_dtype, DataType value_dtype, string container = null, string shared_name = null, bool use_node_name_sharing = false, String opName = "HashTable") 
        {
            OperationDescription desc = NewOperation("HashTable", opName);
            desc.SetAttr("key_dtype", key_dtype);
            desc.SetAttr("value_dtype", value_dtype);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            if (use_node_name_sharing != false)
                desc.SetAttr("use_node_name_sharing", use_node_name_sharing);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// HashTableV2
        /// </summary>
        /// <param name="key_dtype">key dtype</param>
        /// <param name="value_dtype">value dtype</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="use_node_name_sharing">use node name sharing</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] table_handle(type: DtResource).
        /// </returns>
        public Operation HashTableV2(DataType key_dtype, DataType value_dtype, string container = null, string shared_name = null, bool use_node_name_sharing = false, String opName = "HashTableV2") 
        {
            OperationDescription desc = NewOperation("HashTableV2", opName);
            desc.SetAttr("key_dtype", key_dtype);
            desc.SetAttr("value_dtype", value_dtype);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            if (use_node_name_sharing != false)
                desc.SetAttr("use_node_name_sharing", use_node_name_sharing);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// HistogramFixedWidth
        /// </summary>
        /// <param name="values">Input to the operation. </param>
        /// <param name="value_range">Input to the operation. </param>
        /// <param name="nbins">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation HistogramFixedWidth(Output values, Output value_range, Output nbins, DataType? dtype = null, String opName = "HistogramFixedWidth") 
        {
            OperationDescription desc = NewOperation("HistogramFixedWidth", opName);
            desc.AddInput(values);
            desc.AddInput(value_range);
            desc.AddInput(nbins);
            if (dtype.HasValue)
                desc.SetAttr("dtype", dtype.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// HistogramSummary
        /// </summary>
        /// <param name="tag">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] summary(type: DtString).
        /// </returns>
        public Operation HistogramSummary(Output tag, Output values, String opName = "HistogramSummary") 
        {
            OperationDescription desc = NewOperation("HistogramSummary", opName);
            desc.AddInput(tag);
            desc.AddInput(values);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// HostConst
        /// </summary>
        /// <param name="value">value</param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation HostConst(Tensor value, DataType dtype, String opName = "HostConst") 
        {
            OperationDescription desc = NewOperation("HostConst", opName);
            desc.SetAttr("value", value);
            desc.SetAttr("dtype", dtype);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// HSVToRGB
        /// </summary>
        /// <param name="images">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation HSVToRGB(Output images, String opName = "HSVToRGB") 
        {
            OperationDescription desc = NewOperation("HSVToRGB", opName);
            desc.AddInput(images);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Identity
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Identity(Output input, String opName = "Identity") 
        {
            OperationDescription desc = NewOperation("Identity", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IdentityN
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation IdentityN(Output input, String opName = "IdentityN") 
        {
            OperationDescription desc = NewOperation("IdentityN", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IdentityReader
        /// </summary>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] reader_handle(type: DtString).
        /// </returns>
        public Operation IdentityReader(string container = null, string shared_name = null, String opName = "IdentityReader") 
        {
            OperationDescription desc = NewOperation("IdentityReader", opName);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IdentityReaderV2
        /// </summary>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] reader_handle(type: DtResource).
        /// </returns>
        public Operation IdentityReaderV2(string container = null, string shared_name = null, String opName = "IdentityReaderV2") 
        {
            OperationDescription desc = NewOperation("IdentityReaderV2", opName);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// If
        /// </summary>
        /// <param name="cond">Input to the operation. </param>
        /// <param name="input">Input to the operation. </param>
        /// <param name="Tout">Tout</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        // The following attributes are not known: then_branch: func; else_branch: func
        public Operation If(Output cond, Output input, DataType[] Tout, long[][] output_shapes = null, String opName = "If") 
        {
            OperationDescription desc = NewOperation("If", opName);
            desc.AddInput(cond);
            desc.AddInput(input);
            desc.SetAttr("Tout", Tout);
            if (output_shapes != null) desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IFFT
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation IFFT(Output input, String opName = "IFFT") 
        {
            OperationDescription desc = NewOperation("IFFT", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IFFT2D
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation IFFT2D(Output input, String opName = "IFFT2D") 
        {
            OperationDescription desc = NewOperation("IFFT2D", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IFFT3D
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation IFFT3D(Output input, String opName = "IFFT3D") 
        {
            OperationDescription desc = NewOperation("IFFT3D", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IFFTND
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="fft_length">Input to the operation. </param>
        /// <param name="axes">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation IFFTND(Output input, Output fft_length, Output axes, String opName = "IFFTND") 
        {
            OperationDescription desc = NewOperation("IFFTND", opName);
            desc.AddInput(input);
            desc.AddInput(fft_length);
            desc.AddInput(axes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Igamma
        /// </summary>
        /// <param name="a">Input to the operation. </param>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation Igamma(Output a, Output x, String opName = "Igamma") 
        {
            OperationDescription desc = NewOperation("Igamma", opName);
            desc.AddInput(a);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Igammac
        /// </summary>
        /// <param name="a">Input to the operation. </param>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation Igammac(Output a, Output x, String opName = "Igammac") 
        {
            OperationDescription desc = NewOperation("Igammac", opName);
            desc.AddInput(a);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IgammaGradA
        /// </summary>
        /// <param name="a">Input to the operation. </param>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation IgammaGradA(Output a, Output x, String opName = "IgammaGradA") 
        {
            OperationDescription desc = NewOperation("IgammaGradA", opName);
            desc.AddInput(a);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IgnoreErrorsDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="log_warning">log warning</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation IgnoreErrorsDataset(Output input_dataset, DataType[] output_types, long[][] output_shapes, bool log_warning = false, String opName = "IgnoreErrorsDataset") 
        {
            OperationDescription desc = NewOperation("IgnoreErrorsDataset", opName);
            desc.AddInput(input_dataset);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (log_warning != false)
                desc.SetAttr("log_warning", log_warning);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Imag
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="Tout">Tout</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Imag(Output input, DataType? Tout = null, String opName = "Imag") 
        {
            OperationDescription desc = NewOperation("Imag", opName);
            desc.AddInput(input);
            if (Tout.HasValue)
                desc.SetAttr("Tout", Tout.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ImageProjectiveTransformV2
        /// </summary>
        /// <param name="images">Input to the operation. </param>
        /// <param name="transforms">Input to the operation. </param>
        /// <param name="output_shape">Input to the operation. </param>
        /// <param name="interpolation">interpolation</param>
        /// <param name="fill_mode">fill mode</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] transformed_images(type: DtInvalid).
        /// </returns>
        public Operation ImageProjectiveTransformV2(Output images, Output transforms, Output output_shape, string interpolation, string fill_mode = null, String opName = "ImageProjectiveTransformV2") 
        {
            OperationDescription desc = NewOperation("ImageProjectiveTransformV2", opName);
            desc.AddInput(images);
            desc.AddInput(transforms);
            desc.AddInput(output_shape);
            desc.SetAttr("interpolation", interpolation);
            if (fill_mode != null)
                 desc.SetAttr("fill_mode", fill_mode);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ImageProjectiveTransformV3
        /// </summary>
        /// <param name="images">Input to the operation. </param>
        /// <param name="transforms">Input to the operation. </param>
        /// <param name="output_shape">Input to the operation. </param>
        /// <param name="fill_value">Input to the operation. </param>
        /// <param name="interpolation">interpolation</param>
        /// <param name="fill_mode">fill mode</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] transformed_images(type: DtInvalid).
        /// </returns>
        public Operation ImageProjectiveTransformV3(Output images, Output transforms, Output output_shape, Output fill_value, string interpolation, string fill_mode = null, String opName = "ImageProjectiveTransformV3") 
        {
            OperationDescription desc = NewOperation("ImageProjectiveTransformV3", opName);
            desc.AddInput(images);
            desc.AddInput(transforms);
            desc.AddInput(output_shape);
            desc.AddInput(fill_value);
            desc.SetAttr("interpolation", interpolation);
            if (fill_mode != null)
                 desc.SetAttr("fill_mode", fill_mode);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ImageSummary
        /// </summary>
        /// <param name="tag">Input to the operation. </param>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="max_images">max images</param>
        /// <param name="bad_color">bad color</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] summary(type: DtString).
        /// </returns>
        public Operation ImageSummary(Output tag, Output tensor, long max_images = 3, Tensor bad_color = null, String opName = "ImageSummary") 
        {
            OperationDescription desc = NewOperation("ImageSummary", opName);
            desc.AddInput(tag);
            desc.AddInput(tensor);
            if (max_images != 3)
                desc.SetAttr("max_images", max_images);
            if (bad_color != null)
                 desc.SetAttr("bad_color", bad_color);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ImmutableConst
        /// </summary>
        /// <param name="dtype">dtype</param>
        /// <param name="shape">shape</param>
        /// <param name="memory_region_name">memory region name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] tensor(type: DtInvalid).
        /// </returns>
        public Operation ImmutableConst(DataType dtype, long[] shape, string memory_region_name, String opName = "ImmutableConst") 
        {
            OperationDescription desc = NewOperation("ImmutableConst", opName);
            desc.SetAttr("dtype", dtype);
            desc.SetAttrShape("shape", shape);
            desc.SetAttr("memory_region_name", memory_region_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ImportEvent
        /// </summary>
        /// <param name="writer">Input to the operation. </param>
        /// <param name="tfEvent">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ImportEvent(Output writer, Output tfEvent, String opName = "ImportEvent") 
        {
            OperationDescription desc = NewOperation("ImportEvent", opName);
            desc.AddInput(writer);
            desc.AddInput(tfEvent);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IndexFlatMapDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="map_func_other_args">Input to the operation. </param>
        /// <param name="index_map_func_other_args">Input to the operation. </param>
        /// <param name="output_cardinality">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: map_func: func; index_map_func: func
        public Operation IndexFlatMapDataset(Output input_dataset, Output map_func_other_args, Output index_map_func_other_args, Output output_cardinality, DataType[] output_types, long[][] output_shapes, string metadata = null, String opName = "IndexFlatMapDataset") 
        {
            OperationDescription desc = NewOperation("IndexFlatMapDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(map_func_other_args);
            desc.AddInput(index_map_func_other_args);
            desc.AddInput(output_cardinality);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// InfeedDequeue
        /// </summary>
        /// <param name="dtype">dtype</param>
        /// <param name="shape">shape</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation InfeedDequeue(DataType dtype, long[] shape, String opName = "InfeedDequeue") 
        {
            OperationDescription desc = NewOperation("InfeedDequeue", opName);
            desc.SetAttr("dtype", dtype);
            desc.SetAttrShape("shape", shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// InfeedDequeueTuple
        /// </summary>
        /// <param name="dtypes">dtypes</param>
        /// <param name="shapes">shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] outputs(type: DtInvalid).
        /// </returns>
        public Operation InfeedDequeueTuple(DataType[] dtypes, long[][] shapes, String opName = "InfeedDequeueTuple") 
        {
            OperationDescription desc = NewOperation("InfeedDequeueTuple", opName);
            desc.SetAttr("dtypes", dtypes);
            desc.SetAttrShapeList("shapes", shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// InfeedEnqueue
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="shape">shape</param>
        /// <param name="layout">layout</param>
        /// <param name="device_ordinal">device ordinal</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation InfeedEnqueue(Output input, long[] shape = null, long[] layout = null, long device_ordinal = -1, String opName = "InfeedEnqueue") 
        {
            OperationDescription desc = NewOperation("InfeedEnqueue", opName);
            desc.AddInput(input);
            if (shape != null)
                 desc.SetAttrShape("shape", shape);
            if (layout != null) desc.SetAttr("layout", layout);
            if (device_ordinal != -1)
                desc.SetAttr("device_ordinal", device_ordinal);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// InfeedEnqueuePrelinearizedBuffer
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="device_ordinal">device ordinal</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation InfeedEnqueuePrelinearizedBuffer(Output input, long device_ordinal = -1, String opName = "InfeedEnqueuePrelinearizedBuffer") 
        {
            OperationDescription desc = NewOperation("InfeedEnqueuePrelinearizedBuffer", opName);
            desc.AddInput(input);
            if (device_ordinal != -1)
                desc.SetAttr("device_ordinal", device_ordinal);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// InfeedEnqueueTuple
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="shapes">shapes</param>
        /// <param name="layouts">layouts</param>
        /// <param name="device_ordinal">device ordinal</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation InfeedEnqueueTuple(Output inputs, long[][] shapes, long[] layouts = null, long device_ordinal = -1, String opName = "InfeedEnqueueTuple") 
        {
            OperationDescription desc = NewOperation("InfeedEnqueueTuple", opName);
            desc.AddInput(inputs);
            desc.SetAttrShapeList("shapes", shapes);
            if (layouts != null) desc.SetAttr("layouts", layouts);
            if (device_ordinal != -1)
                desc.SetAttr("device_ordinal", device_ordinal);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// InitializeTable
        /// </summary>
        /// <param name="table_handle">Input to the operation. </param>
        /// <param name="keys">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation InitializeTable(Output table_handle, Output keys, Output values, String opName = "InitializeTable") 
        {
            OperationDescription desc = NewOperation("InitializeTable", opName);
            desc.AddInput(table_handle);
            desc.AddInput(keys);
            desc.AddInput(values);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// InitializeTableFromDataset
        /// </summary>
        /// <param name="table_handle">Input to the operation. </param>
        /// <param name="dataset">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation InitializeTableFromDataset(Output table_handle, Output dataset, String opName = "InitializeTableFromDataset") 
        {
            OperationDescription desc = NewOperation("InitializeTableFromDataset", opName);
            desc.AddInput(table_handle);
            desc.AddInput(dataset);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// InitializeTableFromTextFile
        /// </summary>
        /// <param name="table_handle">Input to the operation. </param>
        /// <param name="filename">Input to the operation. </param>
        /// <param name="key_index">key index</param>
        /// <param name="value_index">value index</param>
        /// <param name="vocab_size">vocab size</param>
        /// <param name="delimiter">delimiter</param>
        /// <param name="offset">offset</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation InitializeTableFromTextFile(Output table_handle, Output filename, long key_index, long value_index, long vocab_size = -1, string delimiter = null, long offset = 0, String opName = "InitializeTableFromTextFile") 
        {
            OperationDescription desc = NewOperation("InitializeTableFromTextFile", opName);
            desc.AddInput(table_handle);
            desc.AddInput(filename);
            desc.SetAttr("key_index", key_index);
            desc.SetAttr("value_index", value_index);
            if (vocab_size != -1)
                desc.SetAttr("vocab_size", vocab_size);
            if (delimiter != null)
                 desc.SetAttr("delimiter", delimiter);
            if (offset != 0)
                desc.SetAttr("offset", offset);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// InitializeTableFromTextFileV2
        /// </summary>
        /// <param name="table_handle">Input to the operation. </param>
        /// <param name="filename">Input to the operation. </param>
        /// <param name="key_index">key index</param>
        /// <param name="value_index">value index</param>
        /// <param name="vocab_size">vocab size</param>
        /// <param name="delimiter">delimiter</param>
        /// <param name="offset">offset</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation InitializeTableFromTextFileV2(Output table_handle, Output filename, long key_index, long value_index, long vocab_size = -1, string delimiter = null, long offset = 0, String opName = "InitializeTableFromTextFileV2") 
        {
            OperationDescription desc = NewOperation("InitializeTableFromTextFileV2", opName);
            desc.AddInput(table_handle);
            desc.AddInput(filename);
            desc.SetAttr("key_index", key_index);
            desc.SetAttr("value_index", value_index);
            if (vocab_size != -1)
                desc.SetAttr("vocab_size", vocab_size);
            if (delimiter != null)
                 desc.SetAttr("delimiter", delimiter);
            if (offset != 0)
                desc.SetAttr("offset", offset);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// InitializeTableV2
        /// </summary>
        /// <param name="table_handle">Input to the operation. </param>
        /// <param name="keys">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation InitializeTableV2(Output table_handle, Output keys, Output values, String opName = "InitializeTableV2") 
        {
            OperationDescription desc = NewOperation("InitializeTableV2", opName);
            desc.AddInput(table_handle);
            desc.AddInput(keys);
            desc.AddInput(values);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// InplaceAdd
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="i">Input to the operation. </param>
        /// <param name="v">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation InplaceAdd(Output x, Output i, Output v, String opName = "InplaceAdd") 
        {
            OperationDescription desc = NewOperation("InplaceAdd", opName);
            desc.AddInput(x);
            desc.AddInput(i);
            desc.AddInput(v);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// InplaceSub
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="i">Input to the operation. </param>
        /// <param name="v">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation InplaceSub(Output x, Output i, Output v, String opName = "InplaceSub") 
        {
            OperationDescription desc = NewOperation("InplaceSub", opName);
            desc.AddInput(x);
            desc.AddInput(i);
            desc.AddInput(v);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// InplaceUpdate
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="i">Input to the operation. </param>
        /// <param name="v">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation InplaceUpdate(Output x, Output i, Output v, String opName = "InplaceUpdate") 
        {
            OperationDescription desc = NewOperation("InplaceUpdate", opName);
            desc.AddInput(x);
            desc.AddInput(i);
            desc.AddInput(v);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// InterleaveDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="other_arguments">Input to the operation. </param>
        /// <param name="cycle_length">Input to the operation. </param>
        /// <param name="block_length">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: f: func
        public Operation InterleaveDataset(Output input_dataset, Output other_arguments, Output cycle_length, Output block_length, DataType[] output_types, long[][] output_shapes, string metadata = null, String opName = "InterleaveDataset") 
        {
            OperationDescription desc = NewOperation("InterleaveDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(other_arguments);
            desc.AddInput(cycle_length);
            desc.AddInput(block_length);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// InTopK
        /// </summary>
        /// <param name="predictions">Input to the operation. </param>
        /// <param name="targets">Input to the operation. </param>
        /// <param name="k">k</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] precision(type: DtBool).
        /// </returns>
        public Operation InTopK(Output predictions, Output targets, long k, String opName = "InTopK") 
        {
            OperationDescription desc = NewOperation("InTopK", opName);
            desc.AddInput(predictions);
            desc.AddInput(targets);
            desc.SetAttr("k", k);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// InTopKV2
        /// </summary>
        /// <param name="predictions">Input to the operation. </param>
        /// <param name="targets">Input to the operation. </param>
        /// <param name="k">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] precision(type: DtBool).
        /// </returns>
        public Operation InTopKV2(Output predictions, Output targets, Output k, String opName = "InTopKV2") 
        {
            OperationDescription desc = NewOperation("InTopKV2", opName);
            desc.AddInput(predictions);
            desc.AddInput(targets);
            desc.AddInput(k);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Inv
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Inv(Output x, String opName = "Inv") 
        {
            OperationDescription desc = NewOperation("Inv", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Invert
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Invert(Output x, String opName = "Invert") 
        {
            OperationDescription desc = NewOperation("Invert", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// InvertPermutation
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation InvertPermutation(Output x, String opName = "InvertPermutation") 
        {
            OperationDescription desc = NewOperation("InvertPermutation", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// InvGrad
        /// </summary>
        /// <param name="y">Input to the operation. </param>
        /// <param name="dy">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation InvGrad(Output y, Output dy, String opName = "InvGrad") 
        {
            OperationDescription desc = NewOperation("InvGrad", opName);
            desc.AddInput(y);
            desc.AddInput(dy);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IRFFT
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="fft_length">Input to the operation. </param>
        /// <param name="Treal">Treal</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation IRFFT(Output input, Output fft_length, DataType? Treal = null, String opName = "IRFFT") 
        {
            OperationDescription desc = NewOperation("IRFFT", opName);
            desc.AddInput(input);
            desc.AddInput(fft_length);
            if (Treal.HasValue)
                desc.SetAttr("Treal", Treal.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IRFFT2D
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="fft_length">Input to the operation. </param>
        /// <param name="Treal">Treal</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation IRFFT2D(Output input, Output fft_length, DataType? Treal = null, String opName = "IRFFT2D") 
        {
            OperationDescription desc = NewOperation("IRFFT2D", opName);
            desc.AddInput(input);
            desc.AddInput(fft_length);
            if (Treal.HasValue)
                desc.SetAttr("Treal", Treal.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IRFFT3D
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="fft_length">Input to the operation. </param>
        /// <param name="Treal">Treal</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation IRFFT3D(Output input, Output fft_length, DataType? Treal = null, String opName = "IRFFT3D") 
        {
            OperationDescription desc = NewOperation("IRFFT3D", opName);
            desc.AddInput(input);
            desc.AddInput(fft_length);
            if (Treal.HasValue)
                desc.SetAttr("Treal", Treal.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IRFFTND
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="fft_length">Input to the operation. </param>
        /// <param name="axes">Input to the operation. </param>
        /// <param name="Treal">Treal</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation IRFFTND(Output input, Output fft_length, Output axes, DataType? Treal = null, String opName = "IRFFTND") 
        {
            OperationDescription desc = NewOperation("IRFFTND", opName);
            desc.AddInput(input);
            desc.AddInput(fft_length);
            desc.AddInput(axes);
            if (Treal.HasValue)
                desc.SetAttr("Treal", Treal.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IsBoostedTreesEnsembleInitialized
        /// </summary>
        /// <param name="tree_ensemble_handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] is_initialized(type: DtBool).
        /// </returns>
        public Operation IsBoostedTreesEnsembleInitialized(Output tree_ensemble_handle, String opName = "IsBoostedTreesEnsembleInitialized") 
        {
            OperationDescription desc = NewOperation("IsBoostedTreesEnsembleInitialized", opName);
            desc.AddInput(tree_ensemble_handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IsBoostedTreesQuantileStreamResourceInitialized
        /// </summary>
        /// <param name="quantile_stream_resource_handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] is_initialized(type: DtBool).
        /// </returns>
        public Operation IsBoostedTreesQuantileStreamResourceInitialized(Output quantile_stream_resource_handle, String opName = "IsBoostedTreesQuantileStreamResourceInitialized") 
        {
            OperationDescription desc = NewOperation("IsBoostedTreesQuantileStreamResourceInitialized", opName);
            desc.AddInput(quantile_stream_resource_handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IsFinite
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtBool).
        /// </returns>
        public Operation IsFinite(Output x, String opName = "IsFinite") 
        {
            OperationDescription desc = NewOperation("IsFinite", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IsInf
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtBool).
        /// </returns>
        public Operation IsInf(Output x, String opName = "IsInf") 
        {
            OperationDescription desc = NewOperation("IsInf", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IsNan
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtBool).
        /// </returns>
        public Operation IsNan(Output x, String opName = "IsNan") 
        {
            OperationDescription desc = NewOperation("IsNan", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IsotonicRegression
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="output_dtype">output dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] segments(type: DtInt32).
        /// </returns>
        public Operation IsotonicRegression(Output input, DataType? output_dtype = null, String opName = "IsotonicRegression") 
        {
            OperationDescription desc = NewOperation("IsotonicRegression", opName);
            desc.AddInput(input);
            if (output_dtype.HasValue)
                desc.SetAttr("output_dtype", output_dtype.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IsTPUEmbeddingInitialized
        /// </summary>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] is_tpu_embedding_initialized(type: DtBool).
        /// </returns>
        public Operation IsTPUEmbeddingInitialized(string config = null, String opName = "IsTPUEmbeddingInitialized") 
        {
            OperationDescription desc = NewOperation("IsTPUEmbeddingInitialized", opName);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IsVariableInitialized
        /// </summary>
        /// <param name="reference">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] is_initialized(type: DtBool).
        /// </returns>
        public Operation IsVariableInitialized(Output reference, String opName = "IsVariableInitialized") 
        {
            OperationDescription desc = NewOperation("IsVariableInitialized", opName);
            desc.AddInput(reference);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Iterator
        /// </summary>
        /// <param name="shared_name">shared name</param>
        /// <param name="container">container</param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// </returns>
        public Operation Iterator(string shared_name, string container, DataType[] output_types, long[][] output_shapes, String opName = "Iterator") 
        {
            OperationDescription desc = NewOperation("Iterator", opName);
            desc.SetAttr("shared_name", shared_name);
            desc.SetAttr("container", container);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IteratorFromStringHandle
        /// </summary>
        /// <param name="string_handle">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] resource_handle(type: DtResource).
        /// </returns>
        public Operation IteratorFromStringHandle(Output string_handle, DataType[] output_types = null, long[][] output_shapes = null, String opName = "IteratorFromStringHandle") 
        {
            OperationDescription desc = NewOperation("IteratorFromStringHandle", opName);
            desc.AddInput(string_handle);
            if (output_types != null) desc.SetAttr("output_types", output_types);
            if (output_shapes != null) desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IteratorFromStringHandleV2
        /// </summary>
        /// <param name="string_handle">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] resource_handle(type: DtResource).
        /// </returns>
        public Operation IteratorFromStringHandleV2(Output string_handle, DataType[] output_types = null, long[][] output_shapes = null, String opName = "IteratorFromStringHandleV2") 
        {
            OperationDescription desc = NewOperation("IteratorFromStringHandleV2", opName);
            desc.AddInput(string_handle);
            if (output_types != null) desc.SetAttr("output_types", output_types);
            if (output_shapes != null) desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IteratorGetDevice
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] device(type: DtString).
        /// </returns>
        public Operation IteratorGetDevice(Output resource, String opName = "IteratorGetDevice") 
        {
            OperationDescription desc = NewOperation("IteratorGetDevice", opName);
            desc.AddInput(resource);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IteratorGetModelProto
        /// </summary>
        /// <param name="iterator">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] model_proto(type: DtString).
        /// </returns>
        public Operation IteratorGetModelProto(Output iterator, String opName = "IteratorGetModelProto") 
        {
            OperationDescription desc = NewOperation("IteratorGetModelProto", opName);
            desc.AddInput(iterator);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IteratorGetNext
        /// </summary>
        /// <param name="iterator">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] components(type: DtInvalid).
        /// </returns>
        public Operation IteratorGetNext(Output iterator, DataType[] output_types, long[][] output_shapes, String opName = "IteratorGetNext") 
        {
            OperationDescription desc = NewOperation("IteratorGetNext", opName);
            desc.AddInput(iterator);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IteratorGetNextAsOptional
        /// </summary>
        /// <param name="iterator">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] optional(type: DtVariant).
        /// </returns>
        public Operation IteratorGetNextAsOptional(Output iterator, DataType[] output_types, long[][] output_shapes, String opName = "IteratorGetNextAsOptional") 
        {
            OperationDescription desc = NewOperation("IteratorGetNextAsOptional", opName);
            desc.AddInput(iterator);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IteratorGetNextSync
        /// </summary>
        /// <param name="iterator">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] components(type: DtInvalid).
        /// </returns>
        public Operation IteratorGetNextSync(Output iterator, DataType[] output_types, long[][] output_shapes, String opName = "IteratorGetNextSync") 
        {
            OperationDescription desc = NewOperation("IteratorGetNextSync", opName);
            desc.AddInput(iterator);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IteratorToStringHandle
        /// </summary>
        /// <param name="resource_handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] string_handle(type: DtString).
        /// </returns>
        public Operation IteratorToStringHandle(Output resource_handle, String opName = "IteratorToStringHandle") 
        {
            OperationDescription desc = NewOperation("IteratorToStringHandle", opName);
            desc.AddInput(resource_handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// IteratorV2
        /// </summary>
        /// <param name="shared_name">shared name</param>
        /// <param name="container">container</param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// </returns>
        public Operation IteratorV2(string shared_name, string container, DataType[] output_types, long[][] output_shapes, String opName = "IteratorV2") 
        {
            OperationDescription desc = NewOperation("IteratorV2", opName);
            desc.SetAttr("shared_name", shared_name);
            desc.SetAttr("container", container);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// KMC2ChainInitialization
        /// </summary>
        /// <param name="distances">Input to the operation. </param>
        /// <param name="seed">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] index(type: DtInt64).
        /// </returns>
        public Operation KMC2ChainInitialization(Output distances, Output seed, String opName = "KMC2ChainInitialization") 
        {
            OperationDescription desc = NewOperation("KMC2ChainInitialization", opName);
            desc.AddInput(distances);
            desc.AddInput(seed);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// KmeansPlusPlusInitialization
        /// </summary>
        /// <param name="points">Input to the operation. </param>
        /// <param name="num_to_sample">Input to the operation. </param>
        /// <param name="seed">Input to the operation. </param>
        /// <param name="num_retries_per_sample">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] samples(type: DtFloat).
        /// </returns>
        public Operation KmeansPlusPlusInitialization(Output points, Output num_to_sample, Output seed, Output num_retries_per_sample, String opName = "KmeansPlusPlusInitialization") 
        {
            OperationDescription desc = NewOperation("KmeansPlusPlusInitialization", opName);
            desc.AddInput(points);
            desc.AddInput(num_to_sample);
            desc.AddInput(seed);
            desc.AddInput(num_retries_per_sample);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// KthOrderStatistic
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="k">k</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtFloat).
        /// </returns>
        public Operation KthOrderStatistic(Output input, long k, String opName = "KthOrderStatistic") 
        {
            OperationDescription desc = NewOperation("KthOrderStatistic", opName);
            desc.AddInput(input);
            desc.SetAttr("k", k);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// L2Loss
        /// </summary>
        /// <param name="t">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation L2Loss(Output t, String opName = "L2Loss") 
        {
            OperationDescription desc = NewOperation("L2Loss", opName);
            desc.AddInput(t);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LatencyStatsDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="tag">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation LatencyStatsDataset(Output input_dataset, Output tag, DataType[] output_types, long[][] output_shapes, String opName = "LatencyStatsDataset") 
        {
            OperationDescription desc = NewOperation("LatencyStatsDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(tag);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LeakyRelu
        /// </summary>
        /// <param name="features">Input to the operation. </param>
        /// <param name="alpha">alpha</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] activations(type: DtInvalid).
        /// </returns>
        public Operation LeakyRelu(Output features, float alpha = 0.2f, String opName = "LeakyRelu") 
        {
            OperationDescription desc = NewOperation("LeakyRelu", opName);
            desc.AddInput(features);
            if (alpha != 0.2f)
                desc.SetAttr("alpha", alpha);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LeakyReluGrad
        /// </summary>
        /// <param name="gradients">Input to the operation. </param>
        /// <param name="features">Input to the operation. </param>
        /// <param name="alpha">alpha</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] backprops(type: DtInvalid).
        /// </returns>
        public Operation LeakyReluGrad(Output gradients, Output features, float alpha = 0.2f, String opName = "LeakyReluGrad") 
        {
            OperationDescription desc = NewOperation("LeakyReluGrad", opName);
            desc.AddInput(gradients);
            desc.AddInput(features);
            if (alpha != 0.2f)
                desc.SetAttr("alpha", alpha);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LearnedUnigramCandidateSampler
        /// </summary>
        /// <param name="true_classes">Input to the operation. </param>
        /// <param name="num_true">num true</param>
        /// <param name="num_sampled">num sampled</param>
        /// <param name="unique">unique</param>
        /// <param name="range_max">range max</param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] sampled_candidates(type: DtInt64).
        /// [1] true_expected_count(type: DtFloat).
        /// [2] sampled_expected_count(type: DtFloat).
        /// </returns>
        public Operation LearnedUnigramCandidateSampler(Output true_classes, long num_true, long num_sampled, bool unique, long range_max, long seed = 0, long seed2 = 0, String opName = "LearnedUnigramCandidateSampler") 
        {
            OperationDescription desc = NewOperation("LearnedUnigramCandidateSampler", opName);
            desc.AddInput(true_classes);
            desc.SetAttr("num_true", num_true);
            desc.SetAttr("num_sampled", num_sampled);
            desc.SetAttr("unique", unique);
            desc.SetAttr("range_max", range_max);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LeftShift
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation LeftShift(Output x, Output y, String opName = "LeftShift") 
        {
            OperationDescription desc = NewOperation("LeftShift", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LegacyParallelInterleaveDatasetV2
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="other_arguments">Input to the operation. </param>
        /// <param name="cycle_length">Input to the operation. </param>
        /// <param name="block_length">Input to the operation. </param>
        /// <param name="buffer_output_elements">Input to the operation. </param>
        /// <param name="prefetch_input_elements">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="deterministic">deterministic</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: f: func
        public Operation LegacyParallelInterleaveDatasetV2(Output input_dataset, Output other_arguments, Output cycle_length, Output block_length, Output buffer_output_elements, Output prefetch_input_elements, DataType[] output_types, long[][] output_shapes, string deterministic = null, string metadata = null, String opName = "LegacyParallelInterleaveDatasetV2") 
        {
            OperationDescription desc = NewOperation("LegacyParallelInterleaveDatasetV2", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(other_arguments);
            desc.AddInput(cycle_length);
            desc.AddInput(block_length);
            desc.AddInput(buffer_output_elements);
            desc.AddInput(prefetch_input_elements);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (deterministic != null)
                 desc.SetAttr("deterministic", deterministic);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Less
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtBool).
        /// </returns>
        public Operation Less(Output x, Output y, String opName = "Less") 
        {
            OperationDescription desc = NewOperation("Less", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LessEqual
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtBool).
        /// </returns>
        public Operation LessEqual(Output x, Output y, String opName = "LessEqual") 
        {
            OperationDescription desc = NewOperation("LessEqual", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Lgamma
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Lgamma(Output x, String opName = "Lgamma") 
        {
            OperationDescription desc = NewOperation("Lgamma", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LinSpace
        /// </summary>
        /// <param name="start">Input to the operation. </param>
        /// <param name="stop">Input to the operation. </param>
        /// <param name="num">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation LinSpace(Output start, Output stop, Output num, String opName = "LinSpace") 
        {
            OperationDescription desc = NewOperation("LinSpace", opName);
            desc.AddInput(start);
            desc.AddInput(stop);
            desc.AddInput(num);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ListDataset
        /// </summary>
        /// <param name="tensors">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ListDataset(Output tensors, DataType[] output_types, long[][] output_shapes, string metadata = null, String opName = "ListDataset") 
        {
            OperationDescription desc = NewOperation("ListDataset", opName);
            desc.AddInput(tensors);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ListDiff
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="out_idx">out idx</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// [1] idx(type: DtInvalid).
        /// </returns>
        public Operation ListDiff(Output x, Output y, DataType? out_idx = null, String opName = "ListDiff") 
        {
            OperationDescription desc = NewOperation("ListDiff", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            if (out_idx.HasValue)
                desc.SetAttr("out_idx", out_idx.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ListSnapshotChunksDataset
        /// </summary>
        /// <param name="snapshot_path">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ListSnapshotChunksDataset(Output snapshot_path, DataType[] output_types, long[][] output_shapes, String opName = "ListSnapshotChunksDataset") 
        {
            OperationDescription desc = NewOperation("ListSnapshotChunksDataset", opName);
            desc.AddInput(snapshot_path);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LMDBDataset
        /// </summary>
        /// <param name="filenames">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation LMDBDataset(Output filenames, DataType[] output_types, long[][] output_shapes, String opName = "LMDBDataset") 
        {
            OperationDescription desc = NewOperation("LMDBDataset", opName);
            desc.AddInput(filenames);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LMDBReader
        /// </summary>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] reader_handle(type: DtString).
        /// </returns>
        public Operation LMDBReader(string container = null, string shared_name = null, String opName = "LMDBReader") 
        {
            OperationDescription desc = NewOperation("LMDBReader", opName);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LoadAllTPUEmbeddingParameters
        /// </summary>
        /// <param name="parameters">Input to the operation. </param>
        /// <param name="auxiliary1">Input to the operation. </param>
        /// <param name="auxiliary2">Input to the operation. </param>
        /// <param name="auxiliary3">Input to the operation. </param>
        /// <param name="auxiliary4">Input to the operation. </param>
        /// <param name="auxiliary5">Input to the operation. </param>
        /// <param name="auxiliary6">Input to the operation. </param>
        /// <param name="auxiliary7">Input to the operation. </param>
        /// <param name="config">config</param>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation LoadAllTPUEmbeddingParameters(Output parameters, Output auxiliary1, Output auxiliary2, Output auxiliary3, Output auxiliary4, Output auxiliary5, Output auxiliary6, Output auxiliary7, string config, long num_shards, long shard_id, String opName = "LoadAllTPUEmbeddingParameters") 
        {
            OperationDescription desc = NewOperation("LoadAllTPUEmbeddingParameters", opName);
            desc.AddInput(parameters);
            desc.AddInput(auxiliary1);
            desc.AddInput(auxiliary2);
            desc.AddInput(auxiliary3);
            desc.AddInput(auxiliary4);
            desc.AddInput(auxiliary5);
            desc.AddInput(auxiliary6);
            desc.AddInput(auxiliary7);
            desc.SetAttr("config", config);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LoadAndRemapMatrix
        /// </summary>
        /// <param name="ckpt_path">Input to the operation. </param>
        /// <param name="old_tensor_name">Input to the operation. </param>
        /// <param name="row_remapping">Input to the operation. </param>
        /// <param name="col_remapping">Input to the operation. </param>
        /// <param name="initializing_values">Input to the operation. </param>
        /// <param name="num_rows">num rows</param>
        /// <param name="num_cols">num cols</param>
        /// <param name="max_rows_in_memory">max rows in memory</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_matrix(type: DtFloat).
        /// </returns>
        public Operation LoadAndRemapMatrix(Output ckpt_path, Output old_tensor_name, Output row_remapping, Output col_remapping, Output initializing_values, long num_rows, long num_cols, long max_rows_in_memory = -1, String opName = "LoadAndRemapMatrix") 
        {
            OperationDescription desc = NewOperation("LoadAndRemapMatrix", opName);
            desc.AddInput(ckpt_path);
            desc.AddInput(old_tensor_name);
            desc.AddInput(row_remapping);
            desc.AddInput(col_remapping);
            desc.AddInput(initializing_values);
            desc.SetAttr("num_rows", num_rows);
            desc.SetAttr("num_cols", num_cols);
            if (max_rows_in_memory != -1)
                desc.SetAttr("max_rows_in_memory", max_rows_in_memory);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LoadDataset
        /// </summary>
        /// <param name="path">Input to the operation. </param>
        /// <param name="reader_func_other_args">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="compression">compression</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: reader_func: func
        public Operation LoadDataset(Output path, Output reader_func_other_args, DataType[] output_types, long[][] output_shapes, string compression = null, String opName = "LoadDataset") 
        {
            OperationDescription desc = NewOperation("LoadDataset", opName);
            desc.AddInput(path);
            desc.AddInput(reader_func_other_args);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (compression != null)
                 desc.SetAttr("compression", compression);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LoadTPUEmbeddingAdadeltaParameters
        /// </summary>
        /// <param name="parameters">Input to the operation. </param>
        /// <param name="accumulators">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="table_id">table id</param>
        /// <param name="table_name">table name</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation LoadTPUEmbeddingAdadeltaParameters(Output parameters, Output accumulators, Output updates, long num_shards, long shard_id, long table_id = -1, string table_name = null, string config = null, String opName = "LoadTPUEmbeddingAdadeltaParameters") 
        {
            OperationDescription desc = NewOperation("LoadTPUEmbeddingAdadeltaParameters", opName);
            desc.AddInput(parameters);
            desc.AddInput(accumulators);
            desc.AddInput(updates);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            if (table_id != -1)
                desc.SetAttr("table_id", table_id);
            if (table_name != null)
                 desc.SetAttr("table_name", table_name);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LoadTPUEmbeddingAdagradMomentumParameters
        /// </summary>
        /// <param name="parameters">Input to the operation. </param>
        /// <param name="accumulators">Input to the operation. </param>
        /// <param name="momenta">Input to the operation. </param>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="table_id">table id</param>
        /// <param name="table_name">table name</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation LoadTPUEmbeddingAdagradMomentumParameters(Output parameters, Output accumulators, Output momenta, long num_shards, long shard_id, long table_id = -1, string table_name = null, string config = null, String opName = "LoadTPUEmbeddingAdagradMomentumParameters") 
        {
            OperationDescription desc = NewOperation("LoadTPUEmbeddingAdagradMomentumParameters", opName);
            desc.AddInput(parameters);
            desc.AddInput(accumulators);
            desc.AddInput(momenta);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            if (table_id != -1)
                desc.SetAttr("table_id", table_id);
            if (table_name != null)
                 desc.SetAttr("table_name", table_name);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LoadTPUEmbeddingAdagradParameters
        /// </summary>
        /// <param name="parameters">Input to the operation. </param>
        /// <param name="accumulators">Input to the operation. </param>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="table_id">table id</param>
        /// <param name="table_name">table name</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation LoadTPUEmbeddingAdagradParameters(Output parameters, Output accumulators, long num_shards, long shard_id, long table_id = -1, string table_name = null, string config = null, String opName = "LoadTPUEmbeddingAdagradParameters") 
        {
            OperationDescription desc = NewOperation("LoadTPUEmbeddingAdagradParameters", opName);
            desc.AddInput(parameters);
            desc.AddInput(accumulators);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            if (table_id != -1)
                desc.SetAttr("table_id", table_id);
            if (table_name != null)
                 desc.SetAttr("table_name", table_name);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LoadTPUEmbeddingADAMParameters
        /// </summary>
        /// <param name="parameters">Input to the operation. </param>
        /// <param name="momenta">Input to the operation. </param>
        /// <param name="velocities">Input to the operation. </param>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="table_id">table id</param>
        /// <param name="table_name">table name</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation LoadTPUEmbeddingADAMParameters(Output parameters, Output momenta, Output velocities, long num_shards, long shard_id, long table_id = -1, string table_name = null, string config = null, String opName = "LoadTPUEmbeddingADAMParameters") 
        {
            OperationDescription desc = NewOperation("LoadTPUEmbeddingADAMParameters", opName);
            desc.AddInput(parameters);
            desc.AddInput(momenta);
            desc.AddInput(velocities);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            if (table_id != -1)
                desc.SetAttr("table_id", table_id);
            if (table_name != null)
                 desc.SetAttr("table_name", table_name);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LoadTPUEmbeddingCenteredRMSPropParameters
        /// </summary>
        /// <param name="parameters">Input to the operation. </param>
        /// <param name="ms">Input to the operation. </param>
        /// <param name="mom">Input to the operation. </param>
        /// <param name="mg">Input to the operation. </param>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="table_id">table id</param>
        /// <param name="table_name">table name</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation LoadTPUEmbeddingCenteredRMSPropParameters(Output parameters, Output ms, Output mom, Output mg, long num_shards, long shard_id, long table_id = -1, string table_name = null, string config = null, String opName = "LoadTPUEmbeddingCenteredRMSPropParameters") 
        {
            OperationDescription desc = NewOperation("LoadTPUEmbeddingCenteredRMSPropParameters", opName);
            desc.AddInput(parameters);
            desc.AddInput(ms);
            desc.AddInput(mom);
            desc.AddInput(mg);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            if (table_id != -1)
                desc.SetAttr("table_id", table_id);
            if (table_name != null)
                 desc.SetAttr("table_name", table_name);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LoadTPUEmbeddingFrequencyEstimatorParameters
        /// </summary>
        /// <param name="parameters">Input to the operation. </param>
        /// <param name="last_hit_step">Input to the operation. </param>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="table_id">table id</param>
        /// <param name="table_name">table name</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation LoadTPUEmbeddingFrequencyEstimatorParameters(Output parameters, Output last_hit_step, long num_shards, long shard_id, long table_id = -1, string table_name = null, string config = null, String opName = "LoadTPUEmbeddingFrequencyEstimatorParameters") 
        {
            OperationDescription desc = NewOperation("LoadTPUEmbeddingFrequencyEstimatorParameters", opName);
            desc.AddInput(parameters);
            desc.AddInput(last_hit_step);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            if (table_id != -1)
                desc.SetAttr("table_id", table_id);
            if (table_name != null)
                 desc.SetAttr("table_name", table_name);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LoadTPUEmbeddingFTRLParameters
        /// </summary>
        /// <param name="parameters">Input to the operation. </param>
        /// <param name="accumulators">Input to the operation. </param>
        /// <param name="linears">Input to the operation. </param>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="table_id">table id</param>
        /// <param name="table_name">table name</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation LoadTPUEmbeddingFTRLParameters(Output parameters, Output accumulators, Output linears, long num_shards, long shard_id, long table_id = -1, string table_name = null, string config = null, String opName = "LoadTPUEmbeddingFTRLParameters") 
        {
            OperationDescription desc = NewOperation("LoadTPUEmbeddingFTRLParameters", opName);
            desc.AddInput(parameters);
            desc.AddInput(accumulators);
            desc.AddInput(linears);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            if (table_id != -1)
                desc.SetAttr("table_id", table_id);
            if (table_name != null)
                 desc.SetAttr("table_name", table_name);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LoadTPUEmbeddingMDLAdagradLightParameters
        /// </summary>
        /// <param name="parameters">Input to the operation. </param>
        /// <param name="accumulators">Input to the operation. </param>
        /// <param name="weights">Input to the operation. </param>
        /// <param name="benefits">Input to the operation. </param>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="table_id">table id</param>
        /// <param name="table_name">table name</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation LoadTPUEmbeddingMDLAdagradLightParameters(Output parameters, Output accumulators, Output weights, Output benefits, long num_shards, long shard_id, long table_id = -1, string table_name = null, string config = null, String opName = "LoadTPUEmbeddingMDLAdagradLightParameters") 
        {
            OperationDescription desc = NewOperation("LoadTPUEmbeddingMDLAdagradLightParameters", opName);
            desc.AddInput(parameters);
            desc.AddInput(accumulators);
            desc.AddInput(weights);
            desc.AddInput(benefits);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            if (table_id != -1)
                desc.SetAttr("table_id", table_id);
            if (table_name != null)
                 desc.SetAttr("table_name", table_name);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LoadTPUEmbeddingMomentumParameters
        /// </summary>
        /// <param name="parameters">Input to the operation. </param>
        /// <param name="momenta">Input to the operation. </param>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="table_id">table id</param>
        /// <param name="table_name">table name</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation LoadTPUEmbeddingMomentumParameters(Output parameters, Output momenta, long num_shards, long shard_id, long table_id = -1, string table_name = null, string config = null, String opName = "LoadTPUEmbeddingMomentumParameters") 
        {
            OperationDescription desc = NewOperation("LoadTPUEmbeddingMomentumParameters", opName);
            desc.AddInput(parameters);
            desc.AddInput(momenta);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            if (table_id != -1)
                desc.SetAttr("table_id", table_id);
            if (table_name != null)
                 desc.SetAttr("table_name", table_name);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LoadTPUEmbeddingProximalAdagradParameters
        /// </summary>
        /// <param name="parameters">Input to the operation. </param>
        /// <param name="accumulators">Input to the operation. </param>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="table_id">table id</param>
        /// <param name="table_name">table name</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation LoadTPUEmbeddingProximalAdagradParameters(Output parameters, Output accumulators, long num_shards, long shard_id, long table_id = -1, string table_name = null, string config = null, String opName = "LoadTPUEmbeddingProximalAdagradParameters") 
        {
            OperationDescription desc = NewOperation("LoadTPUEmbeddingProximalAdagradParameters", opName);
            desc.AddInput(parameters);
            desc.AddInput(accumulators);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            if (table_id != -1)
                desc.SetAttr("table_id", table_id);
            if (table_name != null)
                 desc.SetAttr("table_name", table_name);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LoadTPUEmbeddingProximalYogiParameters
        /// </summary>
        /// <param name="parameters">Input to the operation. </param>
        /// <param name="v">Input to the operation. </param>
        /// <param name="m">Input to the operation. </param>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="table_id">table id</param>
        /// <param name="table_name">table name</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation LoadTPUEmbeddingProximalYogiParameters(Output parameters, Output v, Output m, long num_shards, long shard_id, long table_id = -1, string table_name = null, string config = null, String opName = "LoadTPUEmbeddingProximalYogiParameters") 
        {
            OperationDescription desc = NewOperation("LoadTPUEmbeddingProximalYogiParameters", opName);
            desc.AddInput(parameters);
            desc.AddInput(v);
            desc.AddInput(m);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            if (table_id != -1)
                desc.SetAttr("table_id", table_id);
            if (table_name != null)
                 desc.SetAttr("table_name", table_name);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LoadTPUEmbeddingRMSPropParameters
        /// </summary>
        /// <param name="parameters">Input to the operation. </param>
        /// <param name="ms">Input to the operation. </param>
        /// <param name="mom">Input to the operation. </param>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="table_id">table id</param>
        /// <param name="table_name">table name</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation LoadTPUEmbeddingRMSPropParameters(Output parameters, Output ms, Output mom, long num_shards, long shard_id, long table_id = -1, string table_name = null, string config = null, String opName = "LoadTPUEmbeddingRMSPropParameters") 
        {
            OperationDescription desc = NewOperation("LoadTPUEmbeddingRMSPropParameters", opName);
            desc.AddInput(parameters);
            desc.AddInput(ms);
            desc.AddInput(mom);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            if (table_id != -1)
                desc.SetAttr("table_id", table_id);
            if (table_name != null)
                 desc.SetAttr("table_name", table_name);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LoadTPUEmbeddingStochasticGradientDescentParameters
        /// </summary>
        /// <param name="parameters">Input to the operation. </param>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="table_id">table id</param>
        /// <param name="table_name">table name</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation LoadTPUEmbeddingStochasticGradientDescentParameters(Output parameters, long num_shards, long shard_id, long table_id = -1, string table_name = null, string config = null, String opName = "LoadTPUEmbeddingStochasticGradientDescentParameters") 
        {
            OperationDescription desc = NewOperation("LoadTPUEmbeddingStochasticGradientDescentParameters", opName);
            desc.AddInput(parameters);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            if (table_id != -1)
                desc.SetAttr("table_id", table_id);
            if (table_name != null)
                 desc.SetAttr("table_name", table_name);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Log
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Log(Output x, String opName = "Log") 
        {
            OperationDescription desc = NewOperation("Log", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Log1p
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Log1p(Output x, String opName = "Log1p") 
        {
            OperationDescription desc = NewOperation("Log1p", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LogicalAnd
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtBool).
        /// </returns>
        public Operation LogicalAnd(Output x, Output y, String opName = "LogicalAnd") 
        {
            OperationDescription desc = NewOperation("LogicalAnd", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LogicalNot
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtBool).
        /// </returns>
        public Operation LogicalNot(Output x, String opName = "LogicalNot") 
        {
            OperationDescription desc = NewOperation("LogicalNot", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LogicalOr
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtBool).
        /// </returns>
        public Operation LogicalOr(Output x, Output y, String opName = "LogicalOr") 
        {
            OperationDescription desc = NewOperation("LogicalOr", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LogMatrixDeterminant
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] sign(type: DtInvalid).
        /// [1] log_abs_determinant(type: DtInvalid).
        /// </returns>
        public Operation LogMatrixDeterminant(Output input, String opName = "LogMatrixDeterminant") 
        {
            OperationDescription desc = NewOperation("LogMatrixDeterminant", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LogSoftmax
        /// </summary>
        /// <param name="logits">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] logsoftmax(type: DtInvalid).
        /// </returns>
        public Operation LogSoftmax(Output logits, String opName = "LogSoftmax") 
        {
            OperationDescription desc = NewOperation("LogSoftmax", opName);
            desc.AddInput(logits);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LogUniformCandidateSampler
        /// </summary>
        /// <param name="true_classes">Input to the operation. </param>
        /// <param name="num_true">num true</param>
        /// <param name="num_sampled">num sampled</param>
        /// <param name="unique">unique</param>
        /// <param name="range_max">range max</param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] sampled_candidates(type: DtInt64).
        /// [1] true_expected_count(type: DtFloat).
        /// [2] sampled_expected_count(type: DtFloat).
        /// </returns>
        public Operation LogUniformCandidateSampler(Output true_classes, long num_true, long num_sampled, bool unique, long range_max, long seed = 0, long seed2 = 0, String opName = "LogUniformCandidateSampler") 
        {
            OperationDescription desc = NewOperation("LogUniformCandidateSampler", opName);
            desc.AddInput(true_classes);
            desc.SetAttr("num_true", num_true);
            desc.SetAttr("num_sampled", num_sampled);
            desc.SetAttr("unique", unique);
            desc.SetAttr("range_max", range_max);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LookupTableExport
        /// </summary>
        /// <param name="table_handle">Input to the operation. </param>
        /// <param name="Tkeys">Tkeys</param>
        /// <param name="Tvalues">Tvalues</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] keys(type: DtInvalid).
        /// [1] values(type: DtInvalid).
        /// </returns>
        public Operation LookupTableExport(Output table_handle, DataType Tkeys, DataType Tvalues, String opName = "LookupTableExport") 
        {
            OperationDescription desc = NewOperation("LookupTableExport", opName);
            desc.AddInput(table_handle);
            desc.SetAttr("Tkeys", Tkeys);
            desc.SetAttr("Tvalues", Tvalues);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LookupTableExportV2
        /// </summary>
        /// <param name="table_handle">Input to the operation. </param>
        /// <param name="Tkeys">Tkeys</param>
        /// <param name="Tvalues">Tvalues</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] keys(type: DtInvalid).
        /// [1] values(type: DtInvalid).
        /// </returns>
        public Operation LookupTableExportV2(Output table_handle, DataType Tkeys, DataType Tvalues, String opName = "LookupTableExportV2") 
        {
            OperationDescription desc = NewOperation("LookupTableExportV2", opName);
            desc.AddInput(table_handle);
            desc.SetAttr("Tkeys", Tkeys);
            desc.SetAttr("Tvalues", Tvalues);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LookupTableFind
        /// </summary>
        /// <param name="table_handle">Input to the operation. </param>
        /// <param name="keys">Input to the operation. </param>
        /// <param name="default_value">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] values(type: DtInvalid).
        /// </returns>
        public Operation LookupTableFind(Output table_handle, Output keys, Output default_value, String opName = "LookupTableFind") 
        {
            OperationDescription desc = NewOperation("LookupTableFind", opName);
            desc.AddInput(table_handle);
            desc.AddInput(keys);
            desc.AddInput(default_value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LookupTableFindV2
        /// </summary>
        /// <param name="table_handle">Input to the operation. </param>
        /// <param name="keys">Input to the operation. </param>
        /// <param name="default_value">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] values(type: DtInvalid).
        /// </returns>
        public Operation LookupTableFindV2(Output table_handle, Output keys, Output default_value, String opName = "LookupTableFindV2") 
        {
            OperationDescription desc = NewOperation("LookupTableFindV2", opName);
            desc.AddInput(table_handle);
            desc.AddInput(keys);
            desc.AddInput(default_value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LookupTableImport
        /// </summary>
        /// <param name="table_handle">Input to the operation. </param>
        /// <param name="keys">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation LookupTableImport(Output table_handle, Output keys, Output values, String opName = "LookupTableImport") 
        {
            OperationDescription desc = NewOperation("LookupTableImport", opName);
            desc.AddInput(table_handle);
            desc.AddInput(keys);
            desc.AddInput(values);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LookupTableImportV2
        /// </summary>
        /// <param name="table_handle">Input to the operation. </param>
        /// <param name="keys">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation LookupTableImportV2(Output table_handle, Output keys, Output values, String opName = "LookupTableImportV2") 
        {
            OperationDescription desc = NewOperation("LookupTableImportV2", opName);
            desc.AddInput(table_handle);
            desc.AddInput(keys);
            desc.AddInput(values);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LookupTableInsert
        /// </summary>
        /// <param name="table_handle">Input to the operation. </param>
        /// <param name="keys">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation LookupTableInsert(Output table_handle, Output keys, Output values, String opName = "LookupTableInsert") 
        {
            OperationDescription desc = NewOperation("LookupTableInsert", opName);
            desc.AddInput(table_handle);
            desc.AddInput(keys);
            desc.AddInput(values);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LookupTableInsertV2
        /// </summary>
        /// <param name="table_handle">Input to the operation. </param>
        /// <param name="keys">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation LookupTableInsertV2(Output table_handle, Output keys, Output values, String opName = "LookupTableInsertV2") 
        {
            OperationDescription desc = NewOperation("LookupTableInsertV2", opName);
            desc.AddInput(table_handle);
            desc.AddInput(keys);
            desc.AddInput(values);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LookupTableRemoveV2
        /// </summary>
        /// <param name="table_handle">Input to the operation. </param>
        /// <param name="keys">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation LookupTableRemoveV2(Output table_handle, Output keys, String opName = "LookupTableRemoveV2") 
        {
            OperationDescription desc = NewOperation("LookupTableRemoveV2", opName);
            desc.AddInput(table_handle);
            desc.AddInput(keys);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LookupTableSize
        /// </summary>
        /// <param name="table_handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] size(type: DtInt64).
        /// </returns>
        public Operation LookupTableSize(Output table_handle, String opName = "LookupTableSize") 
        {
            OperationDescription desc = NewOperation("LookupTableSize", opName);
            desc.AddInput(table_handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LookupTableSizeV2
        /// </summary>
        /// <param name="table_handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] size(type: DtInt64).
        /// </returns>
        public Operation LookupTableSizeV2(Output table_handle, String opName = "LookupTableSizeV2") 
        {
            OperationDescription desc = NewOperation("LookupTableSizeV2", opName);
            desc.AddInput(table_handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LoopCond
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtBool).
        /// </returns>
        public Operation LoopCond(Output input, String opName = "LoopCond") 
        {
            OperationDescription desc = NewOperation("LoopCond", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LowerBound
        /// </summary>
        /// <param name="sorted_inputs">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="out_type">out type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation LowerBound(Output sorted_inputs, Output values, DataType? out_type = null, String opName = "LowerBound") 
        {
            OperationDescription desc = NewOperation("LowerBound", opName);
            desc.AddInput(sorted_inputs);
            desc.AddInput(values);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LRN
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="depth_radius">depth radius</param>
        /// <param name="bias">bias</param>
        /// <param name="alpha">alpha</param>
        /// <param name="beta">beta</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation LRN(Output input, long depth_radius = 5, float bias = 1f, float alpha = 1f, float beta = 0.5f, String opName = "LRN") 
        {
            OperationDescription desc = NewOperation("LRN", opName);
            desc.AddInput(input);
            if (depth_radius != 5)
                desc.SetAttr("depth_radius", depth_radius);
            if (bias != 1f)
                desc.SetAttr("bias", bias);
            if (alpha != 1f)
                desc.SetAttr("alpha", alpha);
            if (beta != 0.5f)
                desc.SetAttr("beta", beta);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LRNGrad
        /// </summary>
        /// <param name="input_grads">Input to the operation. </param>
        /// <param name="input_image">Input to the operation. </param>
        /// <param name="output_image">Input to the operation. </param>
        /// <param name="depth_radius">depth radius</param>
        /// <param name="bias">bias</param>
        /// <param name="alpha">alpha</param>
        /// <param name="beta">beta</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation LRNGrad(Output input_grads, Output input_image, Output output_image, long depth_radius = 5, float bias = 1f, float alpha = 1f, float beta = 0.5f, String opName = "LRNGrad") 
        {
            OperationDescription desc = NewOperation("LRNGrad", opName);
            desc.AddInput(input_grads);
            desc.AddInput(input_image);
            desc.AddInput(output_image);
            if (depth_radius != 5)
                desc.SetAttr("depth_radius", depth_radius);
            if (bias != 1f)
                desc.SetAttr("bias", bias);
            if (alpha != 1f)
                desc.SetAttr("alpha", alpha);
            if (beta != 0.5f)
                desc.SetAttr("beta", beta);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LSTMBlockCell
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="cs_prev">Input to the operation. </param>
        /// <param name="h_prev">Input to the operation. </param>
        /// <param name="w">Input to the operation. </param>
        /// <param name="wci">Input to the operation. </param>
        /// <param name="wcf">Input to the operation. </param>
        /// <param name="wco">Input to the operation. </param>
        /// <param name="b">Input to the operation. </param>
        /// <param name="forget_bias">forget bias</param>
        /// <param name="cell_clip">cell clip</param>
        /// <param name="use_peephole">use peephole</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] i(type: DtInvalid).
        /// [1] cs(type: DtInvalid).
        /// [2] f(type: DtInvalid).
        /// [3] o(type: DtInvalid).
        /// [4] ci(type: DtInvalid).
        /// [5] co(type: DtInvalid).
        /// [6] h(type: DtInvalid).
        /// </returns>
        public Operation LSTMBlockCell(Output x, Output cs_prev, Output h_prev, Output w, Output wci, Output wcf, Output wco, Output b, float forget_bias = 1f, float cell_clip = 3f, bool use_peephole = false, String opName = "LSTMBlockCell") 
        {
            OperationDescription desc = NewOperation("LSTMBlockCell", opName);
            desc.AddInput(x);
            desc.AddInput(cs_prev);
            desc.AddInput(h_prev);
            desc.AddInput(w);
            desc.AddInput(wci);
            desc.AddInput(wcf);
            desc.AddInput(wco);
            desc.AddInput(b);
            if (forget_bias != 1f)
                desc.SetAttr("forget_bias", forget_bias);
            if (cell_clip != 3f)
                desc.SetAttr("cell_clip", cell_clip);
            if (use_peephole != false)
                desc.SetAttr("use_peephole", use_peephole);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// LSTMBlockCellGrad
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="cs_prev">Input to the operation. </param>
        /// <param name="h_prev">Input to the operation. </param>
        /// <param name="w">Input to the operation. </param>
        /// <param name="wci">Input to the operation. </param>
        /// <param name="wcf">Input to the operation. </param>
        /// <param name="wco">Input to the operation. </param>
        /// <param name="b">Input to the operation. </param>
        /// <param name="i">Input to the operation. </param>
        /// <param name="cs">Input to the operation. </param>
        /// <param name="f">Input to the operation. </param>
        /// <param name="o">Input to the operation. </param>
        /// <param name="ci">Input to the operation. </param>
        /// <param name="co">Input to the operation. </param>
        /// <param name="cs_grad">Input to the operation. </param>
        /// <param name="h_grad">Input to the operation. </param>
        /// <param name="use_peephole">use peephole</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] cs_prev_grad(type: DtInvalid).
        /// [1] dicfo(type: DtInvalid).
        /// [2] wci_grad(type: DtInvalid).
        /// [3] wcf_grad(type: DtInvalid).
        /// [4] wco_grad(type: DtInvalid).
        /// </returns>
        public Operation LSTMBlockCellGrad(Output x, Output cs_prev, Output h_prev, Output w, Output wci, Output wcf, Output wco, Output b, Output i, Output cs, Output f, Output o, Output ci, Output co, Output cs_grad, Output h_grad, bool use_peephole, String opName = "LSTMBlockCellGrad") 
        {
            OperationDescription desc = NewOperation("LSTMBlockCellGrad", opName);
            desc.AddInput(x);
            desc.AddInput(cs_prev);
            desc.AddInput(h_prev);
            desc.AddInput(w);
            desc.AddInput(wci);
            desc.AddInput(wcf);
            desc.AddInput(wco);
            desc.AddInput(b);
            desc.AddInput(i);
            desc.AddInput(cs);
            desc.AddInput(f);
            desc.AddInput(o);
            desc.AddInput(ci);
            desc.AddInput(co);
            desc.AddInput(cs_grad);
            desc.AddInput(h_grad);
            desc.SetAttr("use_peephole", use_peephole);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Lu
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="output_idx_type">output idx type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] lu(type: DtInvalid).
        /// [1] p(type: DtInvalid).
        /// </returns>
        public Operation Lu(Output input, DataType? output_idx_type = null, String opName = "Lu") 
        {
            OperationDescription desc = NewOperation("Lu", opName);
            desc.AddInput(input);
            if (output_idx_type.HasValue)
                desc.SetAttr("output_idx_type", output_idx_type.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MakeIterator
        /// </summary>
        /// <param name="dataset">Input to the operation. </param>
        /// <param name="iterator">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation MakeIterator(Output dataset, Output iterator, String opName = "MakeIterator") 
        {
            OperationDescription desc = NewOperation("MakeIterator", opName);
            desc.AddInput(dataset);
            desc.AddInput(iterator);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MakeUnique
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtFloat).
        /// </returns>
        public Operation MakeUnique(Output input, String opName = "MakeUnique") 
        {
            OperationDescription desc = NewOperation("MakeUnique", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MapAndBatchDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="other_arguments">Input to the operation. </param>
        /// <param name="batch_size">Input to the operation. </param>
        /// <param name="num_parallel_calls">Input to the operation. </param>
        /// <param name="drop_remainder">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="preserve_cardinality">preserve cardinality</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: f: func
        public Operation MapAndBatchDataset(Output input_dataset, Output other_arguments, Output batch_size, Output num_parallel_calls, Output drop_remainder, DataType[] output_types, long[][] output_shapes, bool preserve_cardinality = false, string metadata = null, String opName = "MapAndBatchDataset") 
        {
            OperationDescription desc = NewOperation("MapAndBatchDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(other_arguments);
            desc.AddInput(batch_size);
            desc.AddInput(num_parallel_calls);
            desc.AddInput(drop_remainder);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (preserve_cardinality != false)
                desc.SetAttr("preserve_cardinality", preserve_cardinality);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MapClear
        /// </summary>
        /// <param name="dtypes">dtypes</param>
        /// <param name="capacity">capacity</param>
        /// <param name="memory_limit">memory limit</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation MapClear(DataType[] dtypes, long capacity = 0, long memory_limit = 0, string container = null, string shared_name = null, String opName = "MapClear") 
        {
            OperationDescription desc = NewOperation("MapClear", opName);
            desc.SetAttr("dtypes", dtypes);
            if (capacity != 0)
                desc.SetAttr("capacity", capacity);
            if (memory_limit != 0)
                desc.SetAttr("memory_limit", memory_limit);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MapDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="other_arguments">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="use_inter_op_parallelism">use inter op parallelism</param>
        /// <param name="preserve_cardinality">preserve cardinality</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: f: func
        public Operation MapDataset(Output input_dataset, Output other_arguments, DataType[] output_types, long[][] output_shapes, bool use_inter_op_parallelism = true, bool preserve_cardinality = false, string metadata = null, String opName = "MapDataset") 
        {
            OperationDescription desc = NewOperation("MapDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(other_arguments);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (use_inter_op_parallelism != true)
                desc.SetAttr("use_inter_op_parallelism", use_inter_op_parallelism);
            if (preserve_cardinality != false)
                desc.SetAttr("preserve_cardinality", preserve_cardinality);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MapDefun
        /// </summary>
        /// <param name="arguments">Input to the operation. </param>
        /// <param name="captured_inputs">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="max_intra_op_parallelism">max intra op parallelism</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        // The following attributes are not known: f: func
        public Operation MapDefun(Output arguments, Output captured_inputs, DataType[] output_types, long[][] output_shapes, long max_intra_op_parallelism = 1, String opName = "MapDefun") 
        {
            OperationDescription desc = NewOperation("MapDefun", opName);
            desc.AddInput(arguments);
            desc.AddInput(captured_inputs);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (max_intra_op_parallelism != 1)
                desc.SetAttr("max_intra_op_parallelism", max_intra_op_parallelism);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MapIncompleteSize
        /// </summary>
        /// <param name="dtypes">dtypes</param>
        /// <param name="capacity">capacity</param>
        /// <param name="memory_limit">memory limit</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] size(type: DtInt32).
        /// </returns>
        public Operation MapIncompleteSize(DataType[] dtypes, long capacity = 0, long memory_limit = 0, string container = null, string shared_name = null, String opName = "MapIncompleteSize") 
        {
            OperationDescription desc = NewOperation("MapIncompleteSize", opName);
            desc.SetAttr("dtypes", dtypes);
            if (capacity != 0)
                desc.SetAttr("capacity", capacity);
            if (memory_limit != 0)
                desc.SetAttr("memory_limit", memory_limit);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MapPeek
        /// </summary>
        /// <param name="key">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="dtypes">dtypes</param>
        /// <param name="capacity">capacity</param>
        /// <param name="memory_limit">memory limit</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] values(type: DtInvalid).
        /// </returns>
        public Operation MapPeek(Output key, Output indices, DataType[] dtypes, long capacity = 0, long memory_limit = 0, string container = null, string shared_name = null, String opName = "MapPeek") 
        {
            OperationDescription desc = NewOperation("MapPeek", opName);
            desc.AddInput(key);
            desc.AddInput(indices);
            desc.SetAttr("dtypes", dtypes);
            if (capacity != 0)
                desc.SetAttr("capacity", capacity);
            if (memory_limit != 0)
                desc.SetAttr("memory_limit", memory_limit);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MapSize
        /// </summary>
        /// <param name="dtypes">dtypes</param>
        /// <param name="capacity">capacity</param>
        /// <param name="memory_limit">memory limit</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] size(type: DtInt32).
        /// </returns>
        public Operation MapSize(DataType[] dtypes, long capacity = 0, long memory_limit = 0, string container = null, string shared_name = null, String opName = "MapSize") 
        {
            OperationDescription desc = NewOperation("MapSize", opName);
            desc.SetAttr("dtypes", dtypes);
            if (capacity != 0)
                desc.SetAttr("capacity", capacity);
            if (memory_limit != 0)
                desc.SetAttr("memory_limit", memory_limit);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MapStage
        /// </summary>
        /// <param name="key">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="dtypes">dtypes</param>
        /// <param name="capacity">capacity</param>
        /// <param name="memory_limit">memory limit</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation MapStage(Output key, Output indices, Output values, DataType[] dtypes, long capacity = 0, long memory_limit = 0, string container = null, string shared_name = null, String opName = "MapStage") 
        {
            OperationDescription desc = NewOperation("MapStage", opName);
            desc.AddInput(key);
            desc.AddInput(indices);
            desc.AddInput(values);
            desc.SetAttr("dtypes", dtypes);
            if (capacity != 0)
                desc.SetAttr("capacity", capacity);
            if (memory_limit != 0)
                desc.SetAttr("memory_limit", memory_limit);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MapUnstage
        /// </summary>
        /// <param name="key">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="dtypes">dtypes</param>
        /// <param name="capacity">capacity</param>
        /// <param name="memory_limit">memory limit</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] values(type: DtInvalid).
        /// </returns>
        public Operation MapUnstage(Output key, Output indices, DataType[] dtypes, long capacity = 0, long memory_limit = 0, string container = null, string shared_name = null, String opName = "MapUnstage") 
        {
            OperationDescription desc = NewOperation("MapUnstage", opName);
            desc.AddInput(key);
            desc.AddInput(indices);
            desc.SetAttr("dtypes", dtypes);
            if (capacity != 0)
                desc.SetAttr("capacity", capacity);
            if (memory_limit != 0)
                desc.SetAttr("memory_limit", memory_limit);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MapUnstageNoKey
        /// </summary>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="dtypes">dtypes</param>
        /// <param name="capacity">capacity</param>
        /// <param name="memory_limit">memory limit</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] key(type: DtInt64).
        /// [1] values(type: DtInvalid).
        /// </returns>
        public Operation MapUnstageNoKey(Output indices, DataType[] dtypes, long capacity = 0, long memory_limit = 0, string container = null, string shared_name = null, String opName = "MapUnstageNoKey") 
        {
            OperationDescription desc = NewOperation("MapUnstageNoKey", opName);
            desc.AddInput(indices);
            desc.SetAttr("dtypes", dtypes);
            if (capacity != 0)
                desc.SetAttr("capacity", capacity);
            if (memory_limit != 0)
                desc.SetAttr("memory_limit", memory_limit);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MatchingFiles
        /// </summary>
        /// <param name="pattern">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] filenames(type: DtString).
        /// </returns>
        public Operation MatchingFiles(Output pattern, String opName = "MatchingFiles") 
        {
            OperationDescription desc = NewOperation("MatchingFiles", opName);
            desc.AddInput(pattern);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MatchingFilesDataset
        /// </summary>
        /// <param name="patterns">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation MatchingFilesDataset(Output patterns, String opName = "MatchingFilesDataset") 
        {
            OperationDescription desc = NewOperation("MatchingFilesDataset", opName);
            desc.AddInput(patterns);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MatMul
        /// </summary>
        /// <param name="a">Input to the operation. </param>
        /// <param name="b">Input to the operation. </param>
        /// <param name="transpose_a">transpose a</param>
        /// <param name="transpose_b">transpose b</param>
        /// <param name="grad_a">grad a</param>
        /// <param name="grad_b">grad b</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] product(type: DtInvalid).
        /// </returns>
        public Operation MatMul(Output a, Output b, bool transpose_a = false, bool transpose_b = false, bool grad_a = false, bool grad_b = false, String opName = "MatMul") 
        {
            OperationDescription desc = NewOperation("MatMul", opName);
            desc.AddInput(a);
            desc.AddInput(b);
            if (transpose_a != false)
                desc.SetAttr("transpose_a", transpose_a);
            if (transpose_b != false)
                desc.SetAttr("transpose_b", transpose_b);
            if (grad_a != false)
                desc.SetAttr("grad_a", grad_a);
            if (grad_b != false)
                desc.SetAttr("grad_b", grad_b);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MatrixBandPart
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="num_lower">Input to the operation. </param>
        /// <param name="num_upper">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] band(type: DtInvalid).
        /// </returns>
        public Operation MatrixBandPart(Output input, Output num_lower, Output num_upper, String opName = "MatrixBandPart") 
        {
            OperationDescription desc = NewOperation("MatrixBandPart", opName);
            desc.AddInput(input);
            desc.AddInput(num_lower);
            desc.AddInput(num_upper);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MatrixDeterminant
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation MatrixDeterminant(Output input, String opName = "MatrixDeterminant") 
        {
            OperationDescription desc = NewOperation("MatrixDeterminant", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MatrixDiag
        /// </summary>
        /// <param name="diagonal">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation MatrixDiag(Output diagonal, String opName = "MatrixDiag") 
        {
            OperationDescription desc = NewOperation("MatrixDiag", opName);
            desc.AddInput(diagonal);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MatrixDiagPart
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] diagonal(type: DtInvalid).
        /// </returns>
        public Operation MatrixDiagPart(Output input, String opName = "MatrixDiagPart") 
        {
            OperationDescription desc = NewOperation("MatrixDiagPart", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MatrixDiagPartV2
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="k">Input to the operation. </param>
        /// <param name="padding_value">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] diagonal(type: DtInvalid).
        /// </returns>
        public Operation MatrixDiagPartV2(Output input, Output k, Output padding_value, String opName = "MatrixDiagPartV2") 
        {
            OperationDescription desc = NewOperation("MatrixDiagPartV2", opName);
            desc.AddInput(input);
            desc.AddInput(k);
            desc.AddInput(padding_value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MatrixDiagPartV3
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="k">Input to the operation. </param>
        /// <param name="padding_value">Input to the operation. </param>
        /// <param name="align">align</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] diagonal(type: DtInvalid).
        /// </returns>
        public Operation MatrixDiagPartV3(Output input, Output k, Output padding_value, string align = null, String opName = "MatrixDiagPartV3") 
        {
            OperationDescription desc = NewOperation("MatrixDiagPartV3", opName);
            desc.AddInput(input);
            desc.AddInput(k);
            desc.AddInput(padding_value);
            if (align != null)
                 desc.SetAttr("align", align);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MatrixDiagV2
        /// </summary>
        /// <param name="diagonal">Input to the operation. </param>
        /// <param name="k">Input to the operation. </param>
        /// <param name="num_rows">Input to the operation. </param>
        /// <param name="num_cols">Input to the operation. </param>
        /// <param name="padding_value">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation MatrixDiagV2(Output diagonal, Output k, Output num_rows, Output num_cols, Output padding_value, String opName = "MatrixDiagV2") 
        {
            OperationDescription desc = NewOperation("MatrixDiagV2", opName);
            desc.AddInput(diagonal);
            desc.AddInput(k);
            desc.AddInput(num_rows);
            desc.AddInput(num_cols);
            desc.AddInput(padding_value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MatrixDiagV3
        /// </summary>
        /// <param name="diagonal">Input to the operation. </param>
        /// <param name="k">Input to the operation. </param>
        /// <param name="num_rows">Input to the operation. </param>
        /// <param name="num_cols">Input to the operation. </param>
        /// <param name="padding_value">Input to the operation. </param>
        /// <param name="align">align</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation MatrixDiagV3(Output diagonal, Output k, Output num_rows, Output num_cols, Output padding_value, string align = null, String opName = "MatrixDiagV3") 
        {
            OperationDescription desc = NewOperation("MatrixDiagV3", opName);
            desc.AddInput(diagonal);
            desc.AddInput(k);
            desc.AddInput(num_rows);
            desc.AddInput(num_cols);
            desc.AddInput(padding_value);
            if (align != null)
                 desc.SetAttr("align", align);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MatrixExponential
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation MatrixExponential(Output input, String opName = "MatrixExponential") 
        {
            OperationDescription desc = NewOperation("MatrixExponential", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MatrixInverse
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="adjoint">adjoint</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation MatrixInverse(Output input, bool adjoint = false, String opName = "MatrixInverse") 
        {
            OperationDescription desc = NewOperation("MatrixInverse", opName);
            desc.AddInput(input);
            if (adjoint != false)
                desc.SetAttr("adjoint", adjoint);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MatrixLogarithm
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation MatrixLogarithm(Output input, String opName = "MatrixLogarithm") 
        {
            OperationDescription desc = NewOperation("MatrixLogarithm", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MatrixSetDiag
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="diagonal">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation MatrixSetDiag(Output input, Output diagonal, String opName = "MatrixSetDiag") 
        {
            OperationDescription desc = NewOperation("MatrixSetDiag", opName);
            desc.AddInput(input);
            desc.AddInput(diagonal);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MatrixSetDiagV2
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="diagonal">Input to the operation. </param>
        /// <param name="k">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation MatrixSetDiagV2(Output input, Output diagonal, Output k, String opName = "MatrixSetDiagV2") 
        {
            OperationDescription desc = NewOperation("MatrixSetDiagV2", opName);
            desc.AddInput(input);
            desc.AddInput(diagonal);
            desc.AddInput(k);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MatrixSetDiagV3
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="diagonal">Input to the operation. </param>
        /// <param name="k">Input to the operation. </param>
        /// <param name="align">align</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation MatrixSetDiagV3(Output input, Output diagonal, Output k, string align = null, String opName = "MatrixSetDiagV3") 
        {
            OperationDescription desc = NewOperation("MatrixSetDiagV3", opName);
            desc.AddInput(input);
            desc.AddInput(diagonal);
            desc.AddInput(k);
            if (align != null)
                 desc.SetAttr("align", align);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MatrixSolve
        /// </summary>
        /// <param name="matrix">Input to the operation. </param>
        /// <param name="rhs">Input to the operation. </param>
        /// <param name="adjoint">adjoint</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation MatrixSolve(Output matrix, Output rhs, bool adjoint = false, String opName = "MatrixSolve") 
        {
            OperationDescription desc = NewOperation("MatrixSolve", opName);
            desc.AddInput(matrix);
            desc.AddInput(rhs);
            if (adjoint != false)
                desc.SetAttr("adjoint", adjoint);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MatrixSolveLs
        /// </summary>
        /// <param name="matrix">Input to the operation. </param>
        /// <param name="rhs">Input to the operation. </param>
        /// <param name="l2_regularizer">Input to the operation. </param>
        /// <param name="fast">fast</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation MatrixSolveLs(Output matrix, Output rhs, Output l2_regularizer, bool fast = true, String opName = "MatrixSolveLs") 
        {
            OperationDescription desc = NewOperation("MatrixSolveLs", opName);
            desc.AddInput(matrix);
            desc.AddInput(rhs);
            desc.AddInput(l2_regularizer);
            if (fast != true)
                desc.SetAttr("fast", fast);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MatrixSquareRoot
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation MatrixSquareRoot(Output input, String opName = "MatrixSquareRoot") 
        {
            OperationDescription desc = NewOperation("MatrixSquareRoot", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MatrixTriangularSolve
        /// </summary>
        /// <param name="matrix">Input to the operation. </param>
        /// <param name="rhs">Input to the operation. </param>
        /// <param name="lower">lower</param>
        /// <param name="adjoint">adjoint</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation MatrixTriangularSolve(Output matrix, Output rhs, bool lower = true, bool adjoint = false, String opName = "MatrixTriangularSolve") 
        {
            OperationDescription desc = NewOperation("MatrixTriangularSolve", opName);
            desc.AddInput(matrix);
            desc.AddInput(rhs);
            if (lower != true)
                desc.SetAttr("lower", lower);
            if (adjoint != false)
                desc.SetAttr("adjoint", adjoint);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Max
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="reduction_indices">Input to the operation. </param>
        /// <param name="keep_dims">keep dims</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Max(Output input, Output reduction_indices, bool keep_dims = false, String opName = "Max") 
        {
            OperationDescription desc = NewOperation("Max", opName);
            desc.AddInput(input);
            desc.AddInput(reduction_indices);
            if (keep_dims != false)
                desc.SetAttr("keep_dims", keep_dims);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Maximum
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation Maximum(Output x, Output y, String opName = "Maximum") 
        {
            OperationDescription desc = NewOperation("Maximum", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MaxIntraOpParallelismDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="max_intra_op_parallelism">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation MaxIntraOpParallelismDataset(Output input_dataset, Output max_intra_op_parallelism, DataType[] output_types, long[][] output_shapes, String opName = "MaxIntraOpParallelismDataset") 
        {
            OperationDescription desc = NewOperation("MaxIntraOpParallelismDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(max_intra_op_parallelism);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MaxPool
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="ksize">ksize</param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="explicit_paddings">explicit paddings</param>
        /// <param name="data_format">data format</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation MaxPool(Output input, long[] ksize, long[] strides, string padding, long[] explicit_paddings = null, string data_format = null, String opName = "MaxPool") 
        {
            OperationDescription desc = NewOperation("MaxPool", opName);
            desc.AddInput(input);
            desc.SetAttr("ksize", ksize);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (explicit_paddings != null) desc.SetAttr("explicit_paddings", explicit_paddings);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MaxPool3D
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="ksize">ksize</param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="data_format">data format</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation MaxPool3D(Output input, long[] ksize, long[] strides, string padding, string data_format = null, String opName = "MaxPool3D") 
        {
            OperationDescription desc = NewOperation("MaxPool3D", opName);
            desc.AddInput(input);
            desc.SetAttr("ksize", ksize);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MaxPool3DGrad
        /// </summary>
        /// <param name="orig_input">Input to the operation. </param>
        /// <param name="orig_output">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="ksize">ksize</param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="data_format">data format</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation MaxPool3DGrad(Output orig_input, Output orig_output, Output grad, long[] ksize, long[] strides, string padding, string data_format = null, String opName = "MaxPool3DGrad") 
        {
            OperationDescription desc = NewOperation("MaxPool3DGrad", opName);
            desc.AddInput(orig_input);
            desc.AddInput(orig_output);
            desc.AddInput(grad);
            desc.SetAttr("ksize", ksize);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MaxPool3DGradGrad
        /// </summary>
        /// <param name="orig_input">Input to the operation. </param>
        /// <param name="orig_output">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="ksize">ksize</param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="data_format">data format</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation MaxPool3DGradGrad(Output orig_input, Output orig_output, Output grad, long[] ksize, long[] strides, string padding, string data_format = null, String opName = "MaxPool3DGradGrad") 
        {
            OperationDescription desc = NewOperation("MaxPool3DGradGrad", opName);
            desc.AddInput(orig_input);
            desc.AddInput(orig_output);
            desc.AddInput(grad);
            desc.SetAttr("ksize", ksize);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MaxPoolGrad
        /// </summary>
        /// <param name="orig_input">Input to the operation. </param>
        /// <param name="orig_output">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="ksize">ksize</param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="explicit_paddings">explicit paddings</param>
        /// <param name="data_format">data format</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation MaxPoolGrad(Output orig_input, Output orig_output, Output grad, long[] ksize, long[] strides, string padding, long[] explicit_paddings = null, string data_format = null, String opName = "MaxPoolGrad") 
        {
            OperationDescription desc = NewOperation("MaxPoolGrad", opName);
            desc.AddInput(orig_input);
            desc.AddInput(orig_output);
            desc.AddInput(grad);
            desc.SetAttr("ksize", ksize);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (explicit_paddings != null) desc.SetAttr("explicit_paddings", explicit_paddings);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MaxPoolGradGrad
        /// </summary>
        /// <param name="orig_input">Input to the operation. </param>
        /// <param name="orig_output">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="ksize">ksize</param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="data_format">data format</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation MaxPoolGradGrad(Output orig_input, Output orig_output, Output grad, long[] ksize, long[] strides, string padding, string data_format = null, String opName = "MaxPoolGradGrad") 
        {
            OperationDescription desc = NewOperation("MaxPoolGradGrad", opName);
            desc.AddInput(orig_input);
            desc.AddInput(orig_output);
            desc.AddInput(grad);
            desc.SetAttr("ksize", ksize);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MaxPoolGradGradV2
        /// </summary>
        /// <param name="orig_input">Input to the operation. </param>
        /// <param name="orig_output">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="ksize">Input to the operation. </param>
        /// <param name="strides">Input to the operation. </param>
        /// <param name="padding">padding</param>
        /// <param name="data_format">data format</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation MaxPoolGradGradV2(Output orig_input, Output orig_output, Output grad, Output ksize, Output strides, string padding, string data_format = null, String opName = "MaxPoolGradGradV2") 
        {
            OperationDescription desc = NewOperation("MaxPoolGradGradV2", opName);
            desc.AddInput(orig_input);
            desc.AddInput(orig_output);
            desc.AddInput(grad);
            desc.AddInput(ksize);
            desc.AddInput(strides);
            desc.SetAttr("padding", padding);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MaxPoolGradGradWithArgmax
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="argmax">Input to the operation. </param>
        /// <param name="ksize">ksize</param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="include_batch_in_index">include batch in index</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation MaxPoolGradGradWithArgmax(Output input, Output grad, Output argmax, long[] ksize, long[] strides, string padding, bool include_batch_in_index = false, String opName = "MaxPoolGradGradWithArgmax") 
        {
            OperationDescription desc = NewOperation("MaxPoolGradGradWithArgmax", opName);
            desc.AddInput(input);
            desc.AddInput(grad);
            desc.AddInput(argmax);
            desc.SetAttr("ksize", ksize);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (include_batch_in_index != false)
                desc.SetAttr("include_batch_in_index", include_batch_in_index);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MaxPoolGradV2
        /// </summary>
        /// <param name="orig_input">Input to the operation. </param>
        /// <param name="orig_output">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="ksize">Input to the operation. </param>
        /// <param name="strides">Input to the operation. </param>
        /// <param name="padding">padding</param>
        /// <param name="data_format">data format</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation MaxPoolGradV2(Output orig_input, Output orig_output, Output grad, Output ksize, Output strides, string padding, string data_format = null, String opName = "MaxPoolGradV2") 
        {
            OperationDescription desc = NewOperation("MaxPoolGradV2", opName);
            desc.AddInput(orig_input);
            desc.AddInput(orig_output);
            desc.AddInput(grad);
            desc.AddInput(ksize);
            desc.AddInput(strides);
            desc.SetAttr("padding", padding);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MaxPoolGradWithArgmax
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="argmax">Input to the operation. </param>
        /// <param name="ksize">ksize</param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="include_batch_in_index">include batch in index</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation MaxPoolGradWithArgmax(Output input, Output grad, Output argmax, long[] ksize, long[] strides, string padding, bool include_batch_in_index = false, String opName = "MaxPoolGradWithArgmax") 
        {
            OperationDescription desc = NewOperation("MaxPoolGradWithArgmax", opName);
            desc.AddInput(input);
            desc.AddInput(grad);
            desc.AddInput(argmax);
            desc.SetAttr("ksize", ksize);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (include_batch_in_index != false)
                desc.SetAttr("include_batch_in_index", include_batch_in_index);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MaxPoolV2
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="ksize">Input to the operation. </param>
        /// <param name="strides">Input to the operation. </param>
        /// <param name="padding">padding</param>
        /// <param name="data_format">data format</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation MaxPoolV2(Output input, Output ksize, Output strides, string padding, string data_format = null, String opName = "MaxPoolV2") 
        {
            OperationDescription desc = NewOperation("MaxPoolV2", opName);
            desc.AddInput(input);
            desc.AddInput(ksize);
            desc.AddInput(strides);
            desc.SetAttr("padding", padding);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MaxPoolWithArgmax
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="ksize">ksize</param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="Targmax">Targmax</param>
        /// <param name="include_batch_in_index">include batch in index</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] argmax(type: DtInvalid).
        /// </returns>
        public Operation MaxPoolWithArgmax(Output input, long[] ksize, long[] strides, string padding, DataType? Targmax = null, bool include_batch_in_index = false, String opName = "MaxPoolWithArgmax") 
        {
            OperationDescription desc = NewOperation("MaxPoolWithArgmax", opName);
            desc.AddInput(input);
            desc.SetAttr("ksize", ksize);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (Targmax.HasValue)
                desc.SetAttr("Targmax", Targmax.Value);
            if (include_batch_in_index != false)
                desc.SetAttr("include_batch_in_index", include_batch_in_index);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Mean
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="reduction_indices">Input to the operation. </param>
        /// <param name="keep_dims">keep dims</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Mean(Output input, Output reduction_indices, bool keep_dims = false, String opName = "Mean") 
        {
            OperationDescription desc = NewOperation("Mean", opName);
            desc.AddInput(input);
            desc.AddInput(reduction_indices);
            if (keep_dims != false)
                desc.SetAttr("keep_dims", keep_dims);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Merge
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] value_index(type: DtInt32).
        /// </returns>
        public Operation Merge(Output inputs, String opName = "Merge") 
        {
            OperationDescription desc = NewOperation("Merge", opName);
            desc.AddInput(inputs);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MergeDedupData
        /// </summary>
        /// <param name="integer_tensor">Input to the operation. </param>
        /// <param name="float_tensor">Input to the operation. </param>
        /// <param name="tuple_mask">tuple mask</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtVariant).
        /// </returns>
        public Operation MergeDedupData(Output integer_tensor, Output float_tensor, string tuple_mask, string config = null, String opName = "MergeDedupData") 
        {
            OperationDescription desc = NewOperation("MergeDedupData", opName);
            desc.AddInput(integer_tensor);
            desc.AddInput(float_tensor);
            desc.SetAttr("tuple_mask", tuple_mask);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MergeSummary
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] summary(type: DtString).
        /// </returns>
        public Operation MergeSummary(Output inputs, String opName = "MergeSummary") 
        {
            OperationDescription desc = NewOperation("MergeSummary", opName);
            desc.AddInput(inputs);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MergeV2Checkpoints
        /// </summary>
        /// <param name="checkpoint_prefixes">Input to the operation. </param>
        /// <param name="destination_prefix">Input to the operation. </param>
        /// <param name="delete_old_dirs">delete old dirs</param>
        /// <param name="allow_missing_files">allow missing files</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation MergeV2Checkpoints(Output checkpoint_prefixes, Output destination_prefix, bool delete_old_dirs = true, bool allow_missing_files = false, String opName = "MergeV2Checkpoints") 
        {
            OperationDescription desc = NewOperation("MergeV2Checkpoints", opName);
            desc.AddInput(checkpoint_prefixes);
            desc.AddInput(destination_prefix);
            if (delete_old_dirs != true)
                desc.SetAttr("delete_old_dirs", delete_old_dirs);
            if (allow_missing_files != false)
                desc.SetAttr("allow_missing_files", allow_missing_files);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Mfcc
        /// </summary>
        /// <param name="spectrogram">Input to the operation. </param>
        /// <param name="sample_rate">Input to the operation. </param>
        /// <param name="upper_frequency_limit">upper frequency limit</param>
        /// <param name="lower_frequency_limit">lower frequency limit</param>
        /// <param name="filterbank_channel_count">filterbank channel count</param>
        /// <param name="dct_coefficient_count">dct coefficient count</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtFloat).
        /// </returns>
        public Operation Mfcc(Output spectrogram, Output sample_rate, float upper_frequency_limit = 4000f, float lower_frequency_limit = 20f, long filterbank_channel_count = 40, long dct_coefficient_count = 13, String opName = "Mfcc") 
        {
            OperationDescription desc = NewOperation("Mfcc", opName);
            desc.AddInput(spectrogram);
            desc.AddInput(sample_rate);
            if (upper_frequency_limit != 4000f)
                desc.SetAttr("upper_frequency_limit", upper_frequency_limit);
            if (lower_frequency_limit != 20f)
                desc.SetAttr("lower_frequency_limit", lower_frequency_limit);
            if (filterbank_channel_count != 40)
                desc.SetAttr("filterbank_channel_count", filterbank_channel_count);
            if (dct_coefficient_count != 13)
                desc.SetAttr("dct_coefficient_count", dct_coefficient_count);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Min
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="reduction_indices">Input to the operation. </param>
        /// <param name="keep_dims">keep dims</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Min(Output input, Output reduction_indices, bool keep_dims = false, String opName = "Min") 
        {
            OperationDescription desc = NewOperation("Min", opName);
            desc.AddInput(input);
            desc.AddInput(reduction_indices);
            if (keep_dims != false)
                desc.SetAttr("keep_dims", keep_dims);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Minimum
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation Minimum(Output x, Output y, String opName = "Minimum") 
        {
            OperationDescription desc = NewOperation("Minimum", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MirrorPad
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="paddings">Input to the operation. </param>
        /// <param name="mode">mode</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation MirrorPad(Output input, Output paddings, string mode, String opName = "MirrorPad") 
        {
            OperationDescription desc = NewOperation("MirrorPad", opName);
            desc.AddInput(input);
            desc.AddInput(paddings);
            desc.SetAttr("mode", mode);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MirrorPadGrad
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="paddings">Input to the operation. </param>
        /// <param name="mode">mode</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation MirrorPadGrad(Output input, Output paddings, string mode, String opName = "MirrorPadGrad") 
        {
            OperationDescription desc = NewOperation("MirrorPadGrad", opName);
            desc.AddInput(input);
            desc.AddInput(paddings);
            desc.SetAttr("mode", mode);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MlirPassthroughOp
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="mlir_module">mlir module</param>
        /// <param name="Toutputs">Toutputs</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] outputs(type: DtInvalid).
        /// </returns>
        public Operation MlirPassthroughOp(Output inputs, string mlir_module, DataType[] Toutputs, String opName = "MlirPassthroughOp") 
        {
            OperationDescription desc = NewOperation("MlirPassthroughOp", opName);
            desc.AddInput(inputs);
            desc.SetAttr("mlir_module", mlir_module);
            desc.SetAttr("Toutputs", Toutputs);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Mod
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation Mod(Output x, Output y, String opName = "Mod") 
        {
            OperationDescription desc = NewOperation("Mod", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ModelDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="algorithm">algorithm</param>
        /// <param name="cpu_budget">cpu budget</param>
        /// <param name="ram_budget">ram budget</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ModelDataset(Output input_dataset, DataType[] output_types, long[][] output_shapes, long algorithm = 0, long cpu_budget = 0, long ram_budget = 0, String opName = "ModelDataset") 
        {
            OperationDescription desc = NewOperation("ModelDataset", opName);
            desc.AddInput(input_dataset);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (algorithm != 0)
                desc.SetAttr("algorithm", algorithm);
            if (cpu_budget != 0)
                desc.SetAttr("cpu_budget", cpu_budget);
            if (ram_budget != 0)
                desc.SetAttr("ram_budget", ram_budget);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Mul
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation Mul(Output x, Output y, String opName = "Mul") 
        {
            OperationDescription desc = NewOperation("Mul", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MulNoNan
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation MulNoNan(Output x, Output y, String opName = "MulNoNan") 
        {
            OperationDescription desc = NewOperation("MulNoNan", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MultiDeviceIterator
        /// </summary>
        /// <param name="devices">devices</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="container">container</param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// </returns>
        public Operation MultiDeviceIterator(string[] devices, string shared_name, string container, DataType[] output_types, long[][] output_shapes, String opName = "MultiDeviceIterator") 
        {
            OperationDescription desc = NewOperation("MultiDeviceIterator", opName);
            desc.SetAttr("devices", devices);
            desc.SetAttr("shared_name", shared_name);
            desc.SetAttr("container", container);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MultiDeviceIteratorFromStringHandle
        /// </summary>
        /// <param name="string_handle">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] multi_device_iterator(type: DtResource).
        /// </returns>
        public Operation MultiDeviceIteratorFromStringHandle(Output string_handle, DataType[] output_types = null, long[][] output_shapes = null, String opName = "MultiDeviceIteratorFromStringHandle") 
        {
            OperationDescription desc = NewOperation("MultiDeviceIteratorFromStringHandle", opName);
            desc.AddInput(string_handle);
            if (output_types != null) desc.SetAttr("output_types", output_types);
            if (output_shapes != null) desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MultiDeviceIteratorGetNextFromShard
        /// </summary>
        /// <param name="multi_device_iterator">Input to the operation. </param>
        /// <param name="shard_num">Input to the operation. </param>
        /// <param name="incarnation_id">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] components(type: DtInvalid).
        /// </returns>
        public Operation MultiDeviceIteratorGetNextFromShard(Output multi_device_iterator, Output shard_num, Output incarnation_id, DataType[] output_types, long[][] output_shapes, String opName = "MultiDeviceIteratorGetNextFromShard") 
        {
            OperationDescription desc = NewOperation("MultiDeviceIteratorGetNextFromShard", opName);
            desc.AddInput(multi_device_iterator);
            desc.AddInput(shard_num);
            desc.AddInput(incarnation_id);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MultiDeviceIteratorInit
        /// </summary>
        /// <param name="dataset">Input to the operation. </param>
        /// <param name="multi_device_iterator">Input to the operation. </param>
        /// <param name="max_buffer_size">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] incarnation_id(type: DtInt64).
        /// </returns>
        public Operation MultiDeviceIteratorInit(Output dataset, Output multi_device_iterator, Output max_buffer_size, String opName = "MultiDeviceIteratorInit") 
        {
            OperationDescription desc = NewOperation("MultiDeviceIteratorInit", opName);
            desc.AddInput(dataset);
            desc.AddInput(multi_device_iterator);
            desc.AddInput(max_buffer_size);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MultiDeviceIteratorToStringHandle
        /// </summary>
        /// <param name="multi_device_iterator">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] string_handle(type: DtString).
        /// </returns>
        public Operation MultiDeviceIteratorToStringHandle(Output multi_device_iterator, String opName = "MultiDeviceIteratorToStringHandle") 
        {
            OperationDescription desc = NewOperation("MultiDeviceIteratorToStringHandle", opName);
            desc.AddInput(multi_device_iterator);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Multinomial
        /// </summary>
        /// <param name="logits">Input to the operation. </param>
        /// <param name="num_samples">Input to the operation. </param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="output_dtype">output dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Multinomial(Output logits, Output num_samples, long seed = 0, long seed2 = 0, DataType? output_dtype = null, String opName = "Multinomial") 
        {
            OperationDescription desc = NewOperation("Multinomial", opName);
            desc.AddInput(logits);
            desc.AddInput(num_samples);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            if (output_dtype.HasValue)
                desc.SetAttr("output_dtype", output_dtype.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MutableDenseHashTable
        /// </summary>
        /// <param name="empty_key">Input to the operation. </param>
        /// <param name="value_dtype">value dtype</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="use_node_name_sharing">use node name sharing</param>
        /// <param name="value_shape">value shape</param>
        /// <param name="initial_num_buckets">initial num buckets</param>
        /// <param name="max_load_factor">max load factor</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] table_handle(type: DtString).
        /// </returns>
        public Operation MutableDenseHashTable(Output empty_key, DataType value_dtype, string container = null, string shared_name = null, bool use_node_name_sharing = false, long[] value_shape = null, long initial_num_buckets = 131072, float max_load_factor = 0.8f, String opName = "MutableDenseHashTable") 
        {
            OperationDescription desc = NewOperation("MutableDenseHashTable", opName);
            desc.AddInput(empty_key);
            desc.SetAttr("value_dtype", value_dtype);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            if (use_node_name_sharing != false)
                desc.SetAttr("use_node_name_sharing", use_node_name_sharing);
            if (value_shape != null)
                 desc.SetAttrShape("value_shape", value_shape);
            if (initial_num_buckets != 131072)
                desc.SetAttr("initial_num_buckets", initial_num_buckets);
            if (max_load_factor != 0.8f)
                desc.SetAttr("max_load_factor", max_load_factor);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MutableDenseHashTableV2
        /// </summary>
        /// <param name="empty_key">Input to the operation. </param>
        /// <param name="deleted_key">Input to the operation. </param>
        /// <param name="value_dtype">value dtype</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="use_node_name_sharing">use node name sharing</param>
        /// <param name="value_shape">value shape</param>
        /// <param name="initial_num_buckets">initial num buckets</param>
        /// <param name="max_load_factor">max load factor</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] table_handle(type: DtResource).
        /// </returns>
        public Operation MutableDenseHashTableV2(Output empty_key, Output deleted_key, DataType value_dtype, string container = null, string shared_name = null, bool use_node_name_sharing = false, long[] value_shape = null, long initial_num_buckets = 131072, float max_load_factor = 0.8f, String opName = "MutableDenseHashTableV2") 
        {
            OperationDescription desc = NewOperation("MutableDenseHashTableV2", opName);
            desc.AddInput(empty_key);
            desc.AddInput(deleted_key);
            desc.SetAttr("value_dtype", value_dtype);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            if (use_node_name_sharing != false)
                desc.SetAttr("use_node_name_sharing", use_node_name_sharing);
            if (value_shape != null)
                 desc.SetAttrShape("value_shape", value_shape);
            if (initial_num_buckets != 131072)
                desc.SetAttr("initial_num_buckets", initial_num_buckets);
            if (max_load_factor != 0.8f)
                desc.SetAttr("max_load_factor", max_load_factor);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MutableHashTable
        /// </summary>
        /// <param name="key_dtype">key dtype</param>
        /// <param name="value_dtype">value dtype</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="use_node_name_sharing">use node name sharing</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] table_handle(type: DtString).
        /// </returns>
        public Operation MutableHashTable(DataType key_dtype, DataType value_dtype, string container = null, string shared_name = null, bool use_node_name_sharing = false, String opName = "MutableHashTable") 
        {
            OperationDescription desc = NewOperation("MutableHashTable", opName);
            desc.SetAttr("key_dtype", key_dtype);
            desc.SetAttr("value_dtype", value_dtype);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            if (use_node_name_sharing != false)
                desc.SetAttr("use_node_name_sharing", use_node_name_sharing);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MutableHashTableOfTensors
        /// </summary>
        /// <param name="key_dtype">key dtype</param>
        /// <param name="value_dtype">value dtype</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="use_node_name_sharing">use node name sharing</param>
        /// <param name="value_shape">value shape</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] table_handle(type: DtString).
        /// </returns>
        public Operation MutableHashTableOfTensors(DataType key_dtype, DataType value_dtype, string container = null, string shared_name = null, bool use_node_name_sharing = false, long[] value_shape = null, String opName = "MutableHashTableOfTensors") 
        {
            OperationDescription desc = NewOperation("MutableHashTableOfTensors", opName);
            desc.SetAttr("key_dtype", key_dtype);
            desc.SetAttr("value_dtype", value_dtype);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            if (use_node_name_sharing != false)
                desc.SetAttr("use_node_name_sharing", use_node_name_sharing);
            if (value_shape != null)
                 desc.SetAttrShape("value_shape", value_shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MutableHashTableOfTensorsV2
        /// </summary>
        /// <param name="key_dtype">key dtype</param>
        /// <param name="value_dtype">value dtype</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="use_node_name_sharing">use node name sharing</param>
        /// <param name="value_shape">value shape</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] table_handle(type: DtResource).
        /// </returns>
        public Operation MutableHashTableOfTensorsV2(DataType key_dtype, DataType value_dtype, string container = null, string shared_name = null, bool use_node_name_sharing = false, long[] value_shape = null, String opName = "MutableHashTableOfTensorsV2") 
        {
            OperationDescription desc = NewOperation("MutableHashTableOfTensorsV2", opName);
            desc.SetAttr("key_dtype", key_dtype);
            desc.SetAttr("value_dtype", value_dtype);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            if (use_node_name_sharing != false)
                desc.SetAttr("use_node_name_sharing", use_node_name_sharing);
            if (value_shape != null)
                 desc.SetAttrShape("value_shape", value_shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MutableHashTableV2
        /// </summary>
        /// <param name="key_dtype">key dtype</param>
        /// <param name="value_dtype">value dtype</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="use_node_name_sharing">use node name sharing</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] table_handle(type: DtResource).
        /// </returns>
        public Operation MutableHashTableV2(DataType key_dtype, DataType value_dtype, string container = null, string shared_name = null, bool use_node_name_sharing = false, String opName = "MutableHashTableV2") 
        {
            OperationDescription desc = NewOperation("MutableHashTableV2", opName);
            desc.SetAttr("key_dtype", key_dtype);
            desc.SetAttr("value_dtype", value_dtype);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            if (use_node_name_sharing != false)
                desc.SetAttr("use_node_name_sharing", use_node_name_sharing);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MutexLock
        /// </summary>
        /// <param name="mutex">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] mutex_lock(type: DtVariant).
        /// </returns>
        public Operation MutexLock(Output mutex, String opName = "MutexLock") 
        {
            OperationDescription desc = NewOperation("MutexLock", opName);
            desc.AddInput(mutex);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// MutexV2
        /// </summary>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] resource(type: DtResource).
        /// </returns>
        public Operation MutexV2(string container = null, string shared_name = null, String opName = "MutexV2") 
        {
            OperationDescription desc = NewOperation("MutexV2", opName);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// NcclAllReduce
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="reduction">reduction</param>
        /// <param name="num_devices">num devices</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] data(type: DtInvalid).
        /// </returns>
        public Operation NcclAllReduce(Output input, string reduction, long num_devices, string shared_name, String opName = "NcclAllReduce") 
        {
            OperationDescription desc = NewOperation("NcclAllReduce", opName);
            desc.AddInput(input);
            desc.SetAttr("reduction", reduction);
            desc.SetAttr("num_devices", num_devices);
            desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// NcclBroadcast
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="shape">shape</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation NcclBroadcast(Output input, long[] shape, String opName = "NcclBroadcast") 
        {
            OperationDescription desc = NewOperation("NcclBroadcast", opName);
            desc.AddInput(input);
            desc.SetAttrShape("shape", shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// NcclReduce
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="reduction">reduction</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] data(type: DtInvalid).
        /// </returns>
        public Operation NcclReduce(Output input, string reduction, String opName = "NcclReduce") 
        {
            OperationDescription desc = NewOperation("NcclReduce", opName);
            desc.AddInput(input);
            desc.SetAttr("reduction", reduction);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Ndtri
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Ndtri(Output x, String opName = "Ndtri") 
        {
            OperationDescription desc = NewOperation("Ndtri", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// NearestNeighbors
        /// </summary>
        /// <param name="points">Input to the operation. </param>
        /// <param name="centers">Input to the operation. </param>
        /// <param name="k">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] nearest_center_indices(type: DtInt64).
        /// [1] nearest_center_distances(type: DtFloat).
        /// </returns>
        public Operation NearestNeighbors(Output points, Output centers, Output k, String opName = "NearestNeighbors") 
        {
            OperationDescription desc = NewOperation("NearestNeighbors", opName);
            desc.AddInput(points);
            desc.AddInput(centers);
            desc.AddInput(k);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Neg
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Neg(Output x, String opName = "Neg") 
        {
            OperationDescription desc = NewOperation("Neg", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// NegTrain
        /// </summary>
        /// <param name="w_in">Input to the operation. </param>
        /// <param name="w_out">Input to the operation. </param>
        /// <param name="examples">Input to the operation. </param>
        /// <param name="labels">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="vocab_count">vocab count</param>
        /// <param name="num_negative_samples">num negative samples</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation NegTrain(Output w_in, Output w_out, Output examples, Output labels, Output lr, long[] vocab_count, long num_negative_samples, String opName = "NegTrain") 
        {
            OperationDescription desc = NewOperation("NegTrain", opName);
            desc.AddInput(w_in);
            desc.AddInput(w_out);
            desc.AddInput(examples);
            desc.AddInput(labels);
            desc.AddInput(lr);
            desc.SetAttr("vocab_count", vocab_count);
            desc.SetAttr("num_negative_samples", num_negative_samples);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// NextAfter
        /// </summary>
        /// <param name="x1">Input to the operation. </param>
        /// <param name="x2">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation NextAfter(Output x1, Output x2, String opName = "NextAfter") 
        {
            OperationDescription desc = NewOperation("NextAfter", opName);
            desc.AddInput(x1);
            desc.AddInput(x2);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// NextIteration
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation NextIteration(Output data, String opName = "NextIteration") 
        {
            OperationDescription desc = NewOperation("NextIteration", opName);
            desc.AddInput(data);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// NonDeterministicInts
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation NonDeterministicInts(Output shape, DataType? dtype = null, String opName = "NonDeterministicInts") 
        {
            OperationDescription desc = NewOperation("NonDeterministicInts", opName);
            desc.AddInput(shape);
            if (dtype.HasValue)
                desc.SetAttr("dtype", dtype.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// NonMaxSuppression
        /// </summary>
        /// <param name="boxes">Input to the operation. </param>
        /// <param name="scores">Input to the operation. </param>
        /// <param name="max_output_size">Input to the operation. </param>
        /// <param name="iou_threshold">iou threshold</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] selected_indices(type: DtInt32).
        /// </returns>
        public Operation NonMaxSuppression(Output boxes, Output scores, Output max_output_size, float iou_threshold = 0.5f, String opName = "NonMaxSuppression") 
        {
            OperationDescription desc = NewOperation("NonMaxSuppression", opName);
            desc.AddInput(boxes);
            desc.AddInput(scores);
            desc.AddInput(max_output_size);
            if (iou_threshold != 0.5f)
                desc.SetAttr("iou_threshold", iou_threshold);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// NonMaxSuppressionV2
        /// </summary>
        /// <param name="boxes">Input to the operation. </param>
        /// <param name="scores">Input to the operation. </param>
        /// <param name="max_output_size">Input to the operation. </param>
        /// <param name="iou_threshold">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] selected_indices(type: DtInt32).
        /// </returns>
        public Operation NonMaxSuppressionV2(Output boxes, Output scores, Output max_output_size, Output iou_threshold, String opName = "NonMaxSuppressionV2") 
        {
            OperationDescription desc = NewOperation("NonMaxSuppressionV2", opName);
            desc.AddInput(boxes);
            desc.AddInput(scores);
            desc.AddInput(max_output_size);
            desc.AddInput(iou_threshold);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// NonMaxSuppressionV3
        /// </summary>
        /// <param name="boxes">Input to the operation. </param>
        /// <param name="scores">Input to the operation. </param>
        /// <param name="max_output_size">Input to the operation. </param>
        /// <param name="iou_threshold">Input to the operation. </param>
        /// <param name="score_threshold">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] selected_indices(type: DtInt32).
        /// </returns>
        public Operation NonMaxSuppressionV3(Output boxes, Output scores, Output max_output_size, Output iou_threshold, Output score_threshold, String opName = "NonMaxSuppressionV3") 
        {
            OperationDescription desc = NewOperation("NonMaxSuppressionV3", opName);
            desc.AddInput(boxes);
            desc.AddInput(scores);
            desc.AddInput(max_output_size);
            desc.AddInput(iou_threshold);
            desc.AddInput(score_threshold);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// NonMaxSuppressionV4
        /// </summary>
        /// <param name="boxes">Input to the operation. </param>
        /// <param name="scores">Input to the operation. </param>
        /// <param name="max_output_size">Input to the operation. </param>
        /// <param name="iou_threshold">Input to the operation. </param>
        /// <param name="score_threshold">Input to the operation. </param>
        /// <param name="pad_to_max_output_size">pad to max output size</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] selected_indices(type: DtInt32).
        /// [1] valid_outputs(type: DtInt32).
        /// </returns>
        public Operation NonMaxSuppressionV4(Output boxes, Output scores, Output max_output_size, Output iou_threshold, Output score_threshold, bool pad_to_max_output_size = false, String opName = "NonMaxSuppressionV4") 
        {
            OperationDescription desc = NewOperation("NonMaxSuppressionV4", opName);
            desc.AddInput(boxes);
            desc.AddInput(scores);
            desc.AddInput(max_output_size);
            desc.AddInput(iou_threshold);
            desc.AddInput(score_threshold);
            if (pad_to_max_output_size != false)
                desc.SetAttr("pad_to_max_output_size", pad_to_max_output_size);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// NonMaxSuppressionV5
        /// </summary>
        /// <param name="boxes">Input to the operation. </param>
        /// <param name="scores">Input to the operation. </param>
        /// <param name="max_output_size">Input to the operation. </param>
        /// <param name="iou_threshold">Input to the operation. </param>
        /// <param name="score_threshold">Input to the operation. </param>
        /// <param name="soft_nms_sigma">Input to the operation. </param>
        /// <param name="pad_to_max_output_size">pad to max output size</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] selected_indices(type: DtInt32).
        /// [1] selected_scores(type: DtInvalid).
        /// [2] valid_outputs(type: DtInt32).
        /// </returns>
        public Operation NonMaxSuppressionV5(Output boxes, Output scores, Output max_output_size, Output iou_threshold, Output score_threshold, Output soft_nms_sigma, bool pad_to_max_output_size = false, String opName = "NonMaxSuppressionV5") 
        {
            OperationDescription desc = NewOperation("NonMaxSuppressionV5", opName);
            desc.AddInput(boxes);
            desc.AddInput(scores);
            desc.AddInput(max_output_size);
            desc.AddInput(iou_threshold);
            desc.AddInput(score_threshold);
            desc.AddInput(soft_nms_sigma);
            if (pad_to_max_output_size != false)
                desc.SetAttr("pad_to_max_output_size", pad_to_max_output_size);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// NonMaxSuppressionWithOverlaps
        /// </summary>
        /// <param name="overlaps">Input to the operation. </param>
        /// <param name="scores">Input to the operation. </param>
        /// <param name="max_output_size">Input to the operation. </param>
        /// <param name="overlap_threshold">Input to the operation. </param>
        /// <param name="score_threshold">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] selected_indices(type: DtInt32).
        /// </returns>
        public Operation NonMaxSuppressionWithOverlaps(Output overlaps, Output scores, Output max_output_size, Output overlap_threshold, Output score_threshold, String opName = "NonMaxSuppressionWithOverlaps") 
        {
            OperationDescription desc = NewOperation("NonMaxSuppressionWithOverlaps", opName);
            desc.AddInput(overlaps);
            desc.AddInput(scores);
            desc.AddInput(max_output_size);
            desc.AddInput(overlap_threshold);
            desc.AddInput(score_threshold);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// NonSerializableDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation NonSerializableDataset(Output input_dataset, DataType[] output_types, long[][] output_shapes, String opName = "NonSerializableDataset") 
        {
            OperationDescription desc = NewOperation("NonSerializableDataset", opName);
            desc.AddInput(input_dataset);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// NoOp
        /// </summary>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation NoOp(String opName = "NoOp") 
        {
            OperationDescription desc = NewOperation("NoOp", opName);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// NotEqual
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="incompatible_shape_error">incompatible shape error</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtBool).
        /// </returns>
        public Operation NotEqual(Output x, Output y, bool incompatible_shape_error = true, String opName = "NotEqual") 
        {
            OperationDescription desc = NewOperation("NotEqual", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            if (incompatible_shape_error != true)
                desc.SetAttr("incompatible_shape_error", incompatible_shape_error);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// NthElement
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="n">Input to the operation. </param>
        /// <param name="reverse">reverse</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] values(type: DtInvalid).
        /// </returns>
        public Operation NthElement(Output input, Output n, bool reverse = false, String opName = "NthElement") 
        {
            OperationDescription desc = NewOperation("NthElement", opName);
            desc.AddInput(input);
            desc.AddInput(n);
            if (reverse != false)
                desc.SetAttr("reverse", reverse);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// OneHot
        /// </summary>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="depth">Input to the operation. </param>
        /// <param name="on_value">Input to the operation. </param>
        /// <param name="off_value">Input to the operation. </param>
        /// <param name="axis">axis</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation OneHot(Output indices, Output depth, Output on_value, Output off_value, long axis = -1, String opName = "OneHot") 
        {
            OperationDescription desc = NewOperation("OneHot", opName);
            desc.AddInput(indices);
            desc.AddInput(depth);
            desc.AddInput(on_value);
            desc.AddInput(off_value);
            if (axis != -1)
                desc.SetAttr("axis", axis);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// OneShotIterator
        /// </summary>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// </returns>
        // The following attributes are not known: dataset_factory: func
        public Operation OneShotIterator(DataType[] output_types, long[][] output_shapes, string container = null, string shared_name = null, String opName = "OneShotIterator") 
        {
            OperationDescription desc = NewOperation("OneShotIterator", opName);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// OnesLike
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation OnesLike(Output x, String opName = "OnesLike") 
        {
            OperationDescription desc = NewOperation("OnesLike", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// OptimizeDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="optimizations">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="optimization_configs">optimization configs</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation OptimizeDataset(Output input_dataset, Output optimizations, DataType[] output_types, long[][] output_shapes, string[] optimization_configs = null, String opName = "OptimizeDataset") 
        {
            OperationDescription desc = NewOperation("OptimizeDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(optimizations);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (optimization_configs != null) desc.SetAttr("optimization_configs", optimization_configs);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// OptimizeDatasetV2
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="optimizations_enabled">Input to the operation. </param>
        /// <param name="optimizations_disabled">Input to the operation. </param>
        /// <param name="optimizations_default">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="optimization_configs">optimization configs</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation OptimizeDatasetV2(Output input_dataset, Output optimizations_enabled, Output optimizations_disabled, Output optimizations_default, DataType[] output_types, long[][] output_shapes, string[] optimization_configs = null, String opName = "OptimizeDatasetV2") 
        {
            OperationDescription desc = NewOperation("OptimizeDatasetV2", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(optimizations_enabled);
            desc.AddInput(optimizations_disabled);
            desc.AddInput(optimizations_default);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (optimization_configs != null) desc.SetAttr("optimization_configs", optimization_configs);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// OptionalFromValue
        /// </summary>
        /// <param name="components">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] optional(type: DtVariant).
        /// </returns>
        public Operation OptionalFromValue(Output components, String opName = "OptionalFromValue") 
        {
            OperationDescription desc = NewOperation("OptionalFromValue", opName);
            desc.AddInput(components);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// OptionalGetValue
        /// </summary>
        /// <param name="optional">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] components(type: DtInvalid).
        /// </returns>
        public Operation OptionalGetValue(Output optional, DataType[] output_types, long[][] output_shapes, String opName = "OptionalGetValue") 
        {
            OperationDescription desc = NewOperation("OptionalGetValue", opName);
            desc.AddInput(optional);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// OptionalHasValue
        /// </summary>
        /// <param name="optional">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] has_value(type: DtBool).
        /// </returns>
        public Operation OptionalHasValue(Output optional, String opName = "OptionalHasValue") 
        {
            OperationDescription desc = NewOperation("OptionalHasValue", opName);
            desc.AddInput(optional);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// OptionalNone
        /// </summary>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] optional(type: DtVariant).
        /// </returns>
        public Operation OptionalNone(String opName = "OptionalNone") 
        {
            OperationDescription desc = NewOperation("OptionalNone", opName);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// OptionsDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="serialized_options">serialized options</param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation OptionsDataset(Output input_dataset, string serialized_options, DataType[] output_types, long[][] output_shapes, string metadata = null, String opName = "OptionsDataset") 
        {
            OperationDescription desc = NewOperation("OptionsDataset", opName);
            desc.AddInput(input_dataset);
            desc.SetAttr("serialized_options", serialized_options);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// OrderedMapClear
        /// </summary>
        /// <param name="dtypes">dtypes</param>
        /// <param name="capacity">capacity</param>
        /// <param name="memory_limit">memory limit</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation OrderedMapClear(DataType[] dtypes, long capacity = 0, long memory_limit = 0, string container = null, string shared_name = null, String opName = "OrderedMapClear") 
        {
            OperationDescription desc = NewOperation("OrderedMapClear", opName);
            desc.SetAttr("dtypes", dtypes);
            if (capacity != 0)
                desc.SetAttr("capacity", capacity);
            if (memory_limit != 0)
                desc.SetAttr("memory_limit", memory_limit);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// OrderedMapIncompleteSize
        /// </summary>
        /// <param name="dtypes">dtypes</param>
        /// <param name="capacity">capacity</param>
        /// <param name="memory_limit">memory limit</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] size(type: DtInt32).
        /// </returns>
        public Operation OrderedMapIncompleteSize(DataType[] dtypes, long capacity = 0, long memory_limit = 0, string container = null, string shared_name = null, String opName = "OrderedMapIncompleteSize") 
        {
            OperationDescription desc = NewOperation("OrderedMapIncompleteSize", opName);
            desc.SetAttr("dtypes", dtypes);
            if (capacity != 0)
                desc.SetAttr("capacity", capacity);
            if (memory_limit != 0)
                desc.SetAttr("memory_limit", memory_limit);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// OrderedMapPeek
        /// </summary>
        /// <param name="key">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="dtypes">dtypes</param>
        /// <param name="capacity">capacity</param>
        /// <param name="memory_limit">memory limit</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] values(type: DtInvalid).
        /// </returns>
        public Operation OrderedMapPeek(Output key, Output indices, DataType[] dtypes, long capacity = 0, long memory_limit = 0, string container = null, string shared_name = null, String opName = "OrderedMapPeek") 
        {
            OperationDescription desc = NewOperation("OrderedMapPeek", opName);
            desc.AddInput(key);
            desc.AddInput(indices);
            desc.SetAttr("dtypes", dtypes);
            if (capacity != 0)
                desc.SetAttr("capacity", capacity);
            if (memory_limit != 0)
                desc.SetAttr("memory_limit", memory_limit);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// OrderedMapSize
        /// </summary>
        /// <param name="dtypes">dtypes</param>
        /// <param name="capacity">capacity</param>
        /// <param name="memory_limit">memory limit</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] size(type: DtInt32).
        /// </returns>
        public Operation OrderedMapSize(DataType[] dtypes, long capacity = 0, long memory_limit = 0, string container = null, string shared_name = null, String opName = "OrderedMapSize") 
        {
            OperationDescription desc = NewOperation("OrderedMapSize", opName);
            desc.SetAttr("dtypes", dtypes);
            if (capacity != 0)
                desc.SetAttr("capacity", capacity);
            if (memory_limit != 0)
                desc.SetAttr("memory_limit", memory_limit);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// OrderedMapStage
        /// </summary>
        /// <param name="key">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="dtypes">dtypes</param>
        /// <param name="capacity">capacity</param>
        /// <param name="memory_limit">memory limit</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation OrderedMapStage(Output key, Output indices, Output values, DataType[] dtypes, long capacity = 0, long memory_limit = 0, string container = null, string shared_name = null, String opName = "OrderedMapStage") 
        {
            OperationDescription desc = NewOperation("OrderedMapStage", opName);
            desc.AddInput(key);
            desc.AddInput(indices);
            desc.AddInput(values);
            desc.SetAttr("dtypes", dtypes);
            if (capacity != 0)
                desc.SetAttr("capacity", capacity);
            if (memory_limit != 0)
                desc.SetAttr("memory_limit", memory_limit);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// OrderedMapUnstage
        /// </summary>
        /// <param name="key">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="dtypes">dtypes</param>
        /// <param name="capacity">capacity</param>
        /// <param name="memory_limit">memory limit</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] values(type: DtInvalid).
        /// </returns>
        public Operation OrderedMapUnstage(Output key, Output indices, DataType[] dtypes, long capacity = 0, long memory_limit = 0, string container = null, string shared_name = null, String opName = "OrderedMapUnstage") 
        {
            OperationDescription desc = NewOperation("OrderedMapUnstage", opName);
            desc.AddInput(key);
            desc.AddInput(indices);
            desc.SetAttr("dtypes", dtypes);
            if (capacity != 0)
                desc.SetAttr("capacity", capacity);
            if (memory_limit != 0)
                desc.SetAttr("memory_limit", memory_limit);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// OrderedMapUnstageNoKey
        /// </summary>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="dtypes">dtypes</param>
        /// <param name="capacity">capacity</param>
        /// <param name="memory_limit">memory limit</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] key(type: DtInt64).
        /// [1] values(type: DtInvalid).
        /// </returns>
        public Operation OrderedMapUnstageNoKey(Output indices, DataType[] dtypes, long capacity = 0, long memory_limit = 0, string container = null, string shared_name = null, String opName = "OrderedMapUnstageNoKey") 
        {
            OperationDescription desc = NewOperation("OrderedMapUnstageNoKey", opName);
            desc.AddInput(indices);
            desc.SetAttr("dtypes", dtypes);
            if (capacity != 0)
                desc.SetAttr("capacity", capacity);
            if (memory_limit != 0)
                desc.SetAttr("memory_limit", memory_limit);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// OutfeedDequeue
        /// </summary>
        /// <param name="dtype">dtype</param>
        /// <param name="shape">shape</param>
        /// <param name="device_ordinal">device ordinal</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation OutfeedDequeue(DataType dtype, long[] shape, long device_ordinal = -1, String opName = "OutfeedDequeue") 
        {
            OperationDescription desc = NewOperation("OutfeedDequeue", opName);
            desc.SetAttr("dtype", dtype);
            desc.SetAttrShape("shape", shape);
            if (device_ordinal != -1)
                desc.SetAttr("device_ordinal", device_ordinal);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// OutfeedDequeueTuple
        /// </summary>
        /// <param name="dtypes">dtypes</param>
        /// <param name="shapes">shapes</param>
        /// <param name="device_ordinal">device ordinal</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] outputs(type: DtInvalid).
        /// </returns>
        public Operation OutfeedDequeueTuple(DataType[] dtypes, long[][] shapes, long device_ordinal = -1, String opName = "OutfeedDequeueTuple") 
        {
            OperationDescription desc = NewOperation("OutfeedDequeueTuple", opName);
            desc.SetAttr("dtypes", dtypes);
            desc.SetAttrShapeList("shapes", shapes);
            if (device_ordinal != -1)
                desc.SetAttr("device_ordinal", device_ordinal);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// OutfeedDequeueTupleV2
        /// </summary>
        /// <param name="device_ordinal">Input to the operation. </param>
        /// <param name="dtypes">dtypes</param>
        /// <param name="shapes">shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] outputs(type: DtInvalid).
        /// </returns>
        public Operation OutfeedDequeueTupleV2(Output device_ordinal, DataType[] dtypes, long[][] shapes, String opName = "OutfeedDequeueTupleV2") 
        {
            OperationDescription desc = NewOperation("OutfeedDequeueTupleV2", opName);
            desc.AddInput(device_ordinal);
            desc.SetAttr("dtypes", dtypes);
            desc.SetAttrShapeList("shapes", shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// OutfeedDequeueV2
        /// </summary>
        /// <param name="device_ordinal">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="shape">shape</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation OutfeedDequeueV2(Output device_ordinal, DataType dtype, long[] shape, String opName = "OutfeedDequeueV2") 
        {
            OperationDescription desc = NewOperation("OutfeedDequeueV2", opName);
            desc.AddInput(device_ordinal);
            desc.SetAttr("dtype", dtype);
            desc.SetAttrShape("shape", shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// OutfeedEnqueue
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation OutfeedEnqueue(Output input, String opName = "OutfeedEnqueue") 
        {
            OperationDescription desc = NewOperation("OutfeedEnqueue", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// OutfeedEnqueueTuple
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation OutfeedEnqueueTuple(Output inputs, String opName = "OutfeedEnqueueTuple") 
        {
            OperationDescription desc = NewOperation("OutfeedEnqueueTuple", opName);
            desc.AddInput(inputs);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Pack
        /// </summary>
        /// <param name="values">Input to the operation. </param>
        /// <param name="axis">axis</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Pack(Output values, long axis = 0, String opName = "Pack") 
        {
            OperationDescription desc = NewOperation("Pack", opName);
            desc.AddInput(values);
            if (axis != 0)
                desc.SetAttr("axis", axis);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Pad
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="paddings">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Pad(Output input, Output paddings, String opName = "Pad") 
        {
            OperationDescription desc = NewOperation("Pad", opName);
            desc.AddInput(input);
            desc.AddInput(paddings);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// PaddedBatchDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="batch_size">Input to the operation. </param>
        /// <param name="padded_shapes">Input to the operation. </param>
        /// <param name="padding_values">Input to the operation. </param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation PaddedBatchDataset(Output input_dataset, Output batch_size, Output padded_shapes, Output padding_values, long[][] output_shapes, string metadata = null, String opName = "PaddedBatchDataset") 
        {
            OperationDescription desc = NewOperation("PaddedBatchDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(batch_size);
            desc.AddInput(padded_shapes);
            desc.AddInput(padding_values);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// PaddedBatchDatasetV2
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="batch_size">Input to the operation. </param>
        /// <param name="padded_shapes">Input to the operation. </param>
        /// <param name="padding_values">Input to the operation. </param>
        /// <param name="drop_remainder">Input to the operation. </param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="parallel_copy">parallel copy</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation PaddedBatchDatasetV2(Output input_dataset, Output batch_size, Output padded_shapes, Output padding_values, Output drop_remainder, long[][] output_shapes, bool parallel_copy = false, string metadata = null, String opName = "PaddedBatchDatasetV2") 
        {
            OperationDescription desc = NewOperation("PaddedBatchDatasetV2", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(batch_size);
            desc.AddInput(padded_shapes);
            desc.AddInput(padding_values);
            desc.AddInput(drop_remainder);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (parallel_copy != false)
                desc.SetAttr("parallel_copy", parallel_copy);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// PaddingFIFOQueue
        /// </summary>
        /// <param name="component_types">component types</param>
        /// <param name="shapes">shapes</param>
        /// <param name="capacity">capacity</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtString).
        /// </returns>
        public Operation PaddingFIFOQueue(DataType[] component_types, long[][] shapes = null, long capacity = -1, string container = null, string shared_name = null, String opName = "PaddingFIFOQueue") 
        {
            OperationDescription desc = NewOperation("PaddingFIFOQueue", opName);
            desc.SetAttr("component_types", component_types);
            if (shapes != null) desc.SetAttrShapeList("shapes", shapes);
            if (capacity != -1)
                desc.SetAttr("capacity", capacity);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// PaddingFIFOQueueV2
        /// </summary>
        /// <param name="component_types">component types</param>
        /// <param name="shapes">shapes</param>
        /// <param name="capacity">capacity</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// </returns>
        public Operation PaddingFIFOQueueV2(DataType[] component_types, long[][] shapes = null, long capacity = -1, string container = null, string shared_name = null, String opName = "PaddingFIFOQueueV2") 
        {
            OperationDescription desc = NewOperation("PaddingFIFOQueueV2", opName);
            desc.SetAttr("component_types", component_types);
            if (shapes != null) desc.SetAttrShapeList("shapes", shapes);
            if (capacity != -1)
                desc.SetAttr("capacity", capacity);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// PadV2
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="paddings">Input to the operation. </param>
        /// <param name="constant_values">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation PadV2(Output input, Output paddings, Output constant_values, String opName = "PadV2") 
        {
            OperationDescription desc = NewOperation("PadV2", opName);
            desc.AddInput(input);
            desc.AddInput(paddings);
            desc.AddInput(constant_values);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ParallelBatchDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="batch_size">Input to the operation. </param>
        /// <param name="num_parallel_calls">Input to the operation. </param>
        /// <param name="drop_remainder">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="parallel_copy">parallel copy</param>
        /// <param name="deterministic">deterministic</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ParallelBatchDataset(Output input_dataset, Output batch_size, Output num_parallel_calls, Output drop_remainder, DataType[] output_types, long[][] output_shapes, bool parallel_copy = false, string deterministic = null, string metadata = null, String opName = "ParallelBatchDataset") 
        {
            OperationDescription desc = NewOperation("ParallelBatchDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(batch_size);
            desc.AddInput(num_parallel_calls);
            desc.AddInput(drop_remainder);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (parallel_copy != false)
                desc.SetAttr("parallel_copy", parallel_copy);
            if (deterministic != null)
                 desc.SetAttr("deterministic", deterministic);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ParallelConcat
        /// </summary>
        /// <param name="values">Input to the operation. </param>
        /// <param name="shape">shape</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation ParallelConcat(Output values, long[] shape, String opName = "ParallelConcat") 
        {
            OperationDescription desc = NewOperation("ParallelConcat", opName);
            desc.AddInput(values);
            desc.SetAttrShape("shape", shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ParallelDynamicStitch
        /// </summary>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="data">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] merged(type: DtInvalid).
        /// </returns>
        public Operation ParallelDynamicStitch(Output indices, Output data, String opName = "ParallelDynamicStitch") 
        {
            OperationDescription desc = NewOperation("ParallelDynamicStitch", opName);
            desc.AddInput(indices);
            desc.AddInput(data);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ParallelFilterDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="other_arguments">Input to the operation. </param>
        /// <param name="num_parallel_calls">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="deterministic">deterministic</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: predicate: func
        public Operation ParallelFilterDataset(Output input_dataset, Output other_arguments, Output num_parallel_calls, DataType[] output_types, long[][] output_shapes, string deterministic = null, string metadata = null, String opName = "ParallelFilterDataset") 
        {
            OperationDescription desc = NewOperation("ParallelFilterDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(other_arguments);
            desc.AddInput(num_parallel_calls);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (deterministic != null)
                 desc.SetAttr("deterministic", deterministic);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ParallelInterleaveDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="other_arguments">Input to the operation. </param>
        /// <param name="cycle_length">Input to the operation. </param>
        /// <param name="block_length">Input to the operation. </param>
        /// <param name="sloppy">Input to the operation. </param>
        /// <param name="buffer_output_elements">Input to the operation. </param>
        /// <param name="prefetch_input_elements">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: f: func
        public Operation ParallelInterleaveDataset(Output input_dataset, Output other_arguments, Output cycle_length, Output block_length, Output sloppy, Output buffer_output_elements, Output prefetch_input_elements, DataType[] output_types, long[][] output_shapes, string metadata = null, String opName = "ParallelInterleaveDataset") 
        {
            OperationDescription desc = NewOperation("ParallelInterleaveDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(other_arguments);
            desc.AddInput(cycle_length);
            desc.AddInput(block_length);
            desc.AddInput(sloppy);
            desc.AddInput(buffer_output_elements);
            desc.AddInput(prefetch_input_elements);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ParallelInterleaveDatasetV2
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="other_arguments">Input to the operation. </param>
        /// <param name="cycle_length">Input to the operation. </param>
        /// <param name="block_length">Input to the operation. </param>
        /// <param name="num_parallel_calls">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="sloppy">sloppy</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: f: func
        public Operation ParallelInterleaveDatasetV2(Output input_dataset, Output other_arguments, Output cycle_length, Output block_length, Output num_parallel_calls, DataType[] output_types, long[][] output_shapes, bool sloppy = false, string metadata = null, String opName = "ParallelInterleaveDatasetV2") 
        {
            OperationDescription desc = NewOperation("ParallelInterleaveDatasetV2", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(other_arguments);
            desc.AddInput(cycle_length);
            desc.AddInput(block_length);
            desc.AddInput(num_parallel_calls);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (sloppy != false)
                desc.SetAttr("sloppy", sloppy);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ParallelInterleaveDatasetV3
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="other_arguments">Input to the operation. </param>
        /// <param name="cycle_length">Input to the operation. </param>
        /// <param name="block_length">Input to the operation. </param>
        /// <param name="num_parallel_calls">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="deterministic">deterministic</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: f: func
        public Operation ParallelInterleaveDatasetV3(Output input_dataset, Output other_arguments, Output cycle_length, Output block_length, Output num_parallel_calls, DataType[] output_types, long[][] output_shapes, string deterministic = null, string metadata = null, String opName = "ParallelInterleaveDatasetV3") 
        {
            OperationDescription desc = NewOperation("ParallelInterleaveDatasetV3", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(other_arguments);
            desc.AddInput(cycle_length);
            desc.AddInput(block_length);
            desc.AddInput(num_parallel_calls);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (deterministic != null)
                 desc.SetAttr("deterministic", deterministic);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ParallelInterleaveDatasetV4
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="other_arguments">Input to the operation. </param>
        /// <param name="cycle_length">Input to the operation. </param>
        /// <param name="block_length">Input to the operation. </param>
        /// <param name="buffer_output_elements">Input to the operation. </param>
        /// <param name="prefetch_input_elements">Input to the operation. </param>
        /// <param name="num_parallel_calls">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="deterministic">deterministic</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: f: func
        public Operation ParallelInterleaveDatasetV4(Output input_dataset, Output other_arguments, Output cycle_length, Output block_length, Output buffer_output_elements, Output prefetch_input_elements, Output num_parallel_calls, DataType[] output_types, long[][] output_shapes, string deterministic = null, string metadata = null, String opName = "ParallelInterleaveDatasetV4") 
        {
            OperationDescription desc = NewOperation("ParallelInterleaveDatasetV4", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(other_arguments);
            desc.AddInput(cycle_length);
            desc.AddInput(block_length);
            desc.AddInput(buffer_output_elements);
            desc.AddInput(prefetch_input_elements);
            desc.AddInput(num_parallel_calls);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (deterministic != null)
                 desc.SetAttr("deterministic", deterministic);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ParallelMapDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="other_arguments">Input to the operation. </param>
        /// <param name="num_parallel_calls">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="use_inter_op_parallelism">use inter op parallelism</param>
        /// <param name="sloppy">sloppy</param>
        /// <param name="preserve_cardinality">preserve cardinality</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: f: func
        public Operation ParallelMapDataset(Output input_dataset, Output other_arguments, Output num_parallel_calls, DataType[] output_types, long[][] output_shapes, bool use_inter_op_parallelism = true, bool sloppy = false, bool preserve_cardinality = false, string metadata = null, String opName = "ParallelMapDataset") 
        {
            OperationDescription desc = NewOperation("ParallelMapDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(other_arguments);
            desc.AddInput(num_parallel_calls);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (use_inter_op_parallelism != true)
                desc.SetAttr("use_inter_op_parallelism", use_inter_op_parallelism);
            if (sloppy != false)
                desc.SetAttr("sloppy", sloppy);
            if (preserve_cardinality != false)
                desc.SetAttr("preserve_cardinality", preserve_cardinality);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ParallelMapDatasetV2
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="other_arguments">Input to the operation. </param>
        /// <param name="num_parallel_calls">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="use_inter_op_parallelism">use inter op parallelism</param>
        /// <param name="deterministic">deterministic</param>
        /// <param name="preserve_cardinality">preserve cardinality</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: f: func
        public Operation ParallelMapDatasetV2(Output input_dataset, Output other_arguments, Output num_parallel_calls, DataType[] output_types, long[][] output_shapes, bool use_inter_op_parallelism = true, string deterministic = null, bool preserve_cardinality = false, string metadata = null, String opName = "ParallelMapDatasetV2") 
        {
            OperationDescription desc = NewOperation("ParallelMapDatasetV2", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(other_arguments);
            desc.AddInput(num_parallel_calls);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (use_inter_op_parallelism != true)
                desc.SetAttr("use_inter_op_parallelism", use_inter_op_parallelism);
            if (deterministic != null)
                 desc.SetAttr("deterministic", deterministic);
            if (preserve_cardinality != false)
                desc.SetAttr("preserve_cardinality", preserve_cardinality);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ParameterizedTruncatedNormal
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="means">Input to the operation. </param>
        /// <param name="stdevs">Input to the operation. </param>
        /// <param name="minvals">Input to the operation. </param>
        /// <param name="maxvals">Input to the operation. </param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation ParameterizedTruncatedNormal(Output shape, Output means, Output stdevs, Output minvals, Output maxvals, long seed = 0, long seed2 = 0, String opName = "ParameterizedTruncatedNormal") 
        {
            OperationDescription desc = NewOperation("ParameterizedTruncatedNormal", opName);
            desc.AddInput(shape);
            desc.AddInput(means);
            desc.AddInput(stdevs);
            desc.AddInput(minvals);
            desc.AddInput(maxvals);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ParseExample
        /// </summary>
        /// <param name="serialized">Input to the operation. </param>
        /// <param name="names">Input to the operation. </param>
        /// <param name="sparse_keys">Input to the operation. </param>
        /// <param name="dense_keys">Input to the operation. </param>
        /// <param name="dense_defaults">Input to the operation. </param>
        /// <param name="sparse_types">sparse types</param>
        /// <param name="dense_shapes">dense shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] sparse_indices(type: DtInt64).
        /// [1] sparse_values(type: DtInvalid).
        /// [2] sparse_shapes(type: DtInt64).
        /// [3] dense_values(type: DtInvalid).
        /// </returns>
        public Operation ParseExample(Output serialized, Output names, Output sparse_keys, Output dense_keys, Output dense_defaults, DataType[] sparse_types, long[][] dense_shapes, String opName = "ParseExample") 
        {
            OperationDescription desc = NewOperation("ParseExample", opName);
            desc.AddInput(serialized);
            desc.AddInput(names);
            desc.AddInput(sparse_keys);
            desc.AddInput(dense_keys);
            desc.AddInput(dense_defaults);
            desc.SetAttr("sparse_types", sparse_types);
            desc.SetAttrShapeList("dense_shapes", dense_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ParseExampleDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="num_parallel_calls">Input to the operation. </param>
        /// <param name="dense_defaults">Input to the operation. </param>
        /// <param name="sparse_keys">sparse keys</param>
        /// <param name="dense_keys">dense keys</param>
        /// <param name="sparse_types">sparse types</param>
        /// <param name="dense_shapes">dense shapes</param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="sloppy">sloppy</param>
        /// <param name="ragged_keys">ragged keys</param>
        /// <param name="ragged_value_types">ragged value types</param>
        /// <param name="ragged_split_types">ragged split types</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ParseExampleDataset(Output input_dataset, Output num_parallel_calls, Output dense_defaults, string[] sparse_keys, string[] dense_keys, DataType[] sparse_types, long[][] dense_shapes, DataType[] output_types, long[][] output_shapes, bool sloppy = false, string[] ragged_keys = null, DataType[] ragged_value_types = null, DataType[] ragged_split_types = null, String opName = "ParseExampleDataset") 
        {
            OperationDescription desc = NewOperation("ParseExampleDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(num_parallel_calls);
            desc.AddInput(dense_defaults);
            desc.SetAttr("sparse_keys", sparse_keys);
            desc.SetAttr("dense_keys", dense_keys);
            desc.SetAttr("sparse_types", sparse_types);
            desc.SetAttrShapeList("dense_shapes", dense_shapes);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (sloppy != false)
                desc.SetAttr("sloppy", sloppy);
            if (ragged_keys != null) desc.SetAttr("ragged_keys", ragged_keys);
            if (ragged_value_types != null) desc.SetAttr("ragged_value_types", ragged_value_types);
            if (ragged_split_types != null) desc.SetAttr("ragged_split_types", ragged_split_types);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ParseExampleDatasetV2
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="num_parallel_calls">Input to the operation. </param>
        /// <param name="dense_defaults">Input to the operation. </param>
        /// <param name="sparse_keys">sparse keys</param>
        /// <param name="dense_keys">dense keys</param>
        /// <param name="sparse_types">sparse types</param>
        /// <param name="dense_shapes">dense shapes</param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="deterministic">deterministic</param>
        /// <param name="ragged_keys">ragged keys</param>
        /// <param name="ragged_value_types">ragged value types</param>
        /// <param name="ragged_split_types">ragged split types</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ParseExampleDatasetV2(Output input_dataset, Output num_parallel_calls, Output dense_defaults, string[] sparse_keys, string[] dense_keys, DataType[] sparse_types, long[][] dense_shapes, DataType[] output_types, long[][] output_shapes, string deterministic = null, string[] ragged_keys = null, DataType[] ragged_value_types = null, DataType[] ragged_split_types = null, String opName = "ParseExampleDatasetV2") 
        {
            OperationDescription desc = NewOperation("ParseExampleDatasetV2", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(num_parallel_calls);
            desc.AddInput(dense_defaults);
            desc.SetAttr("sparse_keys", sparse_keys);
            desc.SetAttr("dense_keys", dense_keys);
            desc.SetAttr("sparse_types", sparse_types);
            desc.SetAttrShapeList("dense_shapes", dense_shapes);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (deterministic != null)
                 desc.SetAttr("deterministic", deterministic);
            if (ragged_keys != null) desc.SetAttr("ragged_keys", ragged_keys);
            if (ragged_value_types != null) desc.SetAttr("ragged_value_types", ragged_value_types);
            if (ragged_split_types != null) desc.SetAttr("ragged_split_types", ragged_split_types);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ParseExampleV2
        /// </summary>
        /// <param name="serialized">Input to the operation. </param>
        /// <param name="names">Input to the operation. </param>
        /// <param name="sparse_keys">Input to the operation. </param>
        /// <param name="dense_keys">Input to the operation. </param>
        /// <param name="ragged_keys">Input to the operation. </param>
        /// <param name="dense_defaults">Input to the operation. </param>
        /// <param name="num_sparse">num sparse</param>
        /// <param name="sparse_types">sparse types</param>
        /// <param name="ragged_value_types">ragged value types</param>
        /// <param name="ragged_split_types">ragged split types</param>
        /// <param name="dense_shapes">dense shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] sparse_indices(type: DtInt64).
        /// [1] sparse_values(type: DtInvalid).
        /// [2] sparse_shapes(type: DtInt64).
        /// [3] dense_values(type: DtInvalid).
        /// [4] ragged_values(type: DtInvalid).
        /// [5] ragged_row_splits(type: DtInvalid).
        /// </returns>
        public Operation ParseExampleV2(Output serialized, Output names, Output sparse_keys, Output dense_keys, Output ragged_keys, Output dense_defaults, long num_sparse, DataType[] sparse_types, DataType[] ragged_value_types, DataType[] ragged_split_types, long[][] dense_shapes, String opName = "ParseExampleV2") 
        {
            OperationDescription desc = NewOperation("ParseExampleV2", opName);
            desc.AddInput(serialized);
            desc.AddInput(names);
            desc.AddInput(sparse_keys);
            desc.AddInput(dense_keys);
            desc.AddInput(ragged_keys);
            desc.AddInput(dense_defaults);
            desc.SetAttr("num_sparse", num_sparse);
            desc.SetAttr("sparse_types", sparse_types);
            desc.SetAttr("ragged_value_types", ragged_value_types);
            desc.SetAttr("ragged_split_types", ragged_split_types);
            desc.SetAttrShapeList("dense_shapes", dense_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ParseSequenceExample
        /// </summary>
        /// <param name="serialized">Input to the operation. </param>
        /// <param name="debug_name">Input to the operation. </param>
        /// <param name="context_dense_defaults">Input to the operation. </param>
        /// <param name="feature_list_dense_missing_assumed_empty">feature list dense missing assumed empty</param>
        /// <param name="context_sparse_keys">context sparse keys</param>
        /// <param name="context_dense_keys">context dense keys</param>
        /// <param name="feature_list_sparse_keys">feature list sparse keys</param>
        /// <param name="feature_list_dense_keys">feature list dense keys</param>
        /// <param name="Ncontext_sparse">Ncontext sparse</param>
        /// <param name="Ncontext_dense">Ncontext dense</param>
        /// <param name="Nfeature_list_sparse">Nfeature list sparse</param>
        /// <param name="Nfeature_list_dense">Nfeature list dense</param>
        /// <param name="context_sparse_types">context sparse types</param>
        /// <param name="feature_list_dense_types">feature list dense types</param>
        /// <param name="context_dense_shapes">context dense shapes</param>
        /// <param name="feature_list_sparse_types">feature list sparse types</param>
        /// <param name="feature_list_dense_shapes">feature list dense shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] context_sparse_indices(type: DtInt64).
        /// [1] context_sparse_values(type: DtInvalid).
        /// [2] context_sparse_shapes(type: DtInt64).
        /// [3] context_dense_values(type: DtInvalid).
        /// [4] feature_list_sparse_indices(type: DtInt64).
        /// [5] feature_list_sparse_values(type: DtInvalid).
        /// [6] feature_list_sparse_shapes(type: DtInt64).
        /// [7] feature_list_dense_values(type: DtInvalid).
        /// [8] feature_list_dense_lengths(type: DtInt64).
        /// </returns>
        public Operation ParseSequenceExample(Output serialized, Output debug_name, Output context_dense_defaults, string[] feature_list_dense_missing_assumed_empty, string[] context_sparse_keys, string[] context_dense_keys, string[] feature_list_sparse_keys, string[] feature_list_dense_keys, long Ncontext_sparse = 0, long Ncontext_dense = 0, long Nfeature_list_sparse = 0, long Nfeature_list_dense = 0, DataType[] context_sparse_types = null, DataType[] feature_list_dense_types = null, long[][] context_dense_shapes = null, DataType[] feature_list_sparse_types = null, long[][] feature_list_dense_shapes = null, String opName = "ParseSequenceExample") 
        {
            OperationDescription desc = NewOperation("ParseSequenceExample", opName);
            desc.AddInput(serialized);
            desc.AddInput(debug_name);
            desc.AddInput(context_dense_defaults);
            desc.SetAttr("feature_list_dense_missing_assumed_empty", feature_list_dense_missing_assumed_empty);
            desc.SetAttr("context_sparse_keys", context_sparse_keys);
            desc.SetAttr("context_dense_keys", context_dense_keys);
            desc.SetAttr("feature_list_sparse_keys", feature_list_sparse_keys);
            desc.SetAttr("feature_list_dense_keys", feature_list_dense_keys);
            if (Ncontext_sparse != 0)
                desc.SetAttr("Ncontext_sparse", Ncontext_sparse);
            if (Ncontext_dense != 0)
                desc.SetAttr("Ncontext_dense", Ncontext_dense);
            if (Nfeature_list_sparse != 0)
                desc.SetAttr("Nfeature_list_sparse", Nfeature_list_sparse);
            if (Nfeature_list_dense != 0)
                desc.SetAttr("Nfeature_list_dense", Nfeature_list_dense);
            if (context_sparse_types != null) desc.SetAttr("context_sparse_types", context_sparse_types);
            if (feature_list_dense_types != null) desc.SetAttr("feature_list_dense_types", feature_list_dense_types);
            if (context_dense_shapes != null) desc.SetAttrShapeList("context_dense_shapes", context_dense_shapes);
            if (feature_list_sparse_types != null) desc.SetAttr("feature_list_sparse_types", feature_list_sparse_types);
            if (feature_list_dense_shapes != null) desc.SetAttrShapeList("feature_list_dense_shapes", feature_list_dense_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ParseSequenceExampleV2
        /// </summary>
        /// <param name="serialized">Input to the operation. </param>
        /// <param name="debug_name">Input to the operation. </param>
        /// <param name="context_sparse_keys">Input to the operation. </param>
        /// <param name="context_dense_keys">Input to the operation. </param>
        /// <param name="context_ragged_keys">Input to the operation. </param>
        /// <param name="feature_list_sparse_keys">Input to the operation. </param>
        /// <param name="feature_list_dense_keys">Input to the operation. </param>
        /// <param name="feature_list_ragged_keys">Input to the operation. </param>
        /// <param name="feature_list_dense_missing_assumed_empty">Input to the operation. </param>
        /// <param name="context_dense_defaults">Input to the operation. </param>
        /// <param name="Ncontext_sparse">Ncontext sparse</param>
        /// <param name="context_sparse_types">context sparse types</param>
        /// <param name="context_ragged_value_types">context ragged value types</param>
        /// <param name="context_ragged_split_types">context ragged split types</param>
        /// <param name="context_dense_shapes">context dense shapes</param>
        /// <param name="Nfeature_list_sparse">Nfeature list sparse</param>
        /// <param name="Nfeature_list_dense">Nfeature list dense</param>
        /// <param name="feature_list_dense_types">feature list dense types</param>
        /// <param name="feature_list_sparse_types">feature list sparse types</param>
        /// <param name="feature_list_ragged_value_types">feature list ragged value types</param>
        /// <param name="feature_list_ragged_split_types">feature list ragged split types</param>
        /// <param name="feature_list_dense_shapes">feature list dense shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] context_sparse_indices(type: DtInt64).
        /// [1] context_sparse_values(type: DtInvalid).
        /// [2] context_sparse_shapes(type: DtInt64).
        /// [3] context_dense_values(type: DtInvalid).
        /// [4] context_ragged_values(type: DtInvalid).
        /// [5] context_ragged_row_splits(type: DtInvalid).
        /// [6] feature_list_sparse_indices(type: DtInt64).
        /// [7] feature_list_sparse_values(type: DtInvalid).
        /// [8] feature_list_sparse_shapes(type: DtInt64).
        /// [9] feature_list_dense_values(type: DtInvalid).
        /// [10] feature_list_dense_lengths(type: DtInt64).
        /// [11] feature_list_ragged_values(type: DtInvalid).
        /// [12] feature_list_ragged_outer_splits(type: DtInvalid).
        /// [13] feature_list_ragged_inner_splits(type: DtInvalid).
        /// </returns>
        public Operation ParseSequenceExampleV2(Output serialized, Output debug_name, Output context_sparse_keys, Output context_dense_keys, Output context_ragged_keys, Output feature_list_sparse_keys, Output feature_list_dense_keys, Output feature_list_ragged_keys, Output feature_list_dense_missing_assumed_empty, Output context_dense_defaults, long Ncontext_sparse = 0, DataType[] context_sparse_types = null, DataType[] context_ragged_value_types = null, DataType[] context_ragged_split_types = null, long[][] context_dense_shapes = null, long Nfeature_list_sparse = 0, long Nfeature_list_dense = 0, DataType[] feature_list_dense_types = null, DataType[] feature_list_sparse_types = null, DataType[] feature_list_ragged_value_types = null, DataType[] feature_list_ragged_split_types = null, long[][] feature_list_dense_shapes = null, String opName = "ParseSequenceExampleV2") 
        {
            OperationDescription desc = NewOperation("ParseSequenceExampleV2", opName);
            desc.AddInput(serialized);
            desc.AddInput(debug_name);
            desc.AddInput(context_sparse_keys);
            desc.AddInput(context_dense_keys);
            desc.AddInput(context_ragged_keys);
            desc.AddInput(feature_list_sparse_keys);
            desc.AddInput(feature_list_dense_keys);
            desc.AddInput(feature_list_ragged_keys);
            desc.AddInput(feature_list_dense_missing_assumed_empty);
            desc.AddInput(context_dense_defaults);
            if (Ncontext_sparse != 0)
                desc.SetAttr("Ncontext_sparse", Ncontext_sparse);
            if (context_sparse_types != null) desc.SetAttr("context_sparse_types", context_sparse_types);
            if (context_ragged_value_types != null) desc.SetAttr("context_ragged_value_types", context_ragged_value_types);
            if (context_ragged_split_types != null) desc.SetAttr("context_ragged_split_types", context_ragged_split_types);
            if (context_dense_shapes != null) desc.SetAttrShapeList("context_dense_shapes", context_dense_shapes);
            if (Nfeature_list_sparse != 0)
                desc.SetAttr("Nfeature_list_sparse", Nfeature_list_sparse);
            if (Nfeature_list_dense != 0)
                desc.SetAttr("Nfeature_list_dense", Nfeature_list_dense);
            if (feature_list_dense_types != null) desc.SetAttr("feature_list_dense_types", feature_list_dense_types);
            if (feature_list_sparse_types != null) desc.SetAttr("feature_list_sparse_types", feature_list_sparse_types);
            if (feature_list_ragged_value_types != null) desc.SetAttr("feature_list_ragged_value_types", feature_list_ragged_value_types);
            if (feature_list_ragged_split_types != null) desc.SetAttr("feature_list_ragged_split_types", feature_list_ragged_split_types);
            if (feature_list_dense_shapes != null) desc.SetAttrShapeList("feature_list_dense_shapes", feature_list_dense_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ParseSingleExample
        /// </summary>
        /// <param name="serialized">Input to the operation. </param>
        /// <param name="dense_defaults">Input to the operation. </param>
        /// <param name="num_sparse">num sparse</param>
        /// <param name="sparse_keys">sparse keys</param>
        /// <param name="dense_keys">dense keys</param>
        /// <param name="sparse_types">sparse types</param>
        /// <param name="dense_shapes">dense shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] sparse_indices(type: DtInt64).
        /// [1] sparse_values(type: DtInvalid).
        /// [2] sparse_shapes(type: DtInt64).
        /// [3] dense_values(type: DtInvalid).
        /// </returns>
        public Operation ParseSingleExample(Output serialized, Output dense_defaults, long num_sparse, string[] sparse_keys, string[] dense_keys, DataType[] sparse_types, long[][] dense_shapes, String opName = "ParseSingleExample") 
        {
            OperationDescription desc = NewOperation("ParseSingleExample", opName);
            desc.AddInput(serialized);
            desc.AddInput(dense_defaults);
            desc.SetAttr("num_sparse", num_sparse);
            desc.SetAttr("sparse_keys", sparse_keys);
            desc.SetAttr("dense_keys", dense_keys);
            desc.SetAttr("sparse_types", sparse_types);
            desc.SetAttrShapeList("dense_shapes", dense_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ParseSingleSequenceExample
        /// </summary>
        /// <param name="serialized">Input to the operation. </param>
        /// <param name="feature_list_dense_missing_assumed_empty">Input to the operation. </param>
        /// <param name="context_sparse_keys">Input to the operation. </param>
        /// <param name="context_dense_keys">Input to the operation. </param>
        /// <param name="feature_list_sparse_keys">Input to the operation. </param>
        /// <param name="feature_list_dense_keys">Input to the operation. </param>
        /// <param name="context_dense_defaults">Input to the operation. </param>
        /// <param name="debug_name">Input to the operation. </param>
        /// <param name="context_sparse_types">context sparse types</param>
        /// <param name="feature_list_dense_types">feature list dense types</param>
        /// <param name="context_dense_shapes">context dense shapes</param>
        /// <param name="feature_list_sparse_types">feature list sparse types</param>
        /// <param name="feature_list_dense_shapes">feature list dense shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] context_sparse_indices(type: DtInt64).
        /// [1] context_sparse_values(type: DtInvalid).
        /// [2] context_sparse_shapes(type: DtInt64).
        /// [3] context_dense_values(type: DtInvalid).
        /// [4] feature_list_sparse_indices(type: DtInt64).
        /// [5] feature_list_sparse_values(type: DtInvalid).
        /// [6] feature_list_sparse_shapes(type: DtInt64).
        /// [7] feature_list_dense_values(type: DtInvalid).
        /// </returns>
        public Operation ParseSingleSequenceExample(Output serialized, Output feature_list_dense_missing_assumed_empty, Output context_sparse_keys, Output context_dense_keys, Output feature_list_sparse_keys, Output feature_list_dense_keys, Output context_dense_defaults, Output debug_name, DataType[] context_sparse_types = null, DataType[] feature_list_dense_types = null, long[][] context_dense_shapes = null, DataType[] feature_list_sparse_types = null, long[][] feature_list_dense_shapes = null, String opName = "ParseSingleSequenceExample") 
        {
            OperationDescription desc = NewOperation("ParseSingleSequenceExample", opName);
            desc.AddInput(serialized);
            desc.AddInput(feature_list_dense_missing_assumed_empty);
            desc.AddInput(context_sparse_keys);
            desc.AddInput(context_dense_keys);
            desc.AddInput(feature_list_sparse_keys);
            desc.AddInput(feature_list_dense_keys);
            desc.AddInput(context_dense_defaults);
            desc.AddInput(debug_name);
            if (context_sparse_types != null) desc.SetAttr("context_sparse_types", context_sparse_types);
            if (feature_list_dense_types != null) desc.SetAttr("feature_list_dense_types", feature_list_dense_types);
            if (context_dense_shapes != null) desc.SetAttrShapeList("context_dense_shapes", context_dense_shapes);
            if (feature_list_sparse_types != null) desc.SetAttr("feature_list_sparse_types", feature_list_sparse_types);
            if (feature_list_dense_shapes != null) desc.SetAttrShapeList("feature_list_dense_shapes", feature_list_dense_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ParseTensor
        /// </summary>
        /// <param name="serialized">Input to the operation. </param>
        /// <param name="out_type">out type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation ParseTensor(Output serialized, DataType out_type, String opName = "ParseTensor") 
        {
            OperationDescription desc = NewOperation("ParseTensor", opName);
            desc.AddInput(serialized);
            desc.SetAttr("out_type", out_type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// PartitionedCall
        /// </summary>
        /// <param name="args">Input to the operation. </param>
        /// <param name="Tout">Tout</param>
        /// <param name="config">config</param>
        /// <param name="config_proto">config proto</param>
        /// <param name="executor_type">executor type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        // The following attributes are not known: f: func
        public Operation PartitionedCall(Output args, DataType[] Tout, string config = null, string config_proto = null, string executor_type = null, String opName = "PartitionedCall") 
        {
            OperationDescription desc = NewOperation("PartitionedCall", opName);
            desc.AddInput(args);
            desc.SetAttr("Tout", Tout);
            if (config != null)
                 desc.SetAttr("config", config);
            if (config_proto != null)
                 desc.SetAttr("config_proto", config_proto);
            if (executor_type != null)
                 desc.SetAttr("executor_type", executor_type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Placeholder
        /// </summary>
        /// <param name="dtype">dtype</param>
        /// <param name="shape">shape</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Placeholder(DataType dtype, long[] shape = null, String opName = "Placeholder") 
        {
            OperationDescription desc = NewOperation("Placeholder", opName);
            desc.SetAttr("dtype", dtype);
            if (shape != null)
                 desc.SetAttrShape("shape", shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// PlaceholderV2
        /// </summary>
        /// <param name="dtype">dtype</param>
        /// <param name="shape">shape</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation PlaceholderV2(DataType dtype, long[] shape, String opName = "PlaceholderV2") 
        {
            OperationDescription desc = NewOperation("PlaceholderV2", opName);
            desc.SetAttr("dtype", dtype);
            desc.SetAttrShape("shape", shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// PlaceholderWithDefault
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="shape">shape</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation PlaceholderWithDefault(Output input, long[] shape, String opName = "PlaceholderWithDefault") 
        {
            OperationDescription desc = NewOperation("PlaceholderWithDefault", opName);
            desc.AddInput(input);
            desc.SetAttrShape("shape", shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Polygamma
        /// </summary>
        /// <param name="a">Input to the operation. </param>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation Polygamma(Output a, Output x, String opName = "Polygamma") 
        {
            OperationDescription desc = NewOperation("Polygamma", opName);
            desc.AddInput(a);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// PopulationCount
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtUint8).
        /// </returns>
        public Operation PopulationCount(Output x, String opName = "PopulationCount") 
        {
            OperationDescription desc = NewOperation("PopulationCount", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Pow
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation Pow(Output x, Output y, String opName = "Pow") 
        {
            OperationDescription desc = NewOperation("Pow", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// PrefetchDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="buffer_size">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="slack_period">slack period</param>
        /// <param name="legacy_autotune">legacy autotune</param>
        /// <param name="buffer_size_min">buffer size min</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation PrefetchDataset(Output input_dataset, Output buffer_size, DataType[] output_types, long[][] output_shapes, long slack_period = 0, bool legacy_autotune = true, long buffer_size_min = 0, string metadata = null, String opName = "PrefetchDataset") 
        {
            OperationDescription desc = NewOperation("PrefetchDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(buffer_size);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (slack_period != 0)
                desc.SetAttr("slack_period", slack_period);
            if (legacy_autotune != true)
                desc.SetAttr("legacy_autotune", legacy_autotune);
            if (buffer_size_min != 0)
                desc.SetAttr("buffer_size_min", buffer_size_min);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Prelinearize
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="shape">shape</param>
        /// <param name="layout">layout</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtVariant).
        /// </returns>
        public Operation Prelinearize(Output input, long[] shape = null, long[] layout = null, String opName = "Prelinearize") 
        {
            OperationDescription desc = NewOperation("Prelinearize", opName);
            desc.AddInput(input);
            if (shape != null)
                 desc.SetAttrShape("shape", shape);
            if (layout != null) desc.SetAttr("layout", layout);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// PrelinearizeTuple
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="shapes">shapes</param>
        /// <param name="layouts">layouts</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtVariant).
        /// </returns>
        public Operation PrelinearizeTuple(Output inputs, long[][] shapes, long[] layouts = null, String opName = "PrelinearizeTuple") 
        {
            OperationDescription desc = NewOperation("PrelinearizeTuple", opName);
            desc.AddInput(inputs);
            desc.SetAttrShapeList("shapes", shapes);
            if (layouts != null) desc.SetAttr("layouts", layouts);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// PreventGradient
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="message">message</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation PreventGradient(Output input, string message = null, String opName = "PreventGradient") 
        {
            OperationDescription desc = NewOperation("PreventGradient", opName);
            desc.AddInput(input);
            if (message != null)
                 desc.SetAttr("message", message);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Print
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="data">Input to the operation. </param>
        /// <param name="message">message</param>
        /// <param name="first_n">first n</param>
        /// <param name="summarize">summarize</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Print(Output input, Output data, string message = null, long first_n = -1, long summarize = 3, String opName = "Print") 
        {
            OperationDescription desc = NewOperation("Print", opName);
            desc.AddInput(input);
            desc.AddInput(data);
            if (message != null)
                 desc.SetAttr("message", message);
            if (first_n != -1)
                desc.SetAttr("first_n", first_n);
            if (summarize != 3)
                desc.SetAttr("summarize", summarize);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// PrintV2
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="output_stream">output stream</param>
        /// <param name="end">end</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation PrintV2(Output input, string output_stream = null, string end = null, String opName = "PrintV2") 
        {
            OperationDescription desc = NewOperation("PrintV2", opName);
            desc.AddInput(input);
            if (output_stream != null)
                 desc.SetAttr("output_stream", output_stream);
            if (end != null)
                 desc.SetAttr("end", end);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// PriorityQueue
        /// </summary>
        /// <param name="shapes">shapes</param>
        /// <param name="component_types">component types</param>
        /// <param name="capacity">capacity</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtString).
        /// </returns>
        public Operation PriorityQueue(long[][] shapes, DataType[] component_types = null, long capacity = -1, string container = null, string shared_name = null, String opName = "PriorityQueue") 
        {
            OperationDescription desc = NewOperation("PriorityQueue", opName);
            desc.SetAttrShapeList("shapes", shapes);
            if (component_types != null) desc.SetAttr("component_types", component_types);
            if (capacity != -1)
                desc.SetAttr("capacity", capacity);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// PriorityQueueV2
        /// </summary>
        /// <param name="shapes">shapes</param>
        /// <param name="component_types">component types</param>
        /// <param name="capacity">capacity</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// </returns>
        public Operation PriorityQueueV2(long[][] shapes, DataType[] component_types = null, long capacity = -1, string container = null, string shared_name = null, String opName = "PriorityQueueV2") 
        {
            OperationDescription desc = NewOperation("PriorityQueueV2", opName);
            desc.SetAttrShapeList("shapes", shapes);
            if (component_types != null) desc.SetAttr("component_types", component_types);
            if (capacity != -1)
                desc.SetAttr("capacity", capacity);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// PrivateThreadPoolDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="num_threads">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation PrivateThreadPoolDataset(Output input_dataset, Output num_threads, DataType[] output_types, long[][] output_shapes, String opName = "PrivateThreadPoolDataset") 
        {
            OperationDescription desc = NewOperation("PrivateThreadPoolDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(num_threads);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Prod
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="reduction_indices">Input to the operation. </param>
        /// <param name="keep_dims">keep dims</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Prod(Output input, Output reduction_indices, bool keep_dims = false, String opName = "Prod") 
        {
            OperationDescription desc = NewOperation("Prod", opName);
            desc.AddInput(input);
            desc.AddInput(reduction_indices);
            if (keep_dims != false)
                desc.SetAttr("keep_dims", keep_dims);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// PyFunc
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="token">token</param>
        /// <param name="Tout">Tout</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation PyFunc(Output input, string token, DataType[] Tout, String opName = "PyFunc") 
        {
            OperationDescription desc = NewOperation("PyFunc", opName);
            desc.AddInput(input);
            desc.SetAttr("token", token);
            desc.SetAttr("Tout", Tout);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// PyFuncStateless
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="token">token</param>
        /// <param name="Tout">Tout</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation PyFuncStateless(Output input, string token, DataType[] Tout, String opName = "PyFuncStateless") 
        {
            OperationDescription desc = NewOperation("PyFuncStateless", opName);
            desc.AddInput(input);
            desc.SetAttr("token", token);
            desc.SetAttr("Tout", Tout);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Qr
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="full_matrices">full matrices</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] q(type: DtInvalid).
        /// [1] r(type: DtInvalid).
        /// </returns>
        public Operation Qr(Output input, bool full_matrices = false, String opName = "Qr") 
        {
            OperationDescription desc = NewOperation("Qr", opName);
            desc.AddInput(input);
            if (full_matrices != false)
                desc.SetAttr("full_matrices", full_matrices);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizeAndDequantize
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="signed_input">signed input</param>
        /// <param name="num_bits">num bits</param>
        /// <param name="range_given">range given</param>
        /// <param name="input_min">input min</param>
        /// <param name="input_max">input max</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation QuantizeAndDequantize(Output input, bool signed_input = true, long num_bits = 8, bool range_given = false, float input_min = 0f, float input_max = 0f, String opName = "QuantizeAndDequantize") 
        {
            OperationDescription desc = NewOperation("QuantizeAndDequantize", opName);
            desc.AddInput(input);
            if (signed_input != true)
                desc.SetAttr("signed_input", signed_input);
            if (num_bits != 8)
                desc.SetAttr("num_bits", num_bits);
            if (range_given != false)
                desc.SetAttr("range_given", range_given);
            if (input_min != 0f)
                desc.SetAttr("input_min", input_min);
            if (input_max != 0f)
                desc.SetAttr("input_max", input_max);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizeAndDequantizeV2
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="input_min">Input to the operation. </param>
        /// <param name="input_max">Input to the operation. </param>
        /// <param name="signed_input">signed input</param>
        /// <param name="num_bits">num bits</param>
        /// <param name="range_given">range given</param>
        /// <param name="round_mode">round mode</param>
        /// <param name="narrow_range">narrow range</param>
        /// <param name="axis">axis</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation QuantizeAndDequantizeV2(Output input, Output input_min, Output input_max, bool signed_input = true, long num_bits = 8, bool range_given = false, string round_mode = null, bool narrow_range = false, long axis = -1, String opName = "QuantizeAndDequantizeV2") 
        {
            OperationDescription desc = NewOperation("QuantizeAndDequantizeV2", opName);
            desc.AddInput(input);
            desc.AddInput(input_min);
            desc.AddInput(input_max);
            if (signed_input != true)
                desc.SetAttr("signed_input", signed_input);
            if (num_bits != 8)
                desc.SetAttr("num_bits", num_bits);
            if (range_given != false)
                desc.SetAttr("range_given", range_given);
            if (round_mode != null)
                 desc.SetAttr("round_mode", round_mode);
            if (narrow_range != false)
                desc.SetAttr("narrow_range", narrow_range);
            if (axis != -1)
                desc.SetAttr("axis", axis);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizeAndDequantizeV3
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="input_min">Input to the operation. </param>
        /// <param name="input_max">Input to the operation. </param>
        /// <param name="num_bits">Input to the operation. </param>
        /// <param name="signed_input">signed input</param>
        /// <param name="range_given">range given</param>
        /// <param name="narrow_range">narrow range</param>
        /// <param name="axis">axis</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation QuantizeAndDequantizeV3(Output input, Output input_min, Output input_max, Output num_bits, bool signed_input = true, bool range_given = true, bool narrow_range = false, long axis = -1, String opName = "QuantizeAndDequantizeV3") 
        {
            OperationDescription desc = NewOperation("QuantizeAndDequantizeV3", opName);
            desc.AddInput(input);
            desc.AddInput(input_min);
            desc.AddInput(input_max);
            desc.AddInput(num_bits);
            if (signed_input != true)
                desc.SetAttr("signed_input", signed_input);
            if (range_given != true)
                desc.SetAttr("range_given", range_given);
            if (narrow_range != false)
                desc.SetAttr("narrow_range", narrow_range);
            if (axis != -1)
                desc.SetAttr("axis", axis);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizeAndDequantizeV4
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="input_min">Input to the operation. </param>
        /// <param name="input_max">Input to the operation. </param>
        /// <param name="signed_input">signed input</param>
        /// <param name="num_bits">num bits</param>
        /// <param name="range_given">range given</param>
        /// <param name="round_mode">round mode</param>
        /// <param name="narrow_range">narrow range</param>
        /// <param name="axis">axis</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation QuantizeAndDequantizeV4(Output input, Output input_min, Output input_max, bool signed_input = true, long num_bits = 8, bool range_given = false, string round_mode = null, bool narrow_range = false, long axis = -1, String opName = "QuantizeAndDequantizeV4") 
        {
            OperationDescription desc = NewOperation("QuantizeAndDequantizeV4", opName);
            desc.AddInput(input);
            desc.AddInput(input_min);
            desc.AddInput(input_max);
            if (signed_input != true)
                desc.SetAttr("signed_input", signed_input);
            if (num_bits != 8)
                desc.SetAttr("num_bits", num_bits);
            if (range_given != false)
                desc.SetAttr("range_given", range_given);
            if (round_mode != null)
                 desc.SetAttr("round_mode", round_mode);
            if (narrow_range != false)
                desc.SetAttr("narrow_range", narrow_range);
            if (axis != -1)
                desc.SetAttr("axis", axis);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizeAndDequantizeV4Grad
        /// </summary>
        /// <param name="gradients">Input to the operation. </param>
        /// <param name="input">Input to the operation. </param>
        /// <param name="input_min">Input to the operation. </param>
        /// <param name="input_max">Input to the operation. </param>
        /// <param name="axis">axis</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] input_backprop(type: DtInvalid).
        /// [1] input_min_backprop(type: DtInvalid).
        /// [2] input_max_backprop(type: DtInvalid).
        /// </returns>
        public Operation QuantizeAndDequantizeV4Grad(Output gradients, Output input, Output input_min, Output input_max, long axis = -1, String opName = "QuantizeAndDequantizeV4Grad") 
        {
            OperationDescription desc = NewOperation("QuantizeAndDequantizeV4Grad", opName);
            desc.AddInput(gradients);
            desc.AddInput(input);
            desc.AddInput(input_min);
            desc.AddInput(input_max);
            if (axis != -1)
                desc.SetAttr("axis", axis);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedAdd
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="min_x">Input to the operation. </param>
        /// <param name="max_x">Input to the operation. </param>
        /// <param name="min_y">Input to the operation. </param>
        /// <param name="max_y">Input to the operation. </param>
        /// <param name="Toutput">Toutput</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// [1] min_z(type: DtFloat).
        /// [2] max_z(type: DtFloat).
        /// </returns>
        public Operation QuantizedAdd(Output x, Output y, Output min_x, Output max_x, Output min_y, Output max_y, DataType? Toutput = null, String opName = "QuantizedAdd") 
        {
            OperationDescription desc = NewOperation("QuantizedAdd", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            desc.AddInput(min_x);
            desc.AddInput(max_x);
            desc.AddInput(min_y);
            desc.AddInput(max_y);
            if (Toutput.HasValue)
                desc.SetAttr("Toutput", Toutput.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedAvgPool
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="min_input">Input to the operation. </param>
        /// <param name="max_input">Input to the operation. </param>
        /// <param name="ksize">ksize</param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] min_output(type: DtFloat).
        /// [2] max_output(type: DtFloat).
        /// </returns>
        public Operation QuantizedAvgPool(Output input, Output min_input, Output max_input, long[] ksize, long[] strides, string padding, String opName = "QuantizedAvgPool") 
        {
            OperationDescription desc = NewOperation("QuantizedAvgPool", opName);
            desc.AddInput(input);
            desc.AddInput(min_input);
            desc.AddInput(max_input);
            desc.SetAttr("ksize", ksize);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedBatchNormWithGlobalNormalization
        /// </summary>
        /// <param name="t">Input to the operation. </param>
        /// <param name="t_min">Input to the operation. </param>
        /// <param name="t_max">Input to the operation. </param>
        /// <param name="m">Input to the operation. </param>
        /// <param name="m_min">Input to the operation. </param>
        /// <param name="m_max">Input to the operation. </param>
        /// <param name="v">Input to the operation. </param>
        /// <param name="v_min">Input to the operation. </param>
        /// <param name="v_max">Input to the operation. </param>
        /// <param name="beta">Input to the operation. </param>
        /// <param name="beta_min">Input to the operation. </param>
        /// <param name="beta_max">Input to the operation. </param>
        /// <param name="gamma">Input to the operation. </param>
        /// <param name="gamma_min">Input to the operation. </param>
        /// <param name="gamma_max">Input to the operation. </param>
        /// <param name="out_type">out type</param>
        /// <param name="variance_epsilon">variance epsilon</param>
        /// <param name="scale_after_normalization">scale after normalization</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] result(type: DtInvalid).
        /// [1] result_min(type: DtFloat).
        /// [2] result_max(type: DtFloat).
        /// </returns>
        public Operation QuantizedBatchNormWithGlobalNormalization(Output t, Output t_min, Output t_max, Output m, Output m_min, Output m_max, Output v, Output v_min, Output v_max, Output beta, Output beta_min, Output beta_max, Output gamma, Output gamma_min, Output gamma_max, DataType out_type, float variance_epsilon, bool scale_after_normalization, String opName = "QuantizedBatchNormWithGlobalNormalization") 
        {
            OperationDescription desc = NewOperation("QuantizedBatchNormWithGlobalNormalization", opName);
            desc.AddInput(t);
            desc.AddInput(t_min);
            desc.AddInput(t_max);
            desc.AddInput(m);
            desc.AddInput(m_min);
            desc.AddInput(m_max);
            desc.AddInput(v);
            desc.AddInput(v_min);
            desc.AddInput(v_max);
            desc.AddInput(beta);
            desc.AddInput(beta_min);
            desc.AddInput(beta_max);
            desc.AddInput(gamma);
            desc.AddInput(gamma_min);
            desc.AddInput(gamma_max);
            desc.SetAttr("out_type", out_type);
            desc.SetAttr("variance_epsilon", variance_epsilon);
            desc.SetAttr("scale_after_normalization", scale_after_normalization);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedBiasAdd
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="bias">Input to the operation. </param>
        /// <param name="min_input">Input to the operation. </param>
        /// <param name="max_input">Input to the operation. </param>
        /// <param name="min_bias">Input to the operation. </param>
        /// <param name="max_bias">Input to the operation. </param>
        /// <param name="out_type">out type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] min_out(type: DtFloat).
        /// [2] max_out(type: DtFloat).
        /// </returns>
        public Operation QuantizedBiasAdd(Output input, Output bias, Output min_input, Output max_input, Output min_bias, Output max_bias, DataType out_type, String opName = "QuantizedBiasAdd") 
        {
            OperationDescription desc = NewOperation("QuantizedBiasAdd", opName);
            desc.AddInput(input);
            desc.AddInput(bias);
            desc.AddInput(min_input);
            desc.AddInput(max_input);
            desc.AddInput(min_bias);
            desc.AddInput(max_bias);
            desc.SetAttr("out_type", out_type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedConcat
        /// </summary>
        /// <param name="concat_dim">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="input_mins">Input to the operation. </param>
        /// <param name="input_maxes">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] output_min(type: DtFloat).
        /// [2] output_max(type: DtFloat).
        /// </returns>
        public Operation QuantizedConcat(Output concat_dim, Output values, Output input_mins, Output input_maxes, String opName = "QuantizedConcat") 
        {
            OperationDescription desc = NewOperation("QuantizedConcat", opName);
            desc.AddInput(concat_dim);
            desc.AddInput(values);
            desc.AddInput(input_mins);
            desc.AddInput(input_maxes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedConcatV2
        /// </summary>
        /// <param name="values">Input to the operation. </param>
        /// <param name="axis">Input to the operation. </param>
        /// <param name="input_mins">Input to the operation. </param>
        /// <param name="input_maxes">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] output_min(type: DtFloat).
        /// [2] output_max(type: DtFloat).
        /// </returns>
        public Operation QuantizedConcatV2(Output values, Output axis, Output input_mins, Output input_maxes, String opName = "QuantizedConcatV2") 
        {
            OperationDescription desc = NewOperation("QuantizedConcatV2", opName);
            desc.AddInput(values);
            desc.AddInput(axis);
            desc.AddInput(input_mins);
            desc.AddInput(input_maxes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedConv2D
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="min_input">Input to the operation. </param>
        /// <param name="max_input">Input to the operation. </param>
        /// <param name="min_filter">Input to the operation. </param>
        /// <param name="max_filter">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="out_type">out type</param>
        /// <param name="dilations">dilations</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] min_output(type: DtFloat).
        /// [2] max_output(type: DtFloat).
        /// </returns>
        public Operation QuantizedConv2D(Output input, Output filter, Output min_input, Output max_input, Output min_filter, Output max_filter, long[] strides, string padding, DataType? out_type = null, long[] dilations = null, String opName = "QuantizedConv2D") 
        {
            OperationDescription desc = NewOperation("QuantizedConv2D", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.AddInput(min_input);
            desc.AddInput(max_input);
            desc.AddInput(min_filter);
            desc.AddInput(max_filter);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedConv2DAndRelu
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="min_input">Input to the operation. </param>
        /// <param name="max_input">Input to the operation. </param>
        /// <param name="min_filter">Input to the operation. </param>
        /// <param name="max_filter">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="out_type">out type</param>
        /// <param name="dilations">dilations</param>
        /// <param name="padding_list">padding list</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] min_output(type: DtFloat).
        /// [2] max_output(type: DtFloat).
        /// </returns>
        public Operation QuantizedConv2DAndRelu(Output input, Output filter, Output min_input, Output max_input, Output min_filter, Output max_filter, long[] strides, string padding, DataType? out_type = null, long[] dilations = null, long[] padding_list = null, String opName = "QuantizedConv2DAndRelu") 
        {
            OperationDescription desc = NewOperation("QuantizedConv2DAndRelu", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.AddInput(min_input);
            desc.AddInput(max_input);
            desc.AddInput(min_filter);
            desc.AddInput(max_filter);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            if (padding_list != null) desc.SetAttr("padding_list", padding_list);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedConv2DAndReluAndRequantize
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="min_input">Input to the operation. </param>
        /// <param name="max_input">Input to the operation. </param>
        /// <param name="min_filter">Input to the operation. </param>
        /// <param name="max_filter">Input to the operation. </param>
        /// <param name="min_freezed_output">Input to the operation. </param>
        /// <param name="max_freezed_output">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="out_type">out type</param>
        /// <param name="dilations">dilations</param>
        /// <param name="padding_list">padding list</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] min_output(type: DtFloat).
        /// [2] max_output(type: DtFloat).
        /// </returns>
        public Operation QuantizedConv2DAndReluAndRequantize(Output input, Output filter, Output min_input, Output max_input, Output min_filter, Output max_filter, Output min_freezed_output, Output max_freezed_output, long[] strides, string padding, DataType? out_type = null, long[] dilations = null, long[] padding_list = null, String opName = "QuantizedConv2DAndReluAndRequantize") 
        {
            OperationDescription desc = NewOperation("QuantizedConv2DAndReluAndRequantize", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.AddInput(min_input);
            desc.AddInput(max_input);
            desc.AddInput(min_filter);
            desc.AddInput(max_filter);
            desc.AddInput(min_freezed_output);
            desc.AddInput(max_freezed_output);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            if (padding_list != null) desc.SetAttr("padding_list", padding_list);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedConv2DAndRequantize
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="min_input">Input to the operation. </param>
        /// <param name="max_input">Input to the operation. </param>
        /// <param name="min_filter">Input to the operation. </param>
        /// <param name="max_filter">Input to the operation. </param>
        /// <param name="min_freezed_output">Input to the operation. </param>
        /// <param name="max_freezed_output">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="out_type">out type</param>
        /// <param name="dilations">dilations</param>
        /// <param name="padding_list">padding list</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] min_output(type: DtFloat).
        /// [2] max_output(type: DtFloat).
        /// </returns>
        public Operation QuantizedConv2DAndRequantize(Output input, Output filter, Output min_input, Output max_input, Output min_filter, Output max_filter, Output min_freezed_output, Output max_freezed_output, long[] strides, string padding, DataType? out_type = null, long[] dilations = null, long[] padding_list = null, String opName = "QuantizedConv2DAndRequantize") 
        {
            OperationDescription desc = NewOperation("QuantizedConv2DAndRequantize", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.AddInput(min_input);
            desc.AddInput(max_input);
            desc.AddInput(min_filter);
            desc.AddInput(max_filter);
            desc.AddInput(min_freezed_output);
            desc.AddInput(max_freezed_output);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            if (padding_list != null) desc.SetAttr("padding_list", padding_list);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedConv2DPerChannel
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="min_input">Input to the operation. </param>
        /// <param name="max_input">Input to the operation. </param>
        /// <param name="min_filter">Input to the operation. </param>
        /// <param name="max_filter">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="out_type">out type</param>
        /// <param name="dilations">dilations</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] min_output(type: DtFloat).
        /// [2] max_output(type: DtFloat).
        /// </returns>
        public Operation QuantizedConv2DPerChannel(Output input, Output filter, Output min_input, Output max_input, Output min_filter, Output max_filter, long[] strides, string padding, DataType? out_type = null, long[] dilations = null, String opName = "QuantizedConv2DPerChannel") 
        {
            OperationDescription desc = NewOperation("QuantizedConv2DPerChannel", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.AddInput(min_input);
            desc.AddInput(max_input);
            desc.AddInput(min_filter);
            desc.AddInput(max_filter);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedConv2DWithBias
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="bias">Input to the operation. </param>
        /// <param name="min_input">Input to the operation. </param>
        /// <param name="max_input">Input to the operation. </param>
        /// <param name="min_filter">Input to the operation. </param>
        /// <param name="max_filter">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="out_type">out type</param>
        /// <param name="dilations">dilations</param>
        /// <param name="padding_list">padding list</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] min_output(type: DtFloat).
        /// [2] max_output(type: DtFloat).
        /// </returns>
        public Operation QuantizedConv2DWithBias(Output input, Output filter, Output bias, Output min_input, Output max_input, Output min_filter, Output max_filter, long[] strides, string padding, DataType? out_type = null, long[] dilations = null, long[] padding_list = null, String opName = "QuantizedConv2DWithBias") 
        {
            OperationDescription desc = NewOperation("QuantizedConv2DWithBias", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.AddInput(bias);
            desc.AddInput(min_input);
            desc.AddInput(max_input);
            desc.AddInput(min_filter);
            desc.AddInput(max_filter);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            if (padding_list != null) desc.SetAttr("padding_list", padding_list);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedConv2DWithBiasAndRelu
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="bias">Input to the operation. </param>
        /// <param name="min_input">Input to the operation. </param>
        /// <param name="max_input">Input to the operation. </param>
        /// <param name="min_filter">Input to the operation. </param>
        /// <param name="max_filter">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="out_type">out type</param>
        /// <param name="dilations">dilations</param>
        /// <param name="padding_list">padding list</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] min_output(type: DtFloat).
        /// [2] max_output(type: DtFloat).
        /// </returns>
        public Operation QuantizedConv2DWithBiasAndRelu(Output input, Output filter, Output bias, Output min_input, Output max_input, Output min_filter, Output max_filter, long[] strides, string padding, DataType? out_type = null, long[] dilations = null, long[] padding_list = null, String opName = "QuantizedConv2DWithBiasAndRelu") 
        {
            OperationDescription desc = NewOperation("QuantizedConv2DWithBiasAndRelu", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.AddInput(bias);
            desc.AddInput(min_input);
            desc.AddInput(max_input);
            desc.AddInput(min_filter);
            desc.AddInput(max_filter);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            if (padding_list != null) desc.SetAttr("padding_list", padding_list);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedConv2DWithBiasAndReluAndRequantize
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="bias">Input to the operation. </param>
        /// <param name="min_input">Input to the operation. </param>
        /// <param name="max_input">Input to the operation. </param>
        /// <param name="min_filter">Input to the operation. </param>
        /// <param name="max_filter">Input to the operation. </param>
        /// <param name="min_freezed_output">Input to the operation. </param>
        /// <param name="max_freezed_output">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="out_type">out type</param>
        /// <param name="dilations">dilations</param>
        /// <param name="padding_list">padding list</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] min_output(type: DtFloat).
        /// [2] max_output(type: DtFloat).
        /// </returns>
        public Operation QuantizedConv2DWithBiasAndReluAndRequantize(Output input, Output filter, Output bias, Output min_input, Output max_input, Output min_filter, Output max_filter, Output min_freezed_output, Output max_freezed_output, long[] strides, string padding, DataType? out_type = null, long[] dilations = null, long[] padding_list = null, String opName = "QuantizedConv2DWithBiasAndReluAndRequantize") 
        {
            OperationDescription desc = NewOperation("QuantizedConv2DWithBiasAndReluAndRequantize", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.AddInput(bias);
            desc.AddInput(min_input);
            desc.AddInput(max_input);
            desc.AddInput(min_filter);
            desc.AddInput(max_filter);
            desc.AddInput(min_freezed_output);
            desc.AddInput(max_freezed_output);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            if (padding_list != null) desc.SetAttr("padding_list", padding_list);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedConv2DWithBiasAndRequantize
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="bias">Input to the operation. </param>
        /// <param name="min_input">Input to the operation. </param>
        /// <param name="max_input">Input to the operation. </param>
        /// <param name="min_filter">Input to the operation. </param>
        /// <param name="max_filter">Input to the operation. </param>
        /// <param name="min_freezed_output">Input to the operation. </param>
        /// <param name="max_freezed_output">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="out_type">out type</param>
        /// <param name="dilations">dilations</param>
        /// <param name="padding_list">padding list</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] min_output(type: DtFloat).
        /// [2] max_output(type: DtFloat).
        /// </returns>
        public Operation QuantizedConv2DWithBiasAndRequantize(Output input, Output filter, Output bias, Output min_input, Output max_input, Output min_filter, Output max_filter, Output min_freezed_output, Output max_freezed_output, long[] strides, string padding, DataType? out_type = null, long[] dilations = null, long[] padding_list = null, String opName = "QuantizedConv2DWithBiasAndRequantize") 
        {
            OperationDescription desc = NewOperation("QuantizedConv2DWithBiasAndRequantize", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.AddInput(bias);
            desc.AddInput(min_input);
            desc.AddInput(max_input);
            desc.AddInput(min_filter);
            desc.AddInput(max_filter);
            desc.AddInput(min_freezed_output);
            desc.AddInput(max_freezed_output);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            if (padding_list != null) desc.SetAttr("padding_list", padding_list);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedConv2DWithBiasSignedSumAndReluAndRequantize
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="bias">Input to the operation. </param>
        /// <param name="min_input">Input to the operation. </param>
        /// <param name="max_input">Input to the operation. </param>
        /// <param name="min_filter">Input to the operation. </param>
        /// <param name="max_filter">Input to the operation. </param>
        /// <param name="min_freezed_output">Input to the operation. </param>
        /// <param name="max_freezed_output">Input to the operation. </param>
        /// <param name="summand">Input to the operation. </param>
        /// <param name="min_summand">Input to the operation. </param>
        /// <param name="max_summand">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="out_type">out type</param>
        /// <param name="dilations">dilations</param>
        /// <param name="padding_list">padding list</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] min_output(type: DtFloat).
        /// [2] max_output(type: DtFloat).
        /// </returns>
        public Operation QuantizedConv2DWithBiasSignedSumAndReluAndRequantize(Output input, Output filter, Output bias, Output min_input, Output max_input, Output min_filter, Output max_filter, Output min_freezed_output, Output max_freezed_output, Output summand, Output min_summand, Output max_summand, long[] strides, string padding, DataType? out_type = null, long[] dilations = null, long[] padding_list = null, String opName = "QuantizedConv2DWithBiasSignedSumAndReluAndRequantize") 
        {
            OperationDescription desc = NewOperation("QuantizedConv2DWithBiasSignedSumAndReluAndRequantize", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.AddInput(bias);
            desc.AddInput(min_input);
            desc.AddInput(max_input);
            desc.AddInput(min_filter);
            desc.AddInput(max_filter);
            desc.AddInput(min_freezed_output);
            desc.AddInput(max_freezed_output);
            desc.AddInput(summand);
            desc.AddInput(min_summand);
            desc.AddInput(max_summand);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            if (padding_list != null) desc.SetAttr("padding_list", padding_list);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedConv2DWithBiasSumAndRelu
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="bias">Input to the operation. </param>
        /// <param name="min_input">Input to the operation. </param>
        /// <param name="max_input">Input to the operation. </param>
        /// <param name="min_filter">Input to the operation. </param>
        /// <param name="max_filter">Input to the operation. </param>
        /// <param name="summand">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="out_type">out type</param>
        /// <param name="dilations">dilations</param>
        /// <param name="padding_list">padding list</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] min_output(type: DtFloat).
        /// [2] max_output(type: DtFloat).
        /// </returns>
        public Operation QuantizedConv2DWithBiasSumAndRelu(Output input, Output filter, Output bias, Output min_input, Output max_input, Output min_filter, Output max_filter, Output summand, long[] strides, string padding, DataType? out_type = null, long[] dilations = null, long[] padding_list = null, String opName = "QuantizedConv2DWithBiasSumAndRelu") 
        {
            OperationDescription desc = NewOperation("QuantizedConv2DWithBiasSumAndRelu", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.AddInput(bias);
            desc.AddInput(min_input);
            desc.AddInput(max_input);
            desc.AddInput(min_filter);
            desc.AddInput(max_filter);
            desc.AddInput(summand);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            if (padding_list != null) desc.SetAttr("padding_list", padding_list);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedConv2DWithBiasSumAndReluAndRequantize
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="bias">Input to the operation. </param>
        /// <param name="min_input">Input to the operation. </param>
        /// <param name="max_input">Input to the operation. </param>
        /// <param name="min_filter">Input to the operation. </param>
        /// <param name="max_filter">Input to the operation. </param>
        /// <param name="min_freezed_output">Input to the operation. </param>
        /// <param name="max_freezed_output">Input to the operation. </param>
        /// <param name="summand">Input to the operation. </param>
        /// <param name="min_summand">Input to the operation. </param>
        /// <param name="max_summand">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="out_type">out type</param>
        /// <param name="dilations">dilations</param>
        /// <param name="padding_list">padding list</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] min_output(type: DtFloat).
        /// [2] max_output(type: DtFloat).
        /// </returns>
        public Operation QuantizedConv2DWithBiasSumAndReluAndRequantize(Output input, Output filter, Output bias, Output min_input, Output max_input, Output min_filter, Output max_filter, Output min_freezed_output, Output max_freezed_output, Output summand, Output min_summand, Output max_summand, long[] strides, string padding, DataType? out_type = null, long[] dilations = null, long[] padding_list = null, String opName = "QuantizedConv2DWithBiasSumAndReluAndRequantize") 
        {
            OperationDescription desc = NewOperation("QuantizedConv2DWithBiasSumAndReluAndRequantize", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.AddInput(bias);
            desc.AddInput(min_input);
            desc.AddInput(max_input);
            desc.AddInput(min_filter);
            desc.AddInput(max_filter);
            desc.AddInput(min_freezed_output);
            desc.AddInput(max_freezed_output);
            desc.AddInput(summand);
            desc.AddInput(min_summand);
            desc.AddInput(max_summand);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            if (padding_list != null) desc.SetAttr("padding_list", padding_list);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedDepthwiseConv2D
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="min_input">Input to the operation. </param>
        /// <param name="max_input">Input to the operation. </param>
        /// <param name="min_filter">Input to the operation. </param>
        /// <param name="max_filter">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="out_type">out type</param>
        /// <param name="dilations">dilations</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] min_output(type: DtFloat).
        /// [2] max_output(type: DtFloat).
        /// </returns>
        public Operation QuantizedDepthwiseConv2D(Output input, Output filter, Output min_input, Output max_input, Output min_filter, Output max_filter, long[] strides, string padding, DataType? out_type = null, long[] dilations = null, String opName = "QuantizedDepthwiseConv2D") 
        {
            OperationDescription desc = NewOperation("QuantizedDepthwiseConv2D", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.AddInput(min_input);
            desc.AddInput(max_input);
            desc.AddInput(min_filter);
            desc.AddInput(max_filter);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedDepthwiseConv2DWithBias
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="bias">Input to the operation. </param>
        /// <param name="min_input">Input to the operation. </param>
        /// <param name="max_input">Input to the operation. </param>
        /// <param name="min_filter">Input to the operation. </param>
        /// <param name="max_filter">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="out_type">out type</param>
        /// <param name="dilations">dilations</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] min_output(type: DtFloat).
        /// [2] max_output(type: DtFloat).
        /// </returns>
        public Operation QuantizedDepthwiseConv2DWithBias(Output input, Output filter, Output bias, Output min_input, Output max_input, Output min_filter, Output max_filter, long[] strides, string padding, DataType? out_type = null, long[] dilations = null, String opName = "QuantizedDepthwiseConv2DWithBias") 
        {
            OperationDescription desc = NewOperation("QuantizedDepthwiseConv2DWithBias", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.AddInput(bias);
            desc.AddInput(min_input);
            desc.AddInput(max_input);
            desc.AddInput(min_filter);
            desc.AddInput(max_filter);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedDepthwiseConv2DWithBiasAndRelu
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="bias">Input to the operation. </param>
        /// <param name="min_input">Input to the operation. </param>
        /// <param name="max_input">Input to the operation. </param>
        /// <param name="min_filter">Input to the operation. </param>
        /// <param name="max_filter">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="out_type">out type</param>
        /// <param name="dilations">dilations</param>
        /// <param name="padding_list">padding list</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] min_output(type: DtFloat).
        /// [2] max_output(type: DtFloat).
        /// </returns>
        public Operation QuantizedDepthwiseConv2DWithBiasAndRelu(Output input, Output filter, Output bias, Output min_input, Output max_input, Output min_filter, Output max_filter, long[] strides, string padding, DataType? out_type = null, long[] dilations = null, long[] padding_list = null, String opName = "QuantizedDepthwiseConv2DWithBiasAndRelu") 
        {
            OperationDescription desc = NewOperation("QuantizedDepthwiseConv2DWithBiasAndRelu", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.AddInput(bias);
            desc.AddInput(min_input);
            desc.AddInput(max_input);
            desc.AddInput(min_filter);
            desc.AddInput(max_filter);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            if (padding_list != null) desc.SetAttr("padding_list", padding_list);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="bias">Input to the operation. </param>
        /// <param name="min_input">Input to the operation. </param>
        /// <param name="max_input">Input to the operation. </param>
        /// <param name="min_filter">Input to the operation. </param>
        /// <param name="max_filter">Input to the operation. </param>
        /// <param name="min_freezed_output">Input to the operation. </param>
        /// <param name="max_freezed_output">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="out_type">out type</param>
        /// <param name="dilations">dilations</param>
        /// <param name="padding_list">padding list</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] min_output(type: DtFloat).
        /// [2] max_output(type: DtFloat).
        /// </returns>
        public Operation QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize(Output input, Output filter, Output bias, Output min_input, Output max_input, Output min_filter, Output max_filter, Output min_freezed_output, Output max_freezed_output, long[] strides, string padding, DataType? out_type = null, long[] dilations = null, long[] padding_list = null, String opName = "QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize") 
        {
            OperationDescription desc = NewOperation("QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.AddInput(bias);
            desc.AddInput(min_input);
            desc.AddInput(max_input);
            desc.AddInput(min_filter);
            desc.AddInput(max_filter);
            desc.AddInput(min_freezed_output);
            desc.AddInput(max_freezed_output);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            if (padding_list != null) desc.SetAttr("padding_list", padding_list);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedInstanceNorm
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="x_min">Input to the operation. </param>
        /// <param name="x_max">Input to the operation. </param>
        /// <param name="output_range_given">output range given</param>
        /// <param name="given_y_min">given y min</param>
        /// <param name="given_y_max">given y max</param>
        /// <param name="variance_epsilon">variance epsilon</param>
        /// <param name="min_separation">min separation</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// [1] y_min(type: DtFloat).
        /// [2] y_max(type: DtFloat).
        /// </returns>
        public Operation QuantizedInstanceNorm(Output x, Output x_min, Output x_max, bool output_range_given = false, float given_y_min = 0f, float given_y_max = 0f, float variance_epsilon = 1E-05f, float min_separation = 0.001f, String opName = "QuantizedInstanceNorm") 
        {
            OperationDescription desc = NewOperation("QuantizedInstanceNorm", opName);
            desc.AddInput(x);
            desc.AddInput(x_min);
            desc.AddInput(x_max);
            if (output_range_given != false)
                desc.SetAttr("output_range_given", output_range_given);
            if (given_y_min != 0f)
                desc.SetAttr("given_y_min", given_y_min);
            if (given_y_max != 0f)
                desc.SetAttr("given_y_max", given_y_max);
            if (variance_epsilon != 1E-05f)
                desc.SetAttr("variance_epsilon", variance_epsilon);
            if (min_separation != 0.001f)
                desc.SetAttr("min_separation", min_separation);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedMatMul
        /// </summary>
        /// <param name="a">Input to the operation. </param>
        /// <param name="b">Input to the operation. </param>
        /// <param name="min_a">Input to the operation. </param>
        /// <param name="max_a">Input to the operation. </param>
        /// <param name="min_b">Input to the operation. </param>
        /// <param name="max_b">Input to the operation. </param>
        /// <param name="Toutput">Toutput</param>
        /// <param name="transpose_a">transpose a</param>
        /// <param name="transpose_b">transpose b</param>
        /// <param name="Tactivation">Tactivation</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// [1] min_out(type: DtFloat).
        /// [2] max_out(type: DtFloat).
        /// </returns>
        public Operation QuantizedMatMul(Output a, Output b, Output min_a, Output max_a, Output min_b, Output max_b, DataType? Toutput = null, bool transpose_a = false, bool transpose_b = false, DataType? Tactivation = null, String opName = "QuantizedMatMul") 
        {
            OperationDescription desc = NewOperation("QuantizedMatMul", opName);
            desc.AddInput(a);
            desc.AddInput(b);
            desc.AddInput(min_a);
            desc.AddInput(max_a);
            desc.AddInput(min_b);
            desc.AddInput(max_b);
            if (Toutput.HasValue)
                desc.SetAttr("Toutput", Toutput.Value);
            if (transpose_a != false)
                desc.SetAttr("transpose_a", transpose_a);
            if (transpose_b != false)
                desc.SetAttr("transpose_b", transpose_b);
            if (Tactivation.HasValue)
                desc.SetAttr("Tactivation", Tactivation.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedMatMulWithBias
        /// </summary>
        /// <param name="a">Input to the operation. </param>
        /// <param name="b">Input to the operation. </param>
        /// <param name="bias">Input to the operation. </param>
        /// <param name="min_a">Input to the operation. </param>
        /// <param name="max_a">Input to the operation. </param>
        /// <param name="min_b">Input to the operation. </param>
        /// <param name="max_b">Input to the operation. </param>
        /// <param name="Toutput">Toutput</param>
        /// <param name="transpose_a">transpose a</param>
        /// <param name="transpose_b">transpose b</param>
        /// <param name="input_quant_mode">input quant mode</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// [1] min_out(type: DtFloat).
        /// [2] max_out(type: DtFloat).
        /// </returns>
        public Operation QuantizedMatMulWithBias(Output a, Output b, Output bias, Output min_a, Output max_a, Output min_b, Output max_b, DataType? Toutput = null, bool transpose_a = false, bool transpose_b = false, string input_quant_mode = null, String opName = "QuantizedMatMulWithBias") 
        {
            OperationDescription desc = NewOperation("QuantizedMatMulWithBias", opName);
            desc.AddInput(a);
            desc.AddInput(b);
            desc.AddInput(bias);
            desc.AddInput(min_a);
            desc.AddInput(max_a);
            desc.AddInput(min_b);
            desc.AddInput(max_b);
            if (Toutput.HasValue)
                desc.SetAttr("Toutput", Toutput.Value);
            if (transpose_a != false)
                desc.SetAttr("transpose_a", transpose_a);
            if (transpose_b != false)
                desc.SetAttr("transpose_b", transpose_b);
            if (input_quant_mode != null)
                 desc.SetAttr("input_quant_mode", input_quant_mode);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedMatMulWithBiasAndDequantize
        /// </summary>
        /// <param name="a">Input to the operation. </param>
        /// <param name="b">Input to the operation. </param>
        /// <param name="bias">Input to the operation. </param>
        /// <param name="min_a">Input to the operation. </param>
        /// <param name="max_a">Input to the operation. </param>
        /// <param name="min_b">Input to the operation. </param>
        /// <param name="max_b">Input to the operation. </param>
        /// <param name="min_freezed_output">Input to the operation. </param>
        /// <param name="max_freezed_output">Input to the operation. </param>
        /// <param name="Toutput">Toutput</param>
        /// <param name="transpose_a">transpose a</param>
        /// <param name="transpose_b">transpose b</param>
        /// <param name="input_quant_mode">input quant mode</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation QuantizedMatMulWithBiasAndDequantize(Output a, Output b, Output bias, Output min_a, Output max_a, Output min_b, Output max_b, Output min_freezed_output, Output max_freezed_output, DataType Toutput, bool transpose_a = false, bool transpose_b = false, string input_quant_mode = null, String opName = "QuantizedMatMulWithBiasAndDequantize") 
        {
            OperationDescription desc = NewOperation("QuantizedMatMulWithBiasAndDequantize", opName);
            desc.AddInput(a);
            desc.AddInput(b);
            desc.AddInput(bias);
            desc.AddInput(min_a);
            desc.AddInput(max_a);
            desc.AddInput(min_b);
            desc.AddInput(max_b);
            desc.AddInput(min_freezed_output);
            desc.AddInput(max_freezed_output);
            desc.SetAttr("Toutput", Toutput);
            if (transpose_a != false)
                desc.SetAttr("transpose_a", transpose_a);
            if (transpose_b != false)
                desc.SetAttr("transpose_b", transpose_b);
            if (input_quant_mode != null)
                 desc.SetAttr("input_quant_mode", input_quant_mode);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedMatMulWithBiasAndRelu
        /// </summary>
        /// <param name="a">Input to the operation. </param>
        /// <param name="b">Input to the operation. </param>
        /// <param name="bias">Input to the operation. </param>
        /// <param name="min_a">Input to the operation. </param>
        /// <param name="max_a">Input to the operation. </param>
        /// <param name="min_b">Input to the operation. </param>
        /// <param name="max_b">Input to the operation. </param>
        /// <param name="Toutput">Toutput</param>
        /// <param name="transpose_a">transpose a</param>
        /// <param name="transpose_b">transpose b</param>
        /// <param name="input_quant_mode">input quant mode</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// [1] min_out(type: DtFloat).
        /// [2] max_out(type: DtFloat).
        /// </returns>
        public Operation QuantizedMatMulWithBiasAndRelu(Output a, Output b, Output bias, Output min_a, Output max_a, Output min_b, Output max_b, DataType? Toutput = null, bool transpose_a = false, bool transpose_b = false, string input_quant_mode = null, String opName = "QuantizedMatMulWithBiasAndRelu") 
        {
            OperationDescription desc = NewOperation("QuantizedMatMulWithBiasAndRelu", opName);
            desc.AddInput(a);
            desc.AddInput(b);
            desc.AddInput(bias);
            desc.AddInput(min_a);
            desc.AddInput(max_a);
            desc.AddInput(min_b);
            desc.AddInput(max_b);
            if (Toutput.HasValue)
                desc.SetAttr("Toutput", Toutput.Value);
            if (transpose_a != false)
                desc.SetAttr("transpose_a", transpose_a);
            if (transpose_b != false)
                desc.SetAttr("transpose_b", transpose_b);
            if (input_quant_mode != null)
                 desc.SetAttr("input_quant_mode", input_quant_mode);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedMatMulWithBiasAndReluAndRequantize
        /// </summary>
        /// <param name="a">Input to the operation. </param>
        /// <param name="b">Input to the operation. </param>
        /// <param name="bias">Input to the operation. </param>
        /// <param name="min_a">Input to the operation. </param>
        /// <param name="max_a">Input to the operation. </param>
        /// <param name="min_b">Input to the operation. </param>
        /// <param name="max_b">Input to the operation. </param>
        /// <param name="min_freezed_output">Input to the operation. </param>
        /// <param name="max_freezed_output">Input to the operation. </param>
        /// <param name="Toutput">Toutput</param>
        /// <param name="transpose_a">transpose a</param>
        /// <param name="transpose_b">transpose b</param>
        /// <param name="input_quant_mode">input quant mode</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// [1] min_out(type: DtFloat).
        /// [2] max_out(type: DtFloat).
        /// </returns>
        public Operation QuantizedMatMulWithBiasAndReluAndRequantize(Output a, Output b, Output bias, Output min_a, Output max_a, Output min_b, Output max_b, Output min_freezed_output, Output max_freezed_output, DataType? Toutput = null, bool transpose_a = false, bool transpose_b = false, string input_quant_mode = null, String opName = "QuantizedMatMulWithBiasAndReluAndRequantize") 
        {
            OperationDescription desc = NewOperation("QuantizedMatMulWithBiasAndReluAndRequantize", opName);
            desc.AddInput(a);
            desc.AddInput(b);
            desc.AddInput(bias);
            desc.AddInput(min_a);
            desc.AddInput(max_a);
            desc.AddInput(min_b);
            desc.AddInput(max_b);
            desc.AddInput(min_freezed_output);
            desc.AddInput(max_freezed_output);
            if (Toutput.HasValue)
                desc.SetAttr("Toutput", Toutput.Value);
            if (transpose_a != false)
                desc.SetAttr("transpose_a", transpose_a);
            if (transpose_b != false)
                desc.SetAttr("transpose_b", transpose_b);
            if (input_quant_mode != null)
                 desc.SetAttr("input_quant_mode", input_quant_mode);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedMatMulWithBiasAndRequantize
        /// </summary>
        /// <param name="a">Input to the operation. </param>
        /// <param name="b">Input to the operation. </param>
        /// <param name="bias">Input to the operation. </param>
        /// <param name="min_a">Input to the operation. </param>
        /// <param name="max_a">Input to the operation. </param>
        /// <param name="min_b">Input to the operation. </param>
        /// <param name="max_b">Input to the operation. </param>
        /// <param name="min_freezed_output">Input to the operation. </param>
        /// <param name="max_freezed_output">Input to the operation. </param>
        /// <param name="Toutput">Toutput</param>
        /// <param name="transpose_a">transpose a</param>
        /// <param name="transpose_b">transpose b</param>
        /// <param name="input_quant_mode">input quant mode</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// [1] min_out(type: DtFloat).
        /// [2] max_out(type: DtFloat).
        /// </returns>
        public Operation QuantizedMatMulWithBiasAndRequantize(Output a, Output b, Output bias, Output min_a, Output max_a, Output min_b, Output max_b, Output min_freezed_output, Output max_freezed_output, DataType? Toutput = null, bool transpose_a = false, bool transpose_b = false, string input_quant_mode = null, String opName = "QuantizedMatMulWithBiasAndRequantize") 
        {
            OperationDescription desc = NewOperation("QuantizedMatMulWithBiasAndRequantize", opName);
            desc.AddInput(a);
            desc.AddInput(b);
            desc.AddInput(bias);
            desc.AddInput(min_a);
            desc.AddInput(max_a);
            desc.AddInput(min_b);
            desc.AddInput(max_b);
            desc.AddInput(min_freezed_output);
            desc.AddInput(max_freezed_output);
            if (Toutput.HasValue)
                desc.SetAttr("Toutput", Toutput.Value);
            if (transpose_a != false)
                desc.SetAttr("transpose_a", transpose_a);
            if (transpose_b != false)
                desc.SetAttr("transpose_b", transpose_b);
            if (input_quant_mode != null)
                 desc.SetAttr("input_quant_mode", input_quant_mode);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedMaxPool
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="min_input">Input to the operation. </param>
        /// <param name="max_input">Input to the operation. </param>
        /// <param name="ksize">ksize</param>
        /// <param name="strides">strides</param>
        /// <param name="padding">padding</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] min_output(type: DtFloat).
        /// [2] max_output(type: DtFloat).
        /// </returns>
        public Operation QuantizedMaxPool(Output input, Output min_input, Output max_input, long[] ksize, long[] strides, string padding, String opName = "QuantizedMaxPool") 
        {
            OperationDescription desc = NewOperation("QuantizedMaxPool", opName);
            desc.AddInput(input);
            desc.AddInput(min_input);
            desc.AddInput(max_input);
            desc.SetAttr("ksize", ksize);
            desc.SetAttr("strides", strides);
            desc.SetAttr("padding", padding);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedMul
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="min_x">Input to the operation. </param>
        /// <param name="max_x">Input to the operation. </param>
        /// <param name="min_y">Input to the operation. </param>
        /// <param name="max_y">Input to the operation. </param>
        /// <param name="Toutput">Toutput</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// [1] min_z(type: DtFloat).
        /// [2] max_z(type: DtFloat).
        /// </returns>
        public Operation QuantizedMul(Output x, Output y, Output min_x, Output max_x, Output min_y, Output max_y, DataType? Toutput = null, String opName = "QuantizedMul") 
        {
            OperationDescription desc = NewOperation("QuantizedMul", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            desc.AddInput(min_x);
            desc.AddInput(max_x);
            desc.AddInput(min_y);
            desc.AddInput(max_y);
            if (Toutput.HasValue)
                desc.SetAttr("Toutput", Toutput.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizeDownAndShrinkRange
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="input_min">Input to the operation. </param>
        /// <param name="input_max">Input to the operation. </param>
        /// <param name="out_type">out type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] output_min(type: DtFloat).
        /// [2] output_max(type: DtFloat).
        /// </returns>
        public Operation QuantizeDownAndShrinkRange(Output input, Output input_min, Output input_max, DataType out_type, String opName = "QuantizeDownAndShrinkRange") 
        {
            OperationDescription desc = NewOperation("QuantizeDownAndShrinkRange", opName);
            desc.AddInput(input);
            desc.AddInput(input_min);
            desc.AddInput(input_max);
            desc.SetAttr("out_type", out_type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedRelu
        /// </summary>
        /// <param name="features">Input to the operation. </param>
        /// <param name="min_features">Input to the operation. </param>
        /// <param name="max_features">Input to the operation. </param>
        /// <param name="out_type">out type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] activations(type: DtInvalid).
        /// [1] min_activations(type: DtFloat).
        /// [2] max_activations(type: DtFloat).
        /// </returns>
        public Operation QuantizedRelu(Output features, Output min_features, Output max_features, DataType? out_type = null, String opName = "QuantizedRelu") 
        {
            OperationDescription desc = NewOperation("QuantizedRelu", opName);
            desc.AddInput(features);
            desc.AddInput(min_features);
            desc.AddInput(max_features);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedRelu6
        /// </summary>
        /// <param name="features">Input to the operation. </param>
        /// <param name="min_features">Input to the operation. </param>
        /// <param name="max_features">Input to the operation. </param>
        /// <param name="out_type">out type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] activations(type: DtInvalid).
        /// [1] min_activations(type: DtFloat).
        /// [2] max_activations(type: DtFloat).
        /// </returns>
        public Operation QuantizedRelu6(Output features, Output min_features, Output max_features, DataType? out_type = null, String opName = "QuantizedRelu6") 
        {
            OperationDescription desc = NewOperation("QuantizedRelu6", opName);
            desc.AddInput(features);
            desc.AddInput(min_features);
            desc.AddInput(max_features);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedReluX
        /// </summary>
        /// <param name="features">Input to the operation. </param>
        /// <param name="max_value">Input to the operation. </param>
        /// <param name="min_features">Input to the operation. </param>
        /// <param name="max_features">Input to the operation. </param>
        /// <param name="out_type">out type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] activations(type: DtInvalid).
        /// [1] min_activations(type: DtFloat).
        /// [2] max_activations(type: DtFloat).
        /// </returns>
        public Operation QuantizedReluX(Output features, Output max_value, Output min_features, Output max_features, DataType? out_type = null, String opName = "QuantizedReluX") 
        {
            OperationDescription desc = NewOperation("QuantizedReluX", opName);
            desc.AddInput(features);
            desc.AddInput(max_value);
            desc.AddInput(min_features);
            desc.AddInput(max_features);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedReshape
        /// </summary>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="input_min">Input to the operation. </param>
        /// <param name="input_max">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] output_min(type: DtFloat).
        /// [2] output_max(type: DtFloat).
        /// </returns>
        public Operation QuantizedReshape(Output tensor, Output shape, Output input_min, Output input_max, String opName = "QuantizedReshape") 
        {
            OperationDescription desc = NewOperation("QuantizedReshape", opName);
            desc.AddInput(tensor);
            desc.AddInput(shape);
            desc.AddInput(input_min);
            desc.AddInput(input_max);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizedResizeBilinear
        /// </summary>
        /// <param name="images">Input to the operation. </param>
        /// <param name="size">Input to the operation. </param>
        /// <param name="min">Input to the operation. </param>
        /// <param name="max">Input to the operation. </param>
        /// <param name="align_corners">align corners</param>
        /// <param name="half_pixel_centers">half pixel centers</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] resized_images(type: DtInvalid).
        /// [1] out_min(type: DtFloat).
        /// [2] out_max(type: DtFloat).
        /// </returns>
        public Operation QuantizedResizeBilinear(Output images, Output size, Output min, Output max, bool align_corners = false, bool half_pixel_centers = false, String opName = "QuantizedResizeBilinear") 
        {
            OperationDescription desc = NewOperation("QuantizedResizeBilinear", opName);
            desc.AddInput(images);
            desc.AddInput(size);
            desc.AddInput(min);
            desc.AddInput(max);
            if (align_corners != false)
                desc.SetAttr("align_corners", align_corners);
            if (half_pixel_centers != false)
                desc.SetAttr("half_pixel_centers", half_pixel_centers);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QuantizeV2
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="min_range">Input to the operation. </param>
        /// <param name="max_range">Input to the operation. </param>
        /// <param name="T">T</param>
        /// <param name="mode">mode</param>
        /// <param name="round_mode">round mode</param>
        /// <param name="narrow_range">narrow range</param>
        /// <param name="axis">axis</param>
        /// <param name="ensure_minimum_range">ensure minimum range</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] output_min(type: DtFloat).
        /// [2] output_max(type: DtFloat).
        /// </returns>
        public Operation QuantizeV2(Output input, Output min_range, Output max_range, DataType T, string mode = null, string round_mode = null, bool narrow_range = false, long axis = -1, float ensure_minimum_range = 0.01f, String opName = "QuantizeV2") 
        {
            OperationDescription desc = NewOperation("QuantizeV2", opName);
            desc.AddInput(input);
            desc.AddInput(min_range);
            desc.AddInput(max_range);
            desc.SetAttr("T", T);
            if (mode != null)
                 desc.SetAttr("mode", mode);
            if (round_mode != null)
                 desc.SetAttr("round_mode", round_mode);
            if (narrow_range != false)
                desc.SetAttr("narrow_range", narrow_range);
            if (axis != -1)
                desc.SetAttr("axis", axis);
            if (ensure_minimum_range != 0.01f)
                desc.SetAttr("ensure_minimum_range", ensure_minimum_range);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QueueClose
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="cancel_pending_enqueues">cancel pending enqueues</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation QueueClose(Output handle, bool cancel_pending_enqueues = false, String opName = "QueueClose") 
        {
            OperationDescription desc = NewOperation("QueueClose", opName);
            desc.AddInput(handle);
            if (cancel_pending_enqueues != false)
                desc.SetAttr("cancel_pending_enqueues", cancel_pending_enqueues);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QueueCloseV2
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="cancel_pending_enqueues">cancel pending enqueues</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation QueueCloseV2(Output handle, bool cancel_pending_enqueues = false, String opName = "QueueCloseV2") 
        {
            OperationDescription desc = NewOperation("QueueCloseV2", opName);
            desc.AddInput(handle);
            if (cancel_pending_enqueues != false)
                desc.SetAttr("cancel_pending_enqueues", cancel_pending_enqueues);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QueueDequeue
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="component_types">component types</param>
        /// <param name="timeout_ms">timeout ms</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] components(type: DtInvalid).
        /// </returns>
        public Operation QueueDequeue(Output handle, DataType[] component_types, long timeout_ms = -1, String opName = "QueueDequeue") 
        {
            OperationDescription desc = NewOperation("QueueDequeue", opName);
            desc.AddInput(handle);
            desc.SetAttr("component_types", component_types);
            if (timeout_ms != -1)
                desc.SetAttr("timeout_ms", timeout_ms);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QueueDequeueMany
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="n">Input to the operation. </param>
        /// <param name="component_types">component types</param>
        /// <param name="timeout_ms">timeout ms</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] components(type: DtInvalid).
        /// </returns>
        public Operation QueueDequeueMany(Output handle, Output n, DataType[] component_types, long timeout_ms = -1, String opName = "QueueDequeueMany") 
        {
            OperationDescription desc = NewOperation("QueueDequeueMany", opName);
            desc.AddInput(handle);
            desc.AddInput(n);
            desc.SetAttr("component_types", component_types);
            if (timeout_ms != -1)
                desc.SetAttr("timeout_ms", timeout_ms);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QueueDequeueManyV2
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="n">Input to the operation. </param>
        /// <param name="component_types">component types</param>
        /// <param name="timeout_ms">timeout ms</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] components(type: DtInvalid).
        /// </returns>
        public Operation QueueDequeueManyV2(Output handle, Output n, DataType[] component_types, long timeout_ms = -1, String opName = "QueueDequeueManyV2") 
        {
            OperationDescription desc = NewOperation("QueueDequeueManyV2", opName);
            desc.AddInput(handle);
            desc.AddInput(n);
            desc.SetAttr("component_types", component_types);
            if (timeout_ms != -1)
                desc.SetAttr("timeout_ms", timeout_ms);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QueueDequeueUpTo
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="n">Input to the operation. </param>
        /// <param name="component_types">component types</param>
        /// <param name="timeout_ms">timeout ms</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] components(type: DtInvalid).
        /// </returns>
        public Operation QueueDequeueUpTo(Output handle, Output n, DataType[] component_types, long timeout_ms = -1, String opName = "QueueDequeueUpTo") 
        {
            OperationDescription desc = NewOperation("QueueDequeueUpTo", opName);
            desc.AddInput(handle);
            desc.AddInput(n);
            desc.SetAttr("component_types", component_types);
            if (timeout_ms != -1)
                desc.SetAttr("timeout_ms", timeout_ms);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QueueDequeueUpToV2
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="n">Input to the operation. </param>
        /// <param name="component_types">component types</param>
        /// <param name="timeout_ms">timeout ms</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] components(type: DtInvalid).
        /// </returns>
        public Operation QueueDequeueUpToV2(Output handle, Output n, DataType[] component_types, long timeout_ms = -1, String opName = "QueueDequeueUpToV2") 
        {
            OperationDescription desc = NewOperation("QueueDequeueUpToV2", opName);
            desc.AddInput(handle);
            desc.AddInput(n);
            desc.SetAttr("component_types", component_types);
            if (timeout_ms != -1)
                desc.SetAttr("timeout_ms", timeout_ms);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QueueDequeueV2
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="component_types">component types</param>
        /// <param name="timeout_ms">timeout ms</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] components(type: DtInvalid).
        /// </returns>
        public Operation QueueDequeueV2(Output handle, DataType[] component_types, long timeout_ms = -1, String opName = "QueueDequeueV2") 
        {
            OperationDescription desc = NewOperation("QueueDequeueV2", opName);
            desc.AddInput(handle);
            desc.SetAttr("component_types", component_types);
            if (timeout_ms != -1)
                desc.SetAttr("timeout_ms", timeout_ms);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QueueEnqueue
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="components">Input to the operation. </param>
        /// <param name="timeout_ms">timeout ms</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation QueueEnqueue(Output handle, Output components, long timeout_ms = -1, String opName = "QueueEnqueue") 
        {
            OperationDescription desc = NewOperation("QueueEnqueue", opName);
            desc.AddInput(handle);
            desc.AddInput(components);
            if (timeout_ms != -1)
                desc.SetAttr("timeout_ms", timeout_ms);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QueueEnqueueMany
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="components">Input to the operation. </param>
        /// <param name="timeout_ms">timeout ms</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation QueueEnqueueMany(Output handle, Output components, long timeout_ms = -1, String opName = "QueueEnqueueMany") 
        {
            OperationDescription desc = NewOperation("QueueEnqueueMany", opName);
            desc.AddInput(handle);
            desc.AddInput(components);
            if (timeout_ms != -1)
                desc.SetAttr("timeout_ms", timeout_ms);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QueueEnqueueManyV2
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="components">Input to the operation. </param>
        /// <param name="timeout_ms">timeout ms</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation QueueEnqueueManyV2(Output handle, Output components, long timeout_ms = -1, String opName = "QueueEnqueueManyV2") 
        {
            OperationDescription desc = NewOperation("QueueEnqueueManyV2", opName);
            desc.AddInput(handle);
            desc.AddInput(components);
            if (timeout_ms != -1)
                desc.SetAttr("timeout_ms", timeout_ms);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QueueEnqueueV2
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="components">Input to the operation. </param>
        /// <param name="timeout_ms">timeout ms</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation QueueEnqueueV2(Output handle, Output components, long timeout_ms = -1, String opName = "QueueEnqueueV2") 
        {
            OperationDescription desc = NewOperation("QueueEnqueueV2", opName);
            desc.AddInput(handle);
            desc.AddInput(components);
            if (timeout_ms != -1)
                desc.SetAttr("timeout_ms", timeout_ms);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QueueIsClosed
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] is_closed(type: DtBool).
        /// </returns>
        public Operation QueueIsClosed(Output handle, String opName = "QueueIsClosed") 
        {
            OperationDescription desc = NewOperation("QueueIsClosed", opName);
            desc.AddInput(handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QueueIsClosedV2
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] is_closed(type: DtBool).
        /// </returns>
        public Operation QueueIsClosedV2(Output handle, String opName = "QueueIsClosedV2") 
        {
            OperationDescription desc = NewOperation("QueueIsClosedV2", opName);
            desc.AddInput(handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QueueSize
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] size(type: DtInt32).
        /// </returns>
        public Operation QueueSize(Output handle, String opName = "QueueSize") 
        {
            OperationDescription desc = NewOperation("QueueSize", opName);
            desc.AddInput(handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// QueueSizeV2
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] size(type: DtInt32).
        /// </returns>
        public Operation QueueSizeV2(Output handle, String opName = "QueueSizeV2") 
        {
            OperationDescription desc = NewOperation("QueueSizeV2", opName);
            desc.AddInput(handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RaggedBincount
        /// </summary>
        /// <param name="splits">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="size">Input to the operation. </param>
        /// <param name="weights">Input to the operation. </param>
        /// <param name="binary_output">binary output</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RaggedBincount(Output splits, Output values, Output size, Output weights, bool binary_output = false, String opName = "RaggedBincount") 
        {
            OperationDescription desc = NewOperation("RaggedBincount", opName);
            desc.AddInput(splits);
            desc.AddInput(values);
            desc.AddInput(size);
            desc.AddInput(weights);
            if (binary_output != false)
                desc.SetAttr("binary_output", binary_output);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RaggedCountSparseOutput
        /// </summary>
        /// <param name="splits">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="weights">Input to the operation. </param>
        /// <param name="binary_output">binary output</param>
        /// <param name="minlength">minlength</param>
        /// <param name="maxlength">maxlength</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_indices(type: DtInt64).
        /// [1] output_values(type: DtInvalid).
        /// [2] output_dense_shape(type: DtInt64).
        /// </returns>
        public Operation RaggedCountSparseOutput(Output splits, Output values, Output weights, bool binary_output, long minlength = -1, long maxlength = -1, String opName = "RaggedCountSparseOutput") 
        {
            OperationDescription desc = NewOperation("RaggedCountSparseOutput", opName);
            desc.AddInput(splits);
            desc.AddInput(values);
            desc.AddInput(weights);
            desc.SetAttr("binary_output", binary_output);
            if (minlength != -1)
                desc.SetAttr("minlength", minlength);
            if (maxlength != -1)
                desc.SetAttr("maxlength", maxlength);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RaggedCross
        /// </summary>
        /// <param name="ragged_values">Input to the operation. </param>
        /// <param name="ragged_row_splits">Input to the operation. </param>
        /// <param name="sparse_indices">Input to the operation. </param>
        /// <param name="sparse_values">Input to the operation. </param>
        /// <param name="sparse_shape">Input to the operation. </param>
        /// <param name="dense_inputs">Input to the operation. </param>
        /// <param name="input_order">input order</param>
        /// <param name="hashed_output">hashed output</param>
        /// <param name="num_buckets">num buckets</param>
        /// <param name="hash_key">hash key</param>
        /// <param name="out_values_type">out values type</param>
        /// <param name="out_row_splits_type">out row splits type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_values(type: DtInvalid).
        /// [1] output_row_splits(type: DtInvalid).
        /// </returns>
        public Operation RaggedCross(Output ragged_values, Output ragged_row_splits, Output sparse_indices, Output sparse_values, Output sparse_shape, Output dense_inputs, string input_order, bool hashed_output, long num_buckets, long hash_key, DataType out_values_type, DataType out_row_splits_type, String opName = "RaggedCross") 
        {
            OperationDescription desc = NewOperation("RaggedCross", opName);
            desc.AddInput(ragged_values);
            desc.AddInput(ragged_row_splits);
            desc.AddInput(sparse_indices);
            desc.AddInput(sparse_values);
            desc.AddInput(sparse_shape);
            desc.AddInput(dense_inputs);
            desc.SetAttr("input_order", input_order);
            desc.SetAttr("hashed_output", hashed_output);
            desc.SetAttr("num_buckets", num_buckets);
            desc.SetAttr("hash_key", hash_key);
            desc.SetAttr("out_values_type", out_values_type);
            desc.SetAttr("out_row_splits_type", out_row_splits_type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RaggedFillEmptyRows
        /// </summary>
        /// <param name="value_rowids">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="nrows">Input to the operation. </param>
        /// <param name="default_value">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_value_rowids(type: DtInt64).
        /// [1] output_values(type: DtInvalid).
        /// [2] empty_row_indicator(type: DtBool).
        /// [3] reverse_index_map(type: DtInt64).
        /// </returns>
        public Operation RaggedFillEmptyRows(Output value_rowids, Output values, Output nrows, Output default_value, String opName = "RaggedFillEmptyRows") 
        {
            OperationDescription desc = NewOperation("RaggedFillEmptyRows", opName);
            desc.AddInput(value_rowids);
            desc.AddInput(values);
            desc.AddInput(nrows);
            desc.AddInput(default_value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RaggedFillEmptyRowsGrad
        /// </summary>
        /// <param name="reverse_index_map">Input to the operation. </param>
        /// <param name="grad_values">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] d_values(type: DtInvalid).
        /// [1] d_default_value(type: DtInvalid).
        /// </returns>
        public Operation RaggedFillEmptyRowsGrad(Output reverse_index_map, Output grad_values, String opName = "RaggedFillEmptyRowsGrad") 
        {
            OperationDescription desc = NewOperation("RaggedFillEmptyRowsGrad", opName);
            desc.AddInput(reverse_index_map);
            desc.AddInput(grad_values);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RaggedGather
        /// </summary>
        /// <param name="params_nested_splits">Input to the operation. </param>
        /// <param name="params_dense_values">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="OUTPUT_RAGGED_RANK">OUTPUT RAGGED RANK</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_nested_splits(type: DtInvalid).
        /// [1] output_dense_values(type: DtInvalid).
        /// </returns>
        public Operation RaggedGather(Output params_nested_splits, Output params_dense_values, Output indices, long OUTPUT_RAGGED_RANK, String opName = "RaggedGather") 
        {
            OperationDescription desc = NewOperation("RaggedGather", opName);
            desc.AddInput(params_nested_splits);
            desc.AddInput(params_dense_values);
            desc.AddInput(indices);
            desc.SetAttr("OUTPUT_RAGGED_RANK", OUTPUT_RAGGED_RANK);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RaggedRange
        /// </summary>
        /// <param name="starts">Input to the operation. </param>
        /// <param name="limits">Input to the operation. </param>
        /// <param name="deltas">Input to the operation. </param>
        /// <param name="Tsplits">Tsplits</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] rt_nested_splits(type: DtInvalid).
        /// [1] rt_dense_values(type: DtInvalid).
        /// </returns>
        public Operation RaggedRange(Output starts, Output limits, Output deltas, DataType? Tsplits = null, String opName = "RaggedRange") 
        {
            OperationDescription desc = NewOperation("RaggedRange", opName);
            desc.AddInput(starts);
            desc.AddInput(limits);
            desc.AddInput(deltas);
            if (Tsplits.HasValue)
                desc.SetAttr("Tsplits", Tsplits.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RaggedTensorFromVariant
        /// </summary>
        /// <param name="encoded_ragged">Input to the operation. </param>
        /// <param name="input_ragged_rank">input ragged rank</param>
        /// <param name="output_ragged_rank">output ragged rank</param>
        /// <param name="Tvalues">Tvalues</param>
        /// <param name="Tsplits">Tsplits</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_nested_splits(type: DtInvalid).
        /// [1] output_dense_values(type: DtInvalid).
        /// </returns>
        public Operation RaggedTensorFromVariant(Output encoded_ragged, long input_ragged_rank, long output_ragged_rank, DataType Tvalues, DataType? Tsplits = null, String opName = "RaggedTensorFromVariant") 
        {
            OperationDescription desc = NewOperation("RaggedTensorFromVariant", opName);
            desc.AddInput(encoded_ragged);
            desc.SetAttr("input_ragged_rank", input_ragged_rank);
            desc.SetAttr("output_ragged_rank", output_ragged_rank);
            desc.SetAttr("Tvalues", Tvalues);
            if (Tsplits.HasValue)
                desc.SetAttr("Tsplits", Tsplits.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RaggedTensorToSparse
        /// </summary>
        /// <param name="rt_nested_splits">Input to the operation. </param>
        /// <param name="rt_dense_values">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] sparse_indices(type: DtInt64).
        /// [1] sparse_values(type: DtInvalid).
        /// [2] sparse_dense_shape(type: DtInt64).
        /// </returns>
        public Operation RaggedTensorToSparse(Output rt_nested_splits, Output rt_dense_values, String opName = "RaggedTensorToSparse") 
        {
            OperationDescription desc = NewOperation("RaggedTensorToSparse", opName);
            desc.AddInput(rt_nested_splits);
            desc.AddInput(rt_dense_values);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RaggedTensorToTensor
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="default_value">Input to the operation. </param>
        /// <param name="row_partition_tensors">Input to the operation. </param>
        /// <param name="row_partition_types">row partition types</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] result(type: DtInvalid).
        /// </returns>
        public Operation RaggedTensorToTensor(Output shape, Output values, Output default_value, Output row_partition_tensors, string[] row_partition_types, String opName = "RaggedTensorToTensor") 
        {
            OperationDescription desc = NewOperation("RaggedTensorToTensor", opName);
            desc.AddInput(shape);
            desc.AddInput(values);
            desc.AddInput(default_value);
            desc.AddInput(row_partition_tensors);
            desc.SetAttr("row_partition_types", row_partition_types);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RaggedTensorToVariant
        /// </summary>
        /// <param name="rt_nested_splits">Input to the operation. </param>
        /// <param name="rt_dense_values">Input to the operation. </param>
        /// <param name="batched_input">batched input</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] encoded_ragged(type: DtVariant).
        /// </returns>
        public Operation RaggedTensorToVariant(Output rt_nested_splits, Output rt_dense_values, bool batched_input, String opName = "RaggedTensorToVariant") 
        {
            OperationDescription desc = NewOperation("RaggedTensorToVariant", opName);
            desc.AddInput(rt_nested_splits);
            desc.AddInput(rt_dense_values);
            desc.SetAttr("batched_input", batched_input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RaggedTensorToVariantGradient
        /// </summary>
        /// <param name="encoded_ragged_grad">Input to the operation. </param>
        /// <param name="row_splits">Input to the operation. </param>
        /// <param name="dense_values_shape">Input to the operation. </param>
        /// <param name="Tvalues">Tvalues</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] dense_values_grad(type: DtInvalid).
        /// </returns>
        public Operation RaggedTensorToVariantGradient(Output encoded_ragged_grad, Output row_splits, Output dense_values_shape, DataType Tvalues, String opName = "RaggedTensorToVariantGradient") 
        {
            OperationDescription desc = NewOperation("RaggedTensorToVariantGradient", opName);
            desc.AddInput(encoded_ragged_grad);
            desc.AddInput(row_splits);
            desc.AddInput(dense_values_shape);
            desc.SetAttr("Tvalues", Tvalues);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RandomCrop
        /// </summary>
        /// <param name="image">Input to the operation. </param>
        /// <param name="size">Input to the operation. </param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RandomCrop(Output image, Output size, long seed = 0, long seed2 = 0, String opName = "RandomCrop") 
        {
            OperationDescription desc = NewOperation("RandomCrop", opName);
            desc.AddInput(image);
            desc.AddInput(size);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RandomDataset
        /// </summary>
        /// <param name="seed">Input to the operation. </param>
        /// <param name="seed2">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation RandomDataset(Output seed, Output seed2, DataType[] output_types, long[][] output_shapes, string metadata = null, String opName = "RandomDataset") 
        {
            OperationDescription desc = NewOperation("RandomDataset", opName);
            desc.AddInput(seed);
            desc.AddInput(seed2);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RandomDatasetV2
        /// </summary>
        /// <param name="seed">Input to the operation. </param>
        /// <param name="seed2">Input to the operation. </param>
        /// <param name="seed_generator">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="rerandomize_each_iteration">rerandomize each iteration</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation RandomDatasetV2(Output seed, Output seed2, Output seed_generator, DataType[] output_types, long[][] output_shapes, bool rerandomize_each_iteration = false, string metadata = null, String opName = "RandomDatasetV2") 
        {
            OperationDescription desc = NewOperation("RandomDatasetV2", opName);
            desc.AddInput(seed);
            desc.AddInput(seed2);
            desc.AddInput(seed_generator);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (rerandomize_each_iteration != false)
                desc.SetAttr("rerandomize_each_iteration", rerandomize_each_iteration);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RandomGamma
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="alpha">Input to the operation. </param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RandomGamma(Output shape, Output alpha, long seed = 0, long seed2 = 0, String opName = "RandomGamma") 
        {
            OperationDescription desc = NewOperation("RandomGamma", opName);
            desc.AddInput(shape);
            desc.AddInput(alpha);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RandomGammaGrad
        /// </summary>
        /// <param name="alpha">Input to the operation. </param>
        /// <param name="sample">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RandomGammaGrad(Output alpha, Output sample, String opName = "RandomGammaGrad") 
        {
            OperationDescription desc = NewOperation("RandomGammaGrad", opName);
            desc.AddInput(alpha);
            desc.AddInput(sample);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RandomIndexShuffle
        /// </summary>
        /// <param name="index">Input to the operation. </param>
        /// <param name="seed">Input to the operation. </param>
        /// <param name="max_index">Input to the operation. </param>
        /// <param name="rounds">rounds</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RandomIndexShuffle(Output index, Output seed, Output max_index, long rounds = 4, String opName = "RandomIndexShuffle") 
        {
            OperationDescription desc = NewOperation("RandomIndexShuffle", opName);
            desc.AddInput(index);
            desc.AddInput(seed);
            desc.AddInput(max_index);
            if (rounds != 4)
                desc.SetAttr("rounds", rounds);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RandomPoisson
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="rate">Input to the operation. </param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RandomPoisson(Output shape, Output rate, long seed = 0, long seed2 = 0, String opName = "RandomPoisson") 
        {
            OperationDescription desc = NewOperation("RandomPoisson", opName);
            desc.AddInput(shape);
            desc.AddInput(rate);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RandomPoissonV2
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="rate">Input to the operation. </param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RandomPoissonV2(Output shape, Output rate, long seed = 0, long seed2 = 0, DataType? dtype = null, String opName = "RandomPoissonV2") 
        {
            OperationDescription desc = NewOperation("RandomPoissonV2", opName);
            desc.AddInput(shape);
            desc.AddInput(rate);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            if (dtype.HasValue)
                desc.SetAttr("dtype", dtype.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RandomShuffle
        /// </summary>
        /// <param name="value">Input to the operation. </param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RandomShuffle(Output value, long seed = 0, long seed2 = 0, String opName = "RandomShuffle") 
        {
            OperationDescription desc = NewOperation("RandomShuffle", opName);
            desc.AddInput(value);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RandomShuffleQueue
        /// </summary>
        /// <param name="component_types">component types</param>
        /// <param name="shapes">shapes</param>
        /// <param name="capacity">capacity</param>
        /// <param name="min_after_dequeue">min after dequeue</param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtString).
        /// </returns>
        public Operation RandomShuffleQueue(DataType[] component_types, long[][] shapes = null, long capacity = -1, long min_after_dequeue = 0, long seed = 0, long seed2 = 0, string container = null, string shared_name = null, String opName = "RandomShuffleQueue") 
        {
            OperationDescription desc = NewOperation("RandomShuffleQueue", opName);
            desc.SetAttr("component_types", component_types);
            if (shapes != null) desc.SetAttrShapeList("shapes", shapes);
            if (capacity != -1)
                desc.SetAttr("capacity", capacity);
            if (min_after_dequeue != 0)
                desc.SetAttr("min_after_dequeue", min_after_dequeue);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RandomShuffleQueueV2
        /// </summary>
        /// <param name="component_types">component types</param>
        /// <param name="shapes">shapes</param>
        /// <param name="capacity">capacity</param>
        /// <param name="min_after_dequeue">min after dequeue</param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// </returns>
        public Operation RandomShuffleQueueV2(DataType[] component_types, long[][] shapes = null, long capacity = -1, long min_after_dequeue = 0, long seed = 0, long seed2 = 0, string container = null, string shared_name = null, String opName = "RandomShuffleQueueV2") 
        {
            OperationDescription desc = NewOperation("RandomShuffleQueueV2", opName);
            desc.SetAttr("component_types", component_types);
            if (shapes != null) desc.SetAttrShapeList("shapes", shapes);
            if (capacity != -1)
                desc.SetAttr("capacity", capacity);
            if (min_after_dequeue != 0)
                desc.SetAttr("min_after_dequeue", min_after_dequeue);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RandomStandardNormal
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RandomStandardNormal(Output shape, DataType dtype, long seed = 0, long seed2 = 0, String opName = "RandomStandardNormal") 
        {
            OperationDescription desc = NewOperation("RandomStandardNormal", opName);
            desc.AddInput(shape);
            desc.SetAttr("dtype", dtype);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RandomUniform
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RandomUniform(Output shape, DataType dtype, long seed = 0, long seed2 = 0, String opName = "RandomUniform") 
        {
            OperationDescription desc = NewOperation("RandomUniform", opName);
            desc.AddInput(shape);
            desc.SetAttr("dtype", dtype);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RandomUniformInt
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="minval">Input to the operation. </param>
        /// <param name="maxval">Input to the operation. </param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RandomUniformInt(Output shape, Output minval, Output maxval, long seed = 0, long seed2 = 0, String opName = "RandomUniformInt") 
        {
            OperationDescription desc = NewOperation("RandomUniformInt", opName);
            desc.AddInput(shape);
            desc.AddInput(minval);
            desc.AddInput(maxval);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Range
        /// </summary>
        /// <param name="start">Input to the operation. </param>
        /// <param name="limit">Input to the operation. </param>
        /// <param name="delta">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Range(Output start, Output limit, Output delta, String opName = "Range") 
        {
            OperationDescription desc = NewOperation("Range", opName);
            desc.AddInput(start);
            desc.AddInput(limit);
            desc.AddInput(delta);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RangeDataset
        /// </summary>
        /// <param name="start">Input to the operation. </param>
        /// <param name="stop">Input to the operation. </param>
        /// <param name="step">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="replicate_on_split">replicate on split</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation RangeDataset(Output start, Output stop, Output step, DataType[] output_types, long[][] output_shapes, string metadata = null, bool replicate_on_split = false, String opName = "RangeDataset") 
        {
            OperationDescription desc = NewOperation("RangeDataset", opName);
            desc.AddInput(start);
            desc.AddInput(stop);
            desc.AddInput(step);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            if (replicate_on_split != false)
                desc.SetAttr("replicate_on_split", replicate_on_split);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Rank
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInt32).
        /// </returns>
        public Operation Rank(Output input, String opName = "Rank") 
        {
            OperationDescription desc = NewOperation("Rank", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ReaderNumRecordsProduced
        /// </summary>
        /// <param name="reader_handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] records_produced(type: DtInt64).
        /// </returns>
        public Operation ReaderNumRecordsProduced(Output reader_handle, String opName = "ReaderNumRecordsProduced") 
        {
            OperationDescription desc = NewOperation("ReaderNumRecordsProduced", opName);
            desc.AddInput(reader_handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ReaderNumRecordsProducedV2
        /// </summary>
        /// <param name="reader_handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] records_produced(type: DtInt64).
        /// </returns>
        public Operation ReaderNumRecordsProducedV2(Output reader_handle, String opName = "ReaderNumRecordsProducedV2") 
        {
            OperationDescription desc = NewOperation("ReaderNumRecordsProducedV2", opName);
            desc.AddInput(reader_handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ReaderNumWorkUnitsCompleted
        /// </summary>
        /// <param name="reader_handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] units_completed(type: DtInt64).
        /// </returns>
        public Operation ReaderNumWorkUnitsCompleted(Output reader_handle, String opName = "ReaderNumWorkUnitsCompleted") 
        {
            OperationDescription desc = NewOperation("ReaderNumWorkUnitsCompleted", opName);
            desc.AddInput(reader_handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ReaderNumWorkUnitsCompletedV2
        /// </summary>
        /// <param name="reader_handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] units_completed(type: DtInt64).
        /// </returns>
        public Operation ReaderNumWorkUnitsCompletedV2(Output reader_handle, String opName = "ReaderNumWorkUnitsCompletedV2") 
        {
            OperationDescription desc = NewOperation("ReaderNumWorkUnitsCompletedV2", opName);
            desc.AddInput(reader_handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ReaderRead
        /// </summary>
        /// <param name="reader_handle">Input to the operation. </param>
        /// <param name="queue_handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] key(type: DtString).
        /// [1] value(type: DtString).
        /// </returns>
        public Operation ReaderRead(Output reader_handle, Output queue_handle, String opName = "ReaderRead") 
        {
            OperationDescription desc = NewOperation("ReaderRead", opName);
            desc.AddInput(reader_handle);
            desc.AddInput(queue_handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ReaderReadUpTo
        /// </summary>
        /// <param name="reader_handle">Input to the operation. </param>
        /// <param name="queue_handle">Input to the operation. </param>
        /// <param name="num_records">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] keys(type: DtString).
        /// [1] values(type: DtString).
        /// </returns>
        public Operation ReaderReadUpTo(Output reader_handle, Output queue_handle, Output num_records, String opName = "ReaderReadUpTo") 
        {
            OperationDescription desc = NewOperation("ReaderReadUpTo", opName);
            desc.AddInput(reader_handle);
            desc.AddInput(queue_handle);
            desc.AddInput(num_records);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ReaderReadUpToV2
        /// </summary>
        /// <param name="reader_handle">Input to the operation. </param>
        /// <param name="queue_handle">Input to the operation. </param>
        /// <param name="num_records">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] keys(type: DtString).
        /// [1] values(type: DtString).
        /// </returns>
        public Operation ReaderReadUpToV2(Output reader_handle, Output queue_handle, Output num_records, String opName = "ReaderReadUpToV2") 
        {
            OperationDescription desc = NewOperation("ReaderReadUpToV2", opName);
            desc.AddInput(reader_handle);
            desc.AddInput(queue_handle);
            desc.AddInput(num_records);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ReaderReadV2
        /// </summary>
        /// <param name="reader_handle">Input to the operation. </param>
        /// <param name="queue_handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] key(type: DtString).
        /// [1] value(type: DtString).
        /// </returns>
        public Operation ReaderReadV2(Output reader_handle, Output queue_handle, String opName = "ReaderReadV2") 
        {
            OperationDescription desc = NewOperation("ReaderReadV2", opName);
            desc.AddInput(reader_handle);
            desc.AddInput(queue_handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ReaderReset
        /// </summary>
        /// <param name="reader_handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ReaderReset(Output reader_handle, String opName = "ReaderReset") 
        {
            OperationDescription desc = NewOperation("ReaderReset", opName);
            desc.AddInput(reader_handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ReaderResetV2
        /// </summary>
        /// <param name="reader_handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ReaderResetV2(Output reader_handle, String opName = "ReaderResetV2") 
        {
            OperationDescription desc = NewOperation("ReaderResetV2", opName);
            desc.AddInput(reader_handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ReaderRestoreState
        /// </summary>
        /// <param name="reader_handle">Input to the operation. </param>
        /// <param name="state">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ReaderRestoreState(Output reader_handle, Output state, String opName = "ReaderRestoreState") 
        {
            OperationDescription desc = NewOperation("ReaderRestoreState", opName);
            desc.AddInput(reader_handle);
            desc.AddInput(state);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ReaderRestoreStateV2
        /// </summary>
        /// <param name="reader_handle">Input to the operation. </param>
        /// <param name="state">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ReaderRestoreStateV2(Output reader_handle, Output state, String opName = "ReaderRestoreStateV2") 
        {
            OperationDescription desc = NewOperation("ReaderRestoreStateV2", opName);
            desc.AddInput(reader_handle);
            desc.AddInput(state);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ReaderSerializeState
        /// </summary>
        /// <param name="reader_handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] state(type: DtString).
        /// </returns>
        public Operation ReaderSerializeState(Output reader_handle, String opName = "ReaderSerializeState") 
        {
            OperationDescription desc = NewOperation("ReaderSerializeState", opName);
            desc.AddInput(reader_handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ReaderSerializeStateV2
        /// </summary>
        /// <param name="reader_handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] state(type: DtString).
        /// </returns>
        public Operation ReaderSerializeStateV2(Output reader_handle, String opName = "ReaderSerializeStateV2") 
        {
            OperationDescription desc = NewOperation("ReaderSerializeStateV2", opName);
            desc.AddInput(reader_handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ReadFile
        /// </summary>
        /// <param name="filename">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] contents(type: DtString).
        /// </returns>
        public Operation ReadFile(Output filename, String opName = "ReadFile") 
        {
            OperationDescription desc = NewOperation("ReadFile", opName);
            desc.AddInput(filename);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ReadVariableOp
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] value(type: DtInvalid).
        /// </returns>
        public Operation ReadVariableOp(Output resource, DataType dtype, String opName = "ReadVariableOp") 
        {
            OperationDescription desc = NewOperation("ReadVariableOp", opName);
            desc.AddInput(resource);
            desc.SetAttr("dtype", dtype);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ReadVariableXlaSplitND
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="T">T</param>
        /// <param name="N">N</param>
        /// <param name="num_splits">num splits</param>
        /// <param name="paddings">paddings</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] outputs(type: DtInvalid).
        /// </returns>
        public Operation ReadVariableXlaSplitND(Output resource, DataType T, long N, long[] num_splits, long[] paddings = null, String opName = "ReadVariableXlaSplitND") 
        {
            OperationDescription desc = NewOperation("ReadVariableXlaSplitND", opName);
            desc.AddInput(resource);
            desc.SetAttr("T", T);
            desc.SetAttr("N", N);
            desc.SetAttr("num_splits", num_splits);
            if (paddings != null) desc.SetAttr("paddings", paddings);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Real
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="Tout">Tout</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Real(Output input, DataType? Tout = null, String opName = "Real") 
        {
            OperationDescription desc = NewOperation("Real", opName);
            desc.AddInput(input);
            if (Tout.HasValue)
                desc.SetAttr("Tout", Tout.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RealDiv
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation RealDiv(Output x, Output y, String opName = "RealDiv") 
        {
            OperationDescription desc = NewOperation("RealDiv", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RebatchDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="num_replicas">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="use_fallback">use fallback</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation RebatchDataset(Output input_dataset, Output num_replicas, DataType[] output_types, long[][] output_shapes, bool use_fallback = true, String opName = "RebatchDataset") 
        {
            OperationDescription desc = NewOperation("RebatchDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(num_replicas);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (use_fallback != true)
                desc.SetAttr("use_fallback", use_fallback);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RebatchDatasetV2
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="batch_sizes">Input to the operation. </param>
        /// <param name="drop_remainder">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation RebatchDatasetV2(Output input_dataset, Output batch_sizes, Output drop_remainder, DataType[] output_types, long[][] output_shapes, String opName = "RebatchDatasetV2") 
        {
            OperationDescription desc = NewOperation("RebatchDatasetV2", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(batch_sizes);
            desc.AddInput(drop_remainder);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Reciprocal
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Reciprocal(Output x, String opName = "Reciprocal") 
        {
            OperationDescription desc = NewOperation("Reciprocal", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ReciprocalGrad
        /// </summary>
        /// <param name="y">Input to the operation. </param>
        /// <param name="dy">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation ReciprocalGrad(Output y, Output dy, String opName = "ReciprocalGrad") 
        {
            OperationDescription desc = NewOperation("ReciprocalGrad", opName);
            desc.AddInput(y);
            desc.AddInput(dy);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RecordInput
        /// </summary>
        /// <param name="file_pattern">file pattern</param>
        /// <param name="file_random_seed">file random seed</param>
        /// <param name="file_shuffle_shift_ratio">file shuffle shift ratio</param>
        /// <param name="file_buffer_size">file buffer size</param>
        /// <param name="file_parallelism">file parallelism</param>
        /// <param name="batch_size">batch size</param>
        /// <param name="compression_type">compression type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] records(type: DtString).
        /// </returns>
        public Operation RecordInput(string file_pattern, long file_random_seed = 301, float file_shuffle_shift_ratio = 0f, long file_buffer_size = 10000, long file_parallelism = 16, long batch_size = 32, string compression_type = null, String opName = "RecordInput") 
        {
            OperationDescription desc = NewOperation("RecordInput", opName);
            desc.SetAttr("file_pattern", file_pattern);
            if (file_random_seed != 301)
                desc.SetAttr("file_random_seed", file_random_seed);
            if (file_shuffle_shift_ratio != 0f)
                desc.SetAttr("file_shuffle_shift_ratio", file_shuffle_shift_ratio);
            if (file_buffer_size != 10000)
                desc.SetAttr("file_buffer_size", file_buffer_size);
            if (file_parallelism != 16)
                desc.SetAttr("file_parallelism", file_parallelism);
            if (batch_size != 32)
                desc.SetAttr("batch_size", batch_size);
            if (compression_type != null)
                 desc.SetAttr("compression_type", compression_type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Recv
        /// </summary>
        /// <param name="tensor_type">tensor type</param>
        /// <param name="tensor_name">tensor name</param>
        /// <param name="send_device">send device</param>
        /// <param name="send_device_incarnation">send device incarnation</param>
        /// <param name="recv_device">recv device</param>
        /// <param name="client_terminated">client terminated</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] tensor(type: DtInvalid).
        /// </returns>
        public Operation Recv(DataType tensor_type, string tensor_name, string send_device, long send_device_incarnation, string recv_device, bool client_terminated = false, String opName = "Recv") 
        {
            OperationDescription desc = NewOperation("Recv", opName);
            desc.SetAttr("tensor_type", tensor_type);
            desc.SetAttr("tensor_name", tensor_name);
            desc.SetAttr("send_device", send_device);
            desc.SetAttr("send_device_incarnation", send_device_incarnation);
            desc.SetAttr("recv_device", recv_device);
            if (client_terminated != false)
                desc.SetAttr("client_terminated", client_terminated);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RecvTPUEmbeddingActivations
        /// </summary>
        /// <param name="num_outputs">num outputs</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] outputs(type: DtFloat).
        /// </returns>
        public Operation RecvTPUEmbeddingActivations(long num_outputs, string config, String opName = "RecvTPUEmbeddingActivations") 
        {
            OperationDescription desc = NewOperation("RecvTPUEmbeddingActivations", opName);
            desc.SetAttr("num_outputs", num_outputs);
            desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ReduceDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="initial_state">Input to the operation. </param>
        /// <param name="other_arguments">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="use_inter_op_parallelism">use inter op parallelism</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] components(type: DtInvalid).
        /// </returns>
        // The following attributes are not known: f: func
        public Operation ReduceDataset(Output input_dataset, Output initial_state, Output other_arguments, DataType[] output_types, long[][] output_shapes, bool use_inter_op_parallelism = true, string metadata = null, String opName = "ReduceDataset") 
        {
            OperationDescription desc = NewOperation("ReduceDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(initial_state);
            desc.AddInput(other_arguments);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (use_inter_op_parallelism != true)
                desc.SetAttr("use_inter_op_parallelism", use_inter_op_parallelism);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ReduceJoin
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="reduction_indices">Input to the operation. </param>
        /// <param name="keep_dims">keep dims</param>
        /// <param name="separator">separator</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtString).
        /// </returns>
        public Operation ReduceJoin(Output inputs, Output reduction_indices, bool keep_dims = false, string separator = null, String opName = "ReduceJoin") 
        {
            OperationDescription desc = NewOperation("ReduceJoin", opName);
            desc.AddInput(inputs);
            desc.AddInput(reduction_indices);
            if (keep_dims != false)
                desc.SetAttr("keep_dims", keep_dims);
            if (separator != null)
                 desc.SetAttr("separator", separator);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RefEnter
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="frame_name">frame name</param>
        /// <param name="is_constant">is constant</param>
        /// <param name="parallel_iterations">parallel iterations</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RefEnter(Output data, string frame_name, bool is_constant = false, long parallel_iterations = 10, String opName = "RefEnter") 
        {
            OperationDescription desc = NewOperation("RefEnter", opName);
            desc.AddInput(data);
            desc.SetAttr("frame_name", frame_name);
            if (is_constant != false)
                desc.SetAttr("is_constant", is_constant);
            if (parallel_iterations != 10)
                desc.SetAttr("parallel_iterations", parallel_iterations);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RefExit
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RefExit(Output data, String opName = "RefExit") 
        {
            OperationDescription desc = NewOperation("RefExit", opName);
            desc.AddInput(data);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RefIdentity
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RefIdentity(Output input, String opName = "RefIdentity") 
        {
            OperationDescription desc = NewOperation("RefIdentity", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RefMerge
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] value_index(type: DtInt32).
        /// </returns>
        public Operation RefMerge(Output inputs, String opName = "RefMerge") 
        {
            OperationDescription desc = NewOperation("RefMerge", opName);
            desc.AddInput(inputs);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RefNextIteration
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RefNextIteration(Output data, String opName = "RefNextIteration") 
        {
            OperationDescription desc = NewOperation("RefNextIteration", opName);
            desc.AddInput(data);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RefSelect
        /// </summary>
        /// <param name="index">Input to the operation. </param>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RefSelect(Output index, Output inputs, String opName = "RefSelect") 
        {
            OperationDescription desc = NewOperation("RefSelect", opName);
            desc.AddInput(index);
            desc.AddInput(inputs);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RefSwitch
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="pred">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_false(type: DtInvalid).
        /// [1] output_true(type: DtInvalid).
        /// </returns>
        public Operation RefSwitch(Output data, Output pred, String opName = "RefSwitch") 
        {
            OperationDescription desc = NewOperation("RefSwitch", opName);
            desc.AddInput(data);
            desc.AddInput(pred);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RegexFullMatch
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="pattern">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtBool).
        /// </returns>
        public Operation RegexFullMatch(Output input, Output pattern, String opName = "RegexFullMatch") 
        {
            OperationDescription desc = NewOperation("RegexFullMatch", opName);
            desc.AddInput(input);
            desc.AddInput(pattern);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RegexReplace
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="pattern">Input to the operation. </param>
        /// <param name="rewrite">Input to the operation. </param>
        /// <param name="replace_global">replace global</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtString).
        /// </returns>
        public Operation RegexReplace(Output input, Output pattern, Output rewrite, bool replace_global = true, String opName = "RegexReplace") 
        {
            OperationDescription desc = NewOperation("RegexReplace", opName);
            desc.AddInput(input);
            desc.AddInput(pattern);
            desc.AddInput(rewrite);
            if (replace_global != true)
                desc.SetAttr("replace_global", replace_global);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RegisterDataset
        /// </summary>
        /// <param name="dataset">Input to the operation. </param>
        /// <param name="address">Input to the operation. </param>
        /// <param name="protocol">Input to the operation. </param>
        /// <param name="external_state_policy">external state policy</param>
        /// <param name="element_spec">element spec</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] dataset_id(type: DtInt64).
        /// </returns>
        public Operation RegisterDataset(Output dataset, Output address, Output protocol, long external_state_policy, string element_spec = null, string metadata = null, String opName = "RegisterDataset") 
        {
            OperationDescription desc = NewOperation("RegisterDataset", opName);
            desc.AddInput(dataset);
            desc.AddInput(address);
            desc.AddInput(protocol);
            desc.SetAttr("external_state_policy", external_state_policy);
            if (element_spec != null)
                 desc.SetAttr("element_spec", element_spec);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RegisterDatasetV2
        /// </summary>
        /// <param name="dataset">Input to the operation. </param>
        /// <param name="address">Input to the operation. </param>
        /// <param name="protocol">Input to the operation. </param>
        /// <param name="external_state_policy">external state policy</param>
        /// <param name="element_spec">element spec</param>
        /// <param name="requested_dataset_id">requested dataset id</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] dataset_id(type: DtString).
        /// </returns>
        public Operation RegisterDatasetV2(Output dataset, Output address, Output protocol, long external_state_policy, string element_spec = null, string requested_dataset_id = null, string metadata = null, String opName = "RegisterDatasetV2") 
        {
            OperationDescription desc = NewOperation("RegisterDatasetV2", opName);
            desc.AddInput(dataset);
            desc.AddInput(address);
            desc.AddInput(protocol);
            desc.SetAttr("external_state_policy", external_state_policy);
            if (element_spec != null)
                 desc.SetAttr("element_spec", element_spec);
            if (requested_dataset_id != null)
                 desc.SetAttr("requested_dataset_id", requested_dataset_id);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Relayout
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="layout">layout</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Relayout(Output input, string layout, String opName = "Relayout") 
        {
            OperationDescription desc = NewOperation("Relayout", opName);
            desc.AddInput(input);
            desc.SetAttr("layout", layout);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RelayoutLike
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="layout_input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RelayoutLike(Output input, Output layout_input, String opName = "RelayoutLike") 
        {
            OperationDescription desc = NewOperation("RelayoutLike", opName);
            desc.AddInput(input);
            desc.AddInput(layout_input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Relu
        /// </summary>
        /// <param name="features">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] activations(type: DtInvalid).
        /// </returns>
        public Operation Relu(Output features, String opName = "Relu") 
        {
            OperationDescription desc = NewOperation("Relu", opName);
            desc.AddInput(features);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Relu6
        /// </summary>
        /// <param name="features">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] activations(type: DtInvalid).
        /// </returns>
        public Operation Relu6(Output features, String opName = "Relu6") 
        {
            OperationDescription desc = NewOperation("Relu6", opName);
            desc.AddInput(features);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Relu6Grad
        /// </summary>
        /// <param name="gradients">Input to the operation. </param>
        /// <param name="features">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] backprops(type: DtInvalid).
        /// </returns>
        public Operation Relu6Grad(Output gradients, Output features, String opName = "Relu6Grad") 
        {
            OperationDescription desc = NewOperation("Relu6Grad", opName);
            desc.AddInput(gradients);
            desc.AddInput(features);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ReluGrad
        /// </summary>
        /// <param name="gradients">Input to the operation. </param>
        /// <param name="features">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] backprops(type: DtInvalid).
        /// </returns>
        public Operation ReluGrad(Output gradients, Output features, String opName = "ReluGrad") 
        {
            OperationDescription desc = NewOperation("ReluGrad", opName);
            desc.AddInput(gradients);
            desc.AddInput(features);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RemoteCall
        /// </summary>
        /// <param name="target">Input to the operation. </param>
        /// <param name="args">Input to the operation. </param>
        /// <param name="Tout">Tout</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        // The following attributes are not known: f: func
        public Operation RemoteCall(Output target, Output args, DataType[] Tout, String opName = "RemoteCall") 
        {
            OperationDescription desc = NewOperation("RemoteCall", opName);
            desc.AddInput(target);
            desc.AddInput(args);
            desc.SetAttr("Tout", Tout);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RepeatDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="count">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation RepeatDataset(Output input_dataset, Output count, DataType[] output_types, long[][] output_shapes, string metadata = null, String opName = "RepeatDataset") 
        {
            OperationDescription desc = NewOperation("RepeatDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(count);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RequantizationRange
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="input_min">Input to the operation. </param>
        /// <param name="input_max">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_min(type: DtFloat).
        /// [1] output_max(type: DtFloat).
        /// </returns>
        public Operation RequantizationRange(Output input, Output input_min, Output input_max, String opName = "RequantizationRange") 
        {
            OperationDescription desc = NewOperation("RequantizationRange", opName);
            desc.AddInput(input);
            desc.AddInput(input_min);
            desc.AddInput(input_max);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RequantizationRangePerChannel
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="input_min">Input to the operation. </param>
        /// <param name="input_max">Input to the operation. </param>
        /// <param name="clip_value_max">clip value max</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_min(type: DtFloat).
        /// [1] output_max(type: DtFloat).
        /// </returns>
        public Operation RequantizationRangePerChannel(Output input, Output input_min, Output input_max, float clip_value_max, String opName = "RequantizationRangePerChannel") 
        {
            OperationDescription desc = NewOperation("RequantizationRangePerChannel", opName);
            desc.AddInput(input);
            desc.AddInput(input_min);
            desc.AddInput(input_max);
            desc.SetAttr("clip_value_max", clip_value_max);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Requantize
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="input_min">Input to the operation. </param>
        /// <param name="input_max">Input to the operation. </param>
        /// <param name="requested_output_min">Input to the operation. </param>
        /// <param name="requested_output_max">Input to the operation. </param>
        /// <param name="out_type">out type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] output_min(type: DtFloat).
        /// [2] output_max(type: DtFloat).
        /// </returns>
        public Operation Requantize(Output input, Output input_min, Output input_max, Output requested_output_min, Output requested_output_max, DataType out_type, String opName = "Requantize") 
        {
            OperationDescription desc = NewOperation("Requantize", opName);
            desc.AddInput(input);
            desc.AddInput(input_min);
            desc.AddInput(input_max);
            desc.AddInput(requested_output_min);
            desc.AddInput(requested_output_max);
            desc.SetAttr("out_type", out_type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RequantizePerChannel
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="input_min">Input to the operation. </param>
        /// <param name="input_max">Input to the operation. </param>
        /// <param name="requested_output_min">Input to the operation. </param>
        /// <param name="requested_output_max">Input to the operation. </param>
        /// <param name="out_type">out type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] output_min(type: DtFloat).
        /// [2] output_max(type: DtFloat).
        /// </returns>
        public Operation RequantizePerChannel(Output input, Output input_min, Output input_max, Output requested_output_min, Output requested_output_max, DataType? out_type = null, String opName = "RequantizePerChannel") 
        {
            OperationDescription desc = NewOperation("RequantizePerChannel", opName);
            desc.AddInput(input);
            desc.AddInput(input_min);
            desc.AddInput(input_max);
            desc.AddInput(requested_output_min);
            desc.AddInput(requested_output_max);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Reshape
        /// </summary>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Reshape(Output tensor, Output shape, String opName = "Reshape") 
        {
            OperationDescription desc = NewOperation("Reshape", opName);
            desc.AddInput(tensor);
            desc.AddInput(shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResizeArea
        /// </summary>
        /// <param name="images">Input to the operation. </param>
        /// <param name="size">Input to the operation. </param>
        /// <param name="align_corners">align corners</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] resized_images(type: DtFloat).
        /// </returns>
        public Operation ResizeArea(Output images, Output size, bool align_corners = false, String opName = "ResizeArea") 
        {
            OperationDescription desc = NewOperation("ResizeArea", opName);
            desc.AddInput(images);
            desc.AddInput(size);
            if (align_corners != false)
                desc.SetAttr("align_corners", align_corners);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResizeBicubic
        /// </summary>
        /// <param name="images">Input to the operation. </param>
        /// <param name="size">Input to the operation. </param>
        /// <param name="align_corners">align corners</param>
        /// <param name="half_pixel_centers">half pixel centers</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] resized_images(type: DtFloat).
        /// </returns>
        public Operation ResizeBicubic(Output images, Output size, bool align_corners = false, bool half_pixel_centers = false, String opName = "ResizeBicubic") 
        {
            OperationDescription desc = NewOperation("ResizeBicubic", opName);
            desc.AddInput(images);
            desc.AddInput(size);
            if (align_corners != false)
                desc.SetAttr("align_corners", align_corners);
            if (half_pixel_centers != false)
                desc.SetAttr("half_pixel_centers", half_pixel_centers);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResizeBicubicGrad
        /// </summary>
        /// <param name="grads">Input to the operation. </param>
        /// <param name="original_image">Input to the operation. </param>
        /// <param name="align_corners">align corners</param>
        /// <param name="half_pixel_centers">half pixel centers</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation ResizeBicubicGrad(Output grads, Output original_image, bool align_corners = false, bool half_pixel_centers = false, String opName = "ResizeBicubicGrad") 
        {
            OperationDescription desc = NewOperation("ResizeBicubicGrad", opName);
            desc.AddInput(grads);
            desc.AddInput(original_image);
            if (align_corners != false)
                desc.SetAttr("align_corners", align_corners);
            if (half_pixel_centers != false)
                desc.SetAttr("half_pixel_centers", half_pixel_centers);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResizeBilinear
        /// </summary>
        /// <param name="images">Input to the operation. </param>
        /// <param name="size">Input to the operation. </param>
        /// <param name="align_corners">align corners</param>
        /// <param name="half_pixel_centers">half pixel centers</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] resized_images(type: DtFloat).
        /// </returns>
        public Operation ResizeBilinear(Output images, Output size, bool align_corners = false, bool half_pixel_centers = false, String opName = "ResizeBilinear") 
        {
            OperationDescription desc = NewOperation("ResizeBilinear", opName);
            desc.AddInput(images);
            desc.AddInput(size);
            if (align_corners != false)
                desc.SetAttr("align_corners", align_corners);
            if (half_pixel_centers != false)
                desc.SetAttr("half_pixel_centers", half_pixel_centers);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResizeBilinearGrad
        /// </summary>
        /// <param name="grads">Input to the operation. </param>
        /// <param name="original_image">Input to the operation. </param>
        /// <param name="align_corners">align corners</param>
        /// <param name="half_pixel_centers">half pixel centers</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation ResizeBilinearGrad(Output grads, Output original_image, bool align_corners = false, bool half_pixel_centers = false, String opName = "ResizeBilinearGrad") 
        {
            OperationDescription desc = NewOperation("ResizeBilinearGrad", opName);
            desc.AddInput(grads);
            desc.AddInput(original_image);
            if (align_corners != false)
                desc.SetAttr("align_corners", align_corners);
            if (half_pixel_centers != false)
                desc.SetAttr("half_pixel_centers", half_pixel_centers);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResizeNearestNeighbor
        /// </summary>
        /// <param name="images">Input to the operation. </param>
        /// <param name="size">Input to the operation. </param>
        /// <param name="align_corners">align corners</param>
        /// <param name="half_pixel_centers">half pixel centers</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] resized_images(type: DtInvalid).
        /// </returns>
        public Operation ResizeNearestNeighbor(Output images, Output size, bool align_corners = false, bool half_pixel_centers = false, String opName = "ResizeNearestNeighbor") 
        {
            OperationDescription desc = NewOperation("ResizeNearestNeighbor", opName);
            desc.AddInput(images);
            desc.AddInput(size);
            if (align_corners != false)
                desc.SetAttr("align_corners", align_corners);
            if (half_pixel_centers != false)
                desc.SetAttr("half_pixel_centers", half_pixel_centers);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResizeNearestNeighborGrad
        /// </summary>
        /// <param name="grads">Input to the operation. </param>
        /// <param name="size">Input to the operation. </param>
        /// <param name="align_corners">align corners</param>
        /// <param name="half_pixel_centers">half pixel centers</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation ResizeNearestNeighborGrad(Output grads, Output size, bool align_corners = false, bool half_pixel_centers = false, String opName = "ResizeNearestNeighborGrad") 
        {
            OperationDescription desc = NewOperation("ResizeNearestNeighborGrad", opName);
            desc.AddInput(grads);
            desc.AddInput(size);
            if (align_corners != false)
                desc.SetAttr("align_corners", align_corners);
            if (half_pixel_centers != false)
                desc.SetAttr("half_pixel_centers", half_pixel_centers);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceAccumulatorApplyGradient
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="local_step">Input to the operation. </param>
        /// <param name="gradient">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceAccumulatorApplyGradient(Output handle, Output local_step, Output gradient, String opName = "ResourceAccumulatorApplyGradient") 
        {
            OperationDescription desc = NewOperation("ResourceAccumulatorApplyGradient", opName);
            desc.AddInput(handle);
            desc.AddInput(local_step);
            desc.AddInput(gradient);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceAccumulatorNumAccumulated
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] num_accumulated(type: DtInt32).
        /// </returns>
        public Operation ResourceAccumulatorNumAccumulated(Output handle, String opName = "ResourceAccumulatorNumAccumulated") 
        {
            OperationDescription desc = NewOperation("ResourceAccumulatorNumAccumulated", opName);
            desc.AddInput(handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceAccumulatorSetGlobalStep
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="new_global_step">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceAccumulatorSetGlobalStep(Output handle, Output new_global_step, String opName = "ResourceAccumulatorSetGlobalStep") 
        {
            OperationDescription desc = NewOperation("ResourceAccumulatorSetGlobalStep", opName);
            desc.AddInput(handle);
            desc.AddInput(new_global_step);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceAccumulatorTakeGradient
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="num_required">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] average(type: DtInvalid).
        /// </returns>
        public Operation ResourceAccumulatorTakeGradient(Output handle, Output num_required, DataType dtype, String opName = "ResourceAccumulatorTakeGradient") 
        {
            OperationDescription desc = NewOperation("ResourceAccumulatorTakeGradient", opName);
            desc.AddInput(handle);
            desc.AddInput(num_required);
            desc.SetAttr("dtype", dtype);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceApplyAdadelta
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="accum_update">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="rho">Input to the operation. </param>
        /// <param name="epsilon">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceApplyAdadelta(Output var, Output accum, Output accum_update, Output lr, Output rho, Output epsilon, Output grad, bool use_locking = false, String opName = "ResourceApplyAdadelta") 
        {
            OperationDescription desc = NewOperation("ResourceApplyAdadelta", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(accum_update);
            desc.AddInput(lr);
            desc.AddInput(rho);
            desc.AddInput(epsilon);
            desc.AddInput(grad);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceApplyAdagrad
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="update_slots">update slots</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceApplyAdagrad(Output var, Output accum, Output lr, Output grad, bool use_locking = false, bool update_slots = true, String opName = "ResourceApplyAdagrad") 
        {
            OperationDescription desc = NewOperation("ResourceApplyAdagrad", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(lr);
            desc.AddInput(grad);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            if (update_slots != true)
                desc.SetAttr("update_slots", update_slots);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceApplyAdagradDA
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="gradient_accumulator">Input to the operation. </param>
        /// <param name="gradient_squared_accumulator">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="l1">Input to the operation. </param>
        /// <param name="l2">Input to the operation. </param>
        /// <param name="global_step">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceApplyAdagradDA(Output var, Output gradient_accumulator, Output gradient_squared_accumulator, Output grad, Output lr, Output l1, Output l2, Output global_step, bool use_locking = false, String opName = "ResourceApplyAdagradDA") 
        {
            OperationDescription desc = NewOperation("ResourceApplyAdagradDA", opName);
            desc.AddInput(var);
            desc.AddInput(gradient_accumulator);
            desc.AddInput(gradient_squared_accumulator);
            desc.AddInput(grad);
            desc.AddInput(lr);
            desc.AddInput(l1);
            desc.AddInput(l2);
            desc.AddInput(global_step);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceApplyAdagradV2
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="epsilon">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="update_slots">update slots</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceApplyAdagradV2(Output var, Output accum, Output lr, Output epsilon, Output grad, bool use_locking = false, bool update_slots = true, String opName = "ResourceApplyAdagradV2") 
        {
            OperationDescription desc = NewOperation("ResourceApplyAdagradV2", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(lr);
            desc.AddInput(epsilon);
            desc.AddInput(grad);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            if (update_slots != true)
                desc.SetAttr("update_slots", update_slots);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceApplyAdam
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="m">Input to the operation. </param>
        /// <param name="v">Input to the operation. </param>
        /// <param name="beta1_power">Input to the operation. </param>
        /// <param name="beta2_power">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="beta1">Input to the operation. </param>
        /// <param name="beta2">Input to the operation. </param>
        /// <param name="epsilon">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="use_nesterov">use nesterov</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceApplyAdam(Output var, Output m, Output v, Output beta1_power, Output beta2_power, Output lr, Output beta1, Output beta2, Output epsilon, Output grad, bool use_locking = false, bool use_nesterov = false, String opName = "ResourceApplyAdam") 
        {
            OperationDescription desc = NewOperation("ResourceApplyAdam", opName);
            desc.AddInput(var);
            desc.AddInput(m);
            desc.AddInput(v);
            desc.AddInput(beta1_power);
            desc.AddInput(beta2_power);
            desc.AddInput(lr);
            desc.AddInput(beta1);
            desc.AddInput(beta2);
            desc.AddInput(epsilon);
            desc.AddInput(grad);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            if (use_nesterov != false)
                desc.SetAttr("use_nesterov", use_nesterov);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceApplyAdaMax
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="m">Input to the operation. </param>
        /// <param name="v">Input to the operation. </param>
        /// <param name="beta1_power">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="beta1">Input to the operation. </param>
        /// <param name="beta2">Input to the operation. </param>
        /// <param name="epsilon">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceApplyAdaMax(Output var, Output m, Output v, Output beta1_power, Output lr, Output beta1, Output beta2, Output epsilon, Output grad, bool use_locking = false, String opName = "ResourceApplyAdaMax") 
        {
            OperationDescription desc = NewOperation("ResourceApplyAdaMax", opName);
            desc.AddInput(var);
            desc.AddInput(m);
            desc.AddInput(v);
            desc.AddInput(beta1_power);
            desc.AddInput(lr);
            desc.AddInput(beta1);
            desc.AddInput(beta2);
            desc.AddInput(epsilon);
            desc.AddInput(grad);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceApplyAdamWithAmsgrad
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="m">Input to the operation. </param>
        /// <param name="v">Input to the operation. </param>
        /// <param name="vhat">Input to the operation. </param>
        /// <param name="beta1_power">Input to the operation. </param>
        /// <param name="beta2_power">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="beta1">Input to the operation. </param>
        /// <param name="beta2">Input to the operation. </param>
        /// <param name="epsilon">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceApplyAdamWithAmsgrad(Output var, Output m, Output v, Output vhat, Output beta1_power, Output beta2_power, Output lr, Output beta1, Output beta2, Output epsilon, Output grad, bool use_locking = false, String opName = "ResourceApplyAdamWithAmsgrad") 
        {
            OperationDescription desc = NewOperation("ResourceApplyAdamWithAmsgrad", opName);
            desc.AddInput(var);
            desc.AddInput(m);
            desc.AddInput(v);
            desc.AddInput(vhat);
            desc.AddInput(beta1_power);
            desc.AddInput(beta2_power);
            desc.AddInput(lr);
            desc.AddInput(beta1);
            desc.AddInput(beta2);
            desc.AddInput(epsilon);
            desc.AddInput(grad);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceApplyAddSign
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="m">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="alpha">Input to the operation. </param>
        /// <param name="sign_decay">Input to the operation. </param>
        /// <param name="beta">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceApplyAddSign(Output var, Output m, Output lr, Output alpha, Output sign_decay, Output beta, Output grad, bool use_locking = false, String opName = "ResourceApplyAddSign") 
        {
            OperationDescription desc = NewOperation("ResourceApplyAddSign", opName);
            desc.AddInput(var);
            desc.AddInput(m);
            desc.AddInput(lr);
            desc.AddInput(alpha);
            desc.AddInput(sign_decay);
            desc.AddInput(beta);
            desc.AddInput(grad);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceApplyCenteredRMSProp
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="mg">Input to the operation. </param>
        /// <param name="ms">Input to the operation. </param>
        /// <param name="mom">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="rho">Input to the operation. </param>
        /// <param name="momentum">Input to the operation. </param>
        /// <param name="epsilon">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceApplyCenteredRMSProp(Output var, Output mg, Output ms, Output mom, Output lr, Output rho, Output momentum, Output epsilon, Output grad, bool use_locking = false, String opName = "ResourceApplyCenteredRMSProp") 
        {
            OperationDescription desc = NewOperation("ResourceApplyCenteredRMSProp", opName);
            desc.AddInput(var);
            desc.AddInput(mg);
            desc.AddInput(ms);
            desc.AddInput(mom);
            desc.AddInput(lr);
            desc.AddInput(rho);
            desc.AddInput(momentum);
            desc.AddInput(epsilon);
            desc.AddInput(grad);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceApplyFtrl
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="linear">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="l1">Input to the operation. </param>
        /// <param name="l2">Input to the operation. </param>
        /// <param name="lr_power">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="multiply_linear_by_lr">multiply linear by lr</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceApplyFtrl(Output var, Output accum, Output linear, Output grad, Output lr, Output l1, Output l2, Output lr_power, bool use_locking = false, bool multiply_linear_by_lr = false, String opName = "ResourceApplyFtrl") 
        {
            OperationDescription desc = NewOperation("ResourceApplyFtrl", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(linear);
            desc.AddInput(grad);
            desc.AddInput(lr);
            desc.AddInput(l1);
            desc.AddInput(l2);
            desc.AddInput(lr_power);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            if (multiply_linear_by_lr != false)
                desc.SetAttr("multiply_linear_by_lr", multiply_linear_by_lr);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceApplyFtrlV2
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="linear">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="l1">Input to the operation. </param>
        /// <param name="l2">Input to the operation. </param>
        /// <param name="l2_shrinkage">Input to the operation. </param>
        /// <param name="lr_power">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="multiply_linear_by_lr">multiply linear by lr</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceApplyFtrlV2(Output var, Output accum, Output linear, Output grad, Output lr, Output l1, Output l2, Output l2_shrinkage, Output lr_power, bool use_locking = false, bool multiply_linear_by_lr = false, String opName = "ResourceApplyFtrlV2") 
        {
            OperationDescription desc = NewOperation("ResourceApplyFtrlV2", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(linear);
            desc.AddInput(grad);
            desc.AddInput(lr);
            desc.AddInput(l1);
            desc.AddInput(l2);
            desc.AddInput(l2_shrinkage);
            desc.AddInput(lr_power);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            if (multiply_linear_by_lr != false)
                desc.SetAttr("multiply_linear_by_lr", multiply_linear_by_lr);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceApplyGradientDescent
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="alpha">Input to the operation. </param>
        /// <param name="delta">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceApplyGradientDescent(Output var, Output alpha, Output delta, bool use_locking = false, String opName = "ResourceApplyGradientDescent") 
        {
            OperationDescription desc = NewOperation("ResourceApplyGradientDescent", opName);
            desc.AddInput(var);
            desc.AddInput(alpha);
            desc.AddInput(delta);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceApplyKerasMomentum
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="momentum">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="use_nesterov">use nesterov</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceApplyKerasMomentum(Output var, Output accum, Output lr, Output grad, Output momentum, bool use_locking = false, bool use_nesterov = false, String opName = "ResourceApplyKerasMomentum") 
        {
            OperationDescription desc = NewOperation("ResourceApplyKerasMomentum", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(lr);
            desc.AddInput(grad);
            desc.AddInput(momentum);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            if (use_nesterov != false)
                desc.SetAttr("use_nesterov", use_nesterov);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceApplyMomentum
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="momentum">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="use_nesterov">use nesterov</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceApplyMomentum(Output var, Output accum, Output lr, Output grad, Output momentum, bool use_locking = false, bool use_nesterov = false, String opName = "ResourceApplyMomentum") 
        {
            OperationDescription desc = NewOperation("ResourceApplyMomentum", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(lr);
            desc.AddInput(grad);
            desc.AddInput(momentum);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            if (use_nesterov != false)
                desc.SetAttr("use_nesterov", use_nesterov);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceApplyPowerSign
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="m">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="logbase">Input to the operation. </param>
        /// <param name="sign_decay">Input to the operation. </param>
        /// <param name="beta">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceApplyPowerSign(Output var, Output m, Output lr, Output logbase, Output sign_decay, Output beta, Output grad, bool use_locking = false, String opName = "ResourceApplyPowerSign") 
        {
            OperationDescription desc = NewOperation("ResourceApplyPowerSign", opName);
            desc.AddInput(var);
            desc.AddInput(m);
            desc.AddInput(lr);
            desc.AddInput(logbase);
            desc.AddInput(sign_decay);
            desc.AddInput(beta);
            desc.AddInput(grad);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceApplyProximalAdagrad
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="l1">Input to the operation. </param>
        /// <param name="l2">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceApplyProximalAdagrad(Output var, Output accum, Output lr, Output l1, Output l2, Output grad, bool use_locking = false, String opName = "ResourceApplyProximalAdagrad") 
        {
            OperationDescription desc = NewOperation("ResourceApplyProximalAdagrad", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(lr);
            desc.AddInput(l1);
            desc.AddInput(l2);
            desc.AddInput(grad);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceApplyProximalGradientDescent
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="alpha">Input to the operation. </param>
        /// <param name="l1">Input to the operation. </param>
        /// <param name="l2">Input to the operation. </param>
        /// <param name="delta">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceApplyProximalGradientDescent(Output var, Output alpha, Output l1, Output l2, Output delta, bool use_locking = false, String opName = "ResourceApplyProximalGradientDescent") 
        {
            OperationDescription desc = NewOperation("ResourceApplyProximalGradientDescent", opName);
            desc.AddInput(var);
            desc.AddInput(alpha);
            desc.AddInput(l1);
            desc.AddInput(l2);
            desc.AddInput(delta);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceApplyRMSProp
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="ms">Input to the operation. </param>
        /// <param name="mom">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="rho">Input to the operation. </param>
        /// <param name="momentum">Input to the operation. </param>
        /// <param name="epsilon">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceApplyRMSProp(Output var, Output ms, Output mom, Output lr, Output rho, Output momentum, Output epsilon, Output grad, bool use_locking = false, String opName = "ResourceApplyRMSProp") 
        {
            OperationDescription desc = NewOperation("ResourceApplyRMSProp", opName);
            desc.AddInput(var);
            desc.AddInput(ms);
            desc.AddInput(mom);
            desc.AddInput(lr);
            desc.AddInput(rho);
            desc.AddInput(momentum);
            desc.AddInput(epsilon);
            desc.AddInput(grad);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceConditionalAccumulator
        /// </summary>
        /// <param name="dtype">dtype</param>
        /// <param name="shape">shape</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="reduction_type">reduction type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// </returns>
        public Operation ResourceConditionalAccumulator(DataType dtype, long[] shape, string container = null, string shared_name = null, string reduction_type = null, String opName = "ResourceConditionalAccumulator") 
        {
            OperationDescription desc = NewOperation("ResourceConditionalAccumulator", opName);
            desc.SetAttr("dtype", dtype);
            desc.SetAttrShape("shape", shape);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            if (reduction_type != null)
                 desc.SetAttr("reduction_type", reduction_type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceCountUpTo
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="limit">limit</param>
        /// <param name="T">T</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation ResourceCountUpTo(Output resource, long limit, DataType T, String opName = "ResourceCountUpTo") 
        {
            OperationDescription desc = NewOperation("ResourceCountUpTo", opName);
            desc.AddInput(resource);
            desc.SetAttr("limit", limit);
            desc.SetAttr("T", T);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceGather
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="batch_dims">batch dims</param>
        /// <param name="validate_indices">validate indices</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation ResourceGather(Output resource, Output indices, DataType dtype, long batch_dims = 0, bool validate_indices = true, String opName = "ResourceGather") 
        {
            OperationDescription desc = NewOperation("ResourceGather", opName);
            desc.AddInput(resource);
            desc.AddInput(indices);
            desc.SetAttr("dtype", dtype);
            if (batch_dims != 0)
                desc.SetAttr("batch_dims", batch_dims);
            if (validate_indices != true)
                desc.SetAttr("validate_indices", validate_indices);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceGatherNd
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation ResourceGatherNd(Output resource, Output indices, DataType dtype, String opName = "ResourceGatherNd") 
        {
            OperationDescription desc = NewOperation("ResourceGatherNd", opName);
            desc.AddInput(resource);
            desc.AddInput(indices);
            desc.SetAttr("dtype", dtype);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceScatterAdd
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceScatterAdd(Output resource, Output indices, Output updates, String opName = "ResourceScatterAdd") 
        {
            OperationDescription desc = NewOperation("ResourceScatterAdd", opName);
            desc.AddInput(resource);
            desc.AddInput(indices);
            desc.AddInput(updates);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceScatterDiv
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceScatterDiv(Output resource, Output indices, Output updates, String opName = "ResourceScatterDiv") 
        {
            OperationDescription desc = NewOperation("ResourceScatterDiv", opName);
            desc.AddInput(resource);
            desc.AddInput(indices);
            desc.AddInput(updates);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceScatterMax
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceScatterMax(Output resource, Output indices, Output updates, String opName = "ResourceScatterMax") 
        {
            OperationDescription desc = NewOperation("ResourceScatterMax", opName);
            desc.AddInput(resource);
            desc.AddInput(indices);
            desc.AddInput(updates);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceScatterMin
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceScatterMin(Output resource, Output indices, Output updates, String opName = "ResourceScatterMin") 
        {
            OperationDescription desc = NewOperation("ResourceScatterMin", opName);
            desc.AddInput(resource);
            desc.AddInput(indices);
            desc.AddInput(updates);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceScatterMul
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceScatterMul(Output resource, Output indices, Output updates, String opName = "ResourceScatterMul") 
        {
            OperationDescription desc = NewOperation("ResourceScatterMul", opName);
            desc.AddInput(resource);
            desc.AddInput(indices);
            desc.AddInput(updates);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceScatterNdAdd
        /// </summary>
        /// <param name="reference">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceScatterNdAdd(Output reference, Output indices, Output updates, bool use_locking = true, String opName = "ResourceScatterNdAdd") 
        {
            OperationDescription desc = NewOperation("ResourceScatterNdAdd", opName);
            desc.AddInput(reference);
            desc.AddInput(indices);
            desc.AddInput(updates);
            if (use_locking != true)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceScatterNdMax
        /// </summary>
        /// <param name="reference">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceScatterNdMax(Output reference, Output indices, Output updates, bool use_locking = true, String opName = "ResourceScatterNdMax") 
        {
            OperationDescription desc = NewOperation("ResourceScatterNdMax", opName);
            desc.AddInput(reference);
            desc.AddInput(indices);
            desc.AddInput(updates);
            if (use_locking != true)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceScatterNdMin
        /// </summary>
        /// <param name="reference">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceScatterNdMin(Output reference, Output indices, Output updates, bool use_locking = true, String opName = "ResourceScatterNdMin") 
        {
            OperationDescription desc = NewOperation("ResourceScatterNdMin", opName);
            desc.AddInput(reference);
            desc.AddInput(indices);
            desc.AddInput(updates);
            if (use_locking != true)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceScatterNdSub
        /// </summary>
        /// <param name="reference">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceScatterNdSub(Output reference, Output indices, Output updates, bool use_locking = true, String opName = "ResourceScatterNdSub") 
        {
            OperationDescription desc = NewOperation("ResourceScatterNdSub", opName);
            desc.AddInput(reference);
            desc.AddInput(indices);
            desc.AddInput(updates);
            if (use_locking != true)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceScatterNdUpdate
        /// </summary>
        /// <param name="reference">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceScatterNdUpdate(Output reference, Output indices, Output updates, bool use_locking = true, String opName = "ResourceScatterNdUpdate") 
        {
            OperationDescription desc = NewOperation("ResourceScatterNdUpdate", opName);
            desc.AddInput(reference);
            desc.AddInput(indices);
            desc.AddInput(updates);
            if (use_locking != true)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceScatterSub
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceScatterSub(Output resource, Output indices, Output updates, String opName = "ResourceScatterSub") 
        {
            OperationDescription desc = NewOperation("ResourceScatterSub", opName);
            desc.AddInput(resource);
            desc.AddInput(indices);
            desc.AddInput(updates);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceScatterUpdate
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceScatterUpdate(Output resource, Output indices, Output updates, String opName = "ResourceScatterUpdate") 
        {
            OperationDescription desc = NewOperation("ResourceScatterUpdate", opName);
            desc.AddInput(resource);
            desc.AddInput(indices);
            desc.AddInput(updates);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceSparseApplyAdadelta
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="accum_update">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="rho">Input to the operation. </param>
        /// <param name="epsilon">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceSparseApplyAdadelta(Output var, Output accum, Output accum_update, Output lr, Output rho, Output epsilon, Output grad, Output indices, bool use_locking = false, String opName = "ResourceSparseApplyAdadelta") 
        {
            OperationDescription desc = NewOperation("ResourceSparseApplyAdadelta", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(accum_update);
            desc.AddInput(lr);
            desc.AddInput(rho);
            desc.AddInput(epsilon);
            desc.AddInput(grad);
            desc.AddInput(indices);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceSparseApplyAdagrad
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="update_slots">update slots</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceSparseApplyAdagrad(Output var, Output accum, Output lr, Output grad, Output indices, bool use_locking = false, bool update_slots = true, String opName = "ResourceSparseApplyAdagrad") 
        {
            OperationDescription desc = NewOperation("ResourceSparseApplyAdagrad", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(lr);
            desc.AddInput(grad);
            desc.AddInput(indices);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            if (update_slots != true)
                desc.SetAttr("update_slots", update_slots);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceSparseApplyAdagradDA
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="gradient_accumulator">Input to the operation. </param>
        /// <param name="gradient_squared_accumulator">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="l1">Input to the operation. </param>
        /// <param name="l2">Input to the operation. </param>
        /// <param name="global_step">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceSparseApplyAdagradDA(Output var, Output gradient_accumulator, Output gradient_squared_accumulator, Output grad, Output indices, Output lr, Output l1, Output l2, Output global_step, bool use_locking = false, String opName = "ResourceSparseApplyAdagradDA") 
        {
            OperationDescription desc = NewOperation("ResourceSparseApplyAdagradDA", opName);
            desc.AddInput(var);
            desc.AddInput(gradient_accumulator);
            desc.AddInput(gradient_squared_accumulator);
            desc.AddInput(grad);
            desc.AddInput(indices);
            desc.AddInput(lr);
            desc.AddInput(l1);
            desc.AddInput(l2);
            desc.AddInput(global_step);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceSparseApplyAdagradV2
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="epsilon">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="update_slots">update slots</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceSparseApplyAdagradV2(Output var, Output accum, Output lr, Output epsilon, Output grad, Output indices, bool use_locking = false, bool update_slots = true, String opName = "ResourceSparseApplyAdagradV2") 
        {
            OperationDescription desc = NewOperation("ResourceSparseApplyAdagradV2", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(lr);
            desc.AddInput(epsilon);
            desc.AddInput(grad);
            desc.AddInput(indices);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            if (update_slots != true)
                desc.SetAttr("update_slots", update_slots);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceSparseApplyCenteredRMSProp
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="mg">Input to the operation. </param>
        /// <param name="ms">Input to the operation. </param>
        /// <param name="mom">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="rho">Input to the operation. </param>
        /// <param name="momentum">Input to the operation. </param>
        /// <param name="epsilon">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceSparseApplyCenteredRMSProp(Output var, Output mg, Output ms, Output mom, Output lr, Output rho, Output momentum, Output epsilon, Output grad, Output indices, bool use_locking = false, String opName = "ResourceSparseApplyCenteredRMSProp") 
        {
            OperationDescription desc = NewOperation("ResourceSparseApplyCenteredRMSProp", opName);
            desc.AddInput(var);
            desc.AddInput(mg);
            desc.AddInput(ms);
            desc.AddInput(mom);
            desc.AddInput(lr);
            desc.AddInput(rho);
            desc.AddInput(momentum);
            desc.AddInput(epsilon);
            desc.AddInput(grad);
            desc.AddInput(indices);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceSparseApplyFtrl
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="linear">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="l1">Input to the operation. </param>
        /// <param name="l2">Input to the operation. </param>
        /// <param name="lr_power">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="multiply_linear_by_lr">multiply linear by lr</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceSparseApplyFtrl(Output var, Output accum, Output linear, Output grad, Output indices, Output lr, Output l1, Output l2, Output lr_power, bool use_locking = false, bool multiply_linear_by_lr = false, String opName = "ResourceSparseApplyFtrl") 
        {
            OperationDescription desc = NewOperation("ResourceSparseApplyFtrl", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(linear);
            desc.AddInput(grad);
            desc.AddInput(indices);
            desc.AddInput(lr);
            desc.AddInput(l1);
            desc.AddInput(l2);
            desc.AddInput(lr_power);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            if (multiply_linear_by_lr != false)
                desc.SetAttr("multiply_linear_by_lr", multiply_linear_by_lr);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceSparseApplyFtrlV2
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="linear">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="l1">Input to the operation. </param>
        /// <param name="l2">Input to the operation. </param>
        /// <param name="l2_shrinkage">Input to the operation. </param>
        /// <param name="lr_power">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="multiply_linear_by_lr">multiply linear by lr</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceSparseApplyFtrlV2(Output var, Output accum, Output linear, Output grad, Output indices, Output lr, Output l1, Output l2, Output l2_shrinkage, Output lr_power, bool use_locking = false, bool multiply_linear_by_lr = false, String opName = "ResourceSparseApplyFtrlV2") 
        {
            OperationDescription desc = NewOperation("ResourceSparseApplyFtrlV2", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(linear);
            desc.AddInput(grad);
            desc.AddInput(indices);
            desc.AddInput(lr);
            desc.AddInput(l1);
            desc.AddInput(l2);
            desc.AddInput(l2_shrinkage);
            desc.AddInput(lr_power);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            if (multiply_linear_by_lr != false)
                desc.SetAttr("multiply_linear_by_lr", multiply_linear_by_lr);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceSparseApplyKerasMomentum
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="momentum">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="use_nesterov">use nesterov</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceSparseApplyKerasMomentum(Output var, Output accum, Output lr, Output grad, Output indices, Output momentum, bool use_locking = false, bool use_nesterov = false, String opName = "ResourceSparseApplyKerasMomentum") 
        {
            OperationDescription desc = NewOperation("ResourceSparseApplyKerasMomentum", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(lr);
            desc.AddInput(grad);
            desc.AddInput(indices);
            desc.AddInput(momentum);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            if (use_nesterov != false)
                desc.SetAttr("use_nesterov", use_nesterov);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceSparseApplyMomentum
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="momentum">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="use_nesterov">use nesterov</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceSparseApplyMomentum(Output var, Output accum, Output lr, Output grad, Output indices, Output momentum, bool use_locking = false, bool use_nesterov = false, String opName = "ResourceSparseApplyMomentum") 
        {
            OperationDescription desc = NewOperation("ResourceSparseApplyMomentum", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(lr);
            desc.AddInput(grad);
            desc.AddInput(indices);
            desc.AddInput(momentum);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            if (use_nesterov != false)
                desc.SetAttr("use_nesterov", use_nesterov);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceSparseApplyProximalAdagrad
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="l1">Input to the operation. </param>
        /// <param name="l2">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceSparseApplyProximalAdagrad(Output var, Output accum, Output lr, Output l1, Output l2, Output grad, Output indices, bool use_locking = false, String opName = "ResourceSparseApplyProximalAdagrad") 
        {
            OperationDescription desc = NewOperation("ResourceSparseApplyProximalAdagrad", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(lr);
            desc.AddInput(l1);
            desc.AddInput(l2);
            desc.AddInput(grad);
            desc.AddInput(indices);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceSparseApplyProximalGradientDescent
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="alpha">Input to the operation. </param>
        /// <param name="l1">Input to the operation. </param>
        /// <param name="l2">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceSparseApplyProximalGradientDescent(Output var, Output alpha, Output l1, Output l2, Output grad, Output indices, bool use_locking = false, String opName = "ResourceSparseApplyProximalGradientDescent") 
        {
            OperationDescription desc = NewOperation("ResourceSparseApplyProximalGradientDescent", opName);
            desc.AddInput(var);
            desc.AddInput(alpha);
            desc.AddInput(l1);
            desc.AddInput(l2);
            desc.AddInput(grad);
            desc.AddInput(indices);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceSparseApplyRMSProp
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="ms">Input to the operation. </param>
        /// <param name="mom">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="rho">Input to the operation. </param>
        /// <param name="momentum">Input to the operation. </param>
        /// <param name="epsilon">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceSparseApplyRMSProp(Output var, Output ms, Output mom, Output lr, Output rho, Output momentum, Output epsilon, Output grad, Output indices, bool use_locking = false, String opName = "ResourceSparseApplyRMSProp") 
        {
            OperationDescription desc = NewOperation("ResourceSparseApplyRMSProp", opName);
            desc.AddInput(var);
            desc.AddInput(ms);
            desc.AddInput(mom);
            desc.AddInput(lr);
            desc.AddInput(rho);
            desc.AddInput(momentum);
            desc.AddInput(epsilon);
            desc.AddInput(grad);
            desc.AddInput(indices);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ResourceStridedSliceAssign
        /// </summary>
        /// <param name="reference">Input to the operation. </param>
        /// <param name="begin">Input to the operation. </param>
        /// <param name="end">Input to the operation. </param>
        /// <param name="strides">Input to the operation. </param>
        /// <param name="value">Input to the operation. </param>
        /// <param name="begin_mask">begin mask</param>
        /// <param name="end_mask">end mask</param>
        /// <param name="ellipsis_mask">ellipsis mask</param>
        /// <param name="new_axis_mask">new axis mask</param>
        /// <param name="shrink_axis_mask">shrink axis mask</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ResourceStridedSliceAssign(Output reference, Output begin, Output end, Output strides, Output value, long begin_mask = 0, long end_mask = 0, long ellipsis_mask = 0, long new_axis_mask = 0, long shrink_axis_mask = 0, String opName = "ResourceStridedSliceAssign") 
        {
            OperationDescription desc = NewOperation("ResourceStridedSliceAssign", opName);
            desc.AddInput(reference);
            desc.AddInput(begin);
            desc.AddInput(end);
            desc.AddInput(strides);
            desc.AddInput(value);
            if (begin_mask != 0)
                desc.SetAttr("begin_mask", begin_mask);
            if (end_mask != 0)
                desc.SetAttr("end_mask", end_mask);
            if (ellipsis_mask != 0)
                desc.SetAttr("ellipsis_mask", ellipsis_mask);
            if (new_axis_mask != 0)
                desc.SetAttr("new_axis_mask", new_axis_mask);
            if (shrink_axis_mask != 0)
                desc.SetAttr("shrink_axis_mask", shrink_axis_mask);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Restore
        /// </summary>
        /// <param name="file_pattern">Input to the operation. </param>
        /// <param name="tensor_name">Input to the operation. </param>
        /// <param name="dt">dt</param>
        /// <param name="preferred_shard">preferred shard</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] tensor(type: DtInvalid).
        /// </returns>
        public Operation Restore(Output file_pattern, Output tensor_name, DataType dt, long preferred_shard = -1, String opName = "Restore") 
        {
            OperationDescription desc = NewOperation("Restore", opName);
            desc.AddInput(file_pattern);
            desc.AddInput(tensor_name);
            desc.SetAttr("dt", dt);
            if (preferred_shard != -1)
                desc.SetAttr("preferred_shard", preferred_shard);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RestoreSlice
        /// </summary>
        /// <param name="file_pattern">Input to the operation. </param>
        /// <param name="tensor_name">Input to the operation. </param>
        /// <param name="shape_and_slice">Input to the operation. </param>
        /// <param name="dt">dt</param>
        /// <param name="preferred_shard">preferred shard</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] tensor(type: DtInvalid).
        /// </returns>
        public Operation RestoreSlice(Output file_pattern, Output tensor_name, Output shape_and_slice, DataType dt, long preferred_shard = -1, String opName = "RestoreSlice") 
        {
            OperationDescription desc = NewOperation("RestoreSlice", opName);
            desc.AddInput(file_pattern);
            desc.AddInput(tensor_name);
            desc.AddInput(shape_and_slice);
            desc.SetAttr("dt", dt);
            if (preferred_shard != -1)
                desc.SetAttr("preferred_shard", preferred_shard);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RestoreV2
        /// </summary>
        /// <param name="prefix">Input to the operation. </param>
        /// <param name="tensor_names">Input to the operation. </param>
        /// <param name="shape_and_slices">Input to the operation. </param>
        /// <param name="dtypes">dtypes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] tensors(type: DtInvalid).
        /// </returns>
        public Operation RestoreV2(Output prefix, Output tensor_names, Output shape_and_slices, DataType[] dtypes, String opName = "RestoreV2") 
        {
            OperationDescription desc = NewOperation("RestoreV2", opName);
            desc.AddInput(prefix);
            desc.AddInput(tensor_names);
            desc.AddInput(shape_and_slices);
            desc.SetAttr("dtypes", dtypes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RetrieveAllTPUEmbeddingParameters
        /// </summary>
        /// <param name="NumTables">NumTables</param>
        /// <param name="config">config</param>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] parameters(type: DtFloat).
        /// [1] auxiliary1(type: DtFloat).
        /// [2] auxiliary2(type: DtFloat).
        /// [3] auxiliary3(type: DtFloat).
        /// [4] auxiliary4(type: DtFloat).
        /// [5] auxiliary5(type: DtFloat).
        /// [6] auxiliary6(type: DtFloat).
        /// [7] auxiliary7(type: DtFloat).
        /// </returns>
        public Operation RetrieveAllTPUEmbeddingParameters(long NumTables, string config, long num_shards, long shard_id, String opName = "RetrieveAllTPUEmbeddingParameters") 
        {
            OperationDescription desc = NewOperation("RetrieveAllTPUEmbeddingParameters", opName);
            desc.SetAttr("NumTables", NumTables);
            desc.SetAttr("config", config);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RetrieveTPUEmbeddingAdadeltaParameters
        /// </summary>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="table_id">table id</param>
        /// <param name="table_name">table name</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] parameters(type: DtFloat).
        /// [1] accumulators(type: DtFloat).
        /// [2] updates(type: DtFloat).
        /// </returns>
        public Operation RetrieveTPUEmbeddingAdadeltaParameters(long num_shards, long shard_id, long table_id = -1, string table_name = null, string config = null, String opName = "RetrieveTPUEmbeddingAdadeltaParameters") 
        {
            OperationDescription desc = NewOperation("RetrieveTPUEmbeddingAdadeltaParameters", opName);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            if (table_id != -1)
                desc.SetAttr("table_id", table_id);
            if (table_name != null)
                 desc.SetAttr("table_name", table_name);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RetrieveTPUEmbeddingAdagradMomentumParameters
        /// </summary>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="table_id">table id</param>
        /// <param name="table_name">table name</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] parameters(type: DtFloat).
        /// [1] accumulators(type: DtFloat).
        /// [2] momenta(type: DtFloat).
        /// </returns>
        public Operation RetrieveTPUEmbeddingAdagradMomentumParameters(long num_shards, long shard_id, long table_id = -1, string table_name = null, string config = null, String opName = "RetrieveTPUEmbeddingAdagradMomentumParameters") 
        {
            OperationDescription desc = NewOperation("RetrieveTPUEmbeddingAdagradMomentumParameters", opName);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            if (table_id != -1)
                desc.SetAttr("table_id", table_id);
            if (table_name != null)
                 desc.SetAttr("table_name", table_name);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RetrieveTPUEmbeddingAdagradParameters
        /// </summary>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="table_id">table id</param>
        /// <param name="table_name">table name</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] parameters(type: DtFloat).
        /// [1] accumulators(type: DtFloat).
        /// </returns>
        public Operation RetrieveTPUEmbeddingAdagradParameters(long num_shards, long shard_id, long table_id = -1, string table_name = null, string config = null, String opName = "RetrieveTPUEmbeddingAdagradParameters") 
        {
            OperationDescription desc = NewOperation("RetrieveTPUEmbeddingAdagradParameters", opName);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            if (table_id != -1)
                desc.SetAttr("table_id", table_id);
            if (table_name != null)
                 desc.SetAttr("table_name", table_name);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RetrieveTPUEmbeddingADAMParameters
        /// </summary>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="table_id">table id</param>
        /// <param name="table_name">table name</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] parameters(type: DtFloat).
        /// [1] momenta(type: DtFloat).
        /// [2] velocities(type: DtFloat).
        /// </returns>
        public Operation RetrieveTPUEmbeddingADAMParameters(long num_shards, long shard_id, long table_id = -1, string table_name = null, string config = null, String opName = "RetrieveTPUEmbeddingADAMParameters") 
        {
            OperationDescription desc = NewOperation("RetrieveTPUEmbeddingADAMParameters", opName);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            if (table_id != -1)
                desc.SetAttr("table_id", table_id);
            if (table_name != null)
                 desc.SetAttr("table_name", table_name);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RetrieveTPUEmbeddingCenteredRMSPropParameters
        /// </summary>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="table_id">table id</param>
        /// <param name="table_name">table name</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] parameters(type: DtFloat).
        /// [1] ms(type: DtFloat).
        /// [2] mom(type: DtFloat).
        /// [3] mg(type: DtFloat).
        /// </returns>
        public Operation RetrieveTPUEmbeddingCenteredRMSPropParameters(long num_shards, long shard_id, long table_id = -1, string table_name = null, string config = null, String opName = "RetrieveTPUEmbeddingCenteredRMSPropParameters") 
        {
            OperationDescription desc = NewOperation("RetrieveTPUEmbeddingCenteredRMSPropParameters", opName);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            if (table_id != -1)
                desc.SetAttr("table_id", table_id);
            if (table_name != null)
                 desc.SetAttr("table_name", table_name);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RetrieveTPUEmbeddingFrequencyEstimatorParameters
        /// </summary>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="table_id">table id</param>
        /// <param name="table_name">table name</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] parameters(type: DtFloat).
        /// [1] last_hit_step(type: DtFloat).
        /// </returns>
        public Operation RetrieveTPUEmbeddingFrequencyEstimatorParameters(long num_shards, long shard_id, long table_id = -1, string table_name = null, string config = null, String opName = "RetrieveTPUEmbeddingFrequencyEstimatorParameters") 
        {
            OperationDescription desc = NewOperation("RetrieveTPUEmbeddingFrequencyEstimatorParameters", opName);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            if (table_id != -1)
                desc.SetAttr("table_id", table_id);
            if (table_name != null)
                 desc.SetAttr("table_name", table_name);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RetrieveTPUEmbeddingFTRLParameters
        /// </summary>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="table_id">table id</param>
        /// <param name="table_name">table name</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] parameters(type: DtFloat).
        /// [1] accumulators(type: DtFloat).
        /// [2] linears(type: DtFloat).
        /// </returns>
        public Operation RetrieveTPUEmbeddingFTRLParameters(long num_shards, long shard_id, long table_id = -1, string table_name = null, string config = null, String opName = "RetrieveTPUEmbeddingFTRLParameters") 
        {
            OperationDescription desc = NewOperation("RetrieveTPUEmbeddingFTRLParameters", opName);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            if (table_id != -1)
                desc.SetAttr("table_id", table_id);
            if (table_name != null)
                 desc.SetAttr("table_name", table_name);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RetrieveTPUEmbeddingMDLAdagradLightParameters
        /// </summary>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="table_id">table id</param>
        /// <param name="table_name">table name</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] parameters(type: DtFloat).
        /// [1] accumulators(type: DtFloat).
        /// [2] weights(type: DtFloat).
        /// [3] benefits(type: DtFloat).
        /// </returns>
        public Operation RetrieveTPUEmbeddingMDLAdagradLightParameters(long num_shards, long shard_id, long table_id = -1, string table_name = null, string config = null, String opName = "RetrieveTPUEmbeddingMDLAdagradLightParameters") 
        {
            OperationDescription desc = NewOperation("RetrieveTPUEmbeddingMDLAdagradLightParameters", opName);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            if (table_id != -1)
                desc.SetAttr("table_id", table_id);
            if (table_name != null)
                 desc.SetAttr("table_name", table_name);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RetrieveTPUEmbeddingMomentumParameters
        /// </summary>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="table_id">table id</param>
        /// <param name="table_name">table name</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] parameters(type: DtFloat).
        /// [1] momenta(type: DtFloat).
        /// </returns>
        public Operation RetrieveTPUEmbeddingMomentumParameters(long num_shards, long shard_id, long table_id = -1, string table_name = null, string config = null, String opName = "RetrieveTPUEmbeddingMomentumParameters") 
        {
            OperationDescription desc = NewOperation("RetrieveTPUEmbeddingMomentumParameters", opName);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            if (table_id != -1)
                desc.SetAttr("table_id", table_id);
            if (table_name != null)
                 desc.SetAttr("table_name", table_name);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RetrieveTPUEmbeddingProximalAdagradParameters
        /// </summary>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="table_id">table id</param>
        /// <param name="table_name">table name</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] parameters(type: DtFloat).
        /// [1] accumulators(type: DtFloat).
        /// </returns>
        public Operation RetrieveTPUEmbeddingProximalAdagradParameters(long num_shards, long shard_id, long table_id = -1, string table_name = null, string config = null, String opName = "RetrieveTPUEmbeddingProximalAdagradParameters") 
        {
            OperationDescription desc = NewOperation("RetrieveTPUEmbeddingProximalAdagradParameters", opName);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            if (table_id != -1)
                desc.SetAttr("table_id", table_id);
            if (table_name != null)
                 desc.SetAttr("table_name", table_name);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RetrieveTPUEmbeddingProximalYogiParameters
        /// </summary>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="table_id">table id</param>
        /// <param name="table_name">table name</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] parameters(type: DtFloat).
        /// [1] v(type: DtFloat).
        /// [2] m(type: DtFloat).
        /// </returns>
        public Operation RetrieveTPUEmbeddingProximalYogiParameters(long num_shards, long shard_id, long table_id = -1, string table_name = null, string config = null, String opName = "RetrieveTPUEmbeddingProximalYogiParameters") 
        {
            OperationDescription desc = NewOperation("RetrieveTPUEmbeddingProximalYogiParameters", opName);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            if (table_id != -1)
                desc.SetAttr("table_id", table_id);
            if (table_name != null)
                 desc.SetAttr("table_name", table_name);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RetrieveTPUEmbeddingRMSPropParameters
        /// </summary>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="table_id">table id</param>
        /// <param name="table_name">table name</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] parameters(type: DtFloat).
        /// [1] ms(type: DtFloat).
        /// [2] mom(type: DtFloat).
        /// </returns>
        public Operation RetrieveTPUEmbeddingRMSPropParameters(long num_shards, long shard_id, long table_id = -1, string table_name = null, string config = null, String opName = "RetrieveTPUEmbeddingRMSPropParameters") 
        {
            OperationDescription desc = NewOperation("RetrieveTPUEmbeddingRMSPropParameters", opName);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            if (table_id != -1)
                desc.SetAttr("table_id", table_id);
            if (table_name != null)
                 desc.SetAttr("table_name", table_name);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RetrieveTPUEmbeddingStochasticGradientDescentParameters
        /// </summary>
        /// <param name="num_shards">num shards</param>
        /// <param name="shard_id">shard id</param>
        /// <param name="table_id">table id</param>
        /// <param name="table_name">table name</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] parameters(type: DtFloat).
        /// </returns>
        public Operation RetrieveTPUEmbeddingStochasticGradientDescentParameters(long num_shards, long shard_id, long table_id = -1, string table_name = null, string config = null, String opName = "RetrieveTPUEmbeddingStochasticGradientDescentParameters") 
        {
            OperationDescription desc = NewOperation("RetrieveTPUEmbeddingStochasticGradientDescentParameters", opName);
            desc.SetAttr("num_shards", num_shards);
            desc.SetAttr("shard_id", shard_id);
            if (table_id != -1)
                desc.SetAttr("table_id", table_id);
            if (table_name != null)
                 desc.SetAttr("table_name", table_name);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Reverse
        /// </summary>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="dims">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Reverse(Output tensor, Output dims, String opName = "Reverse") 
        {
            OperationDescription desc = NewOperation("Reverse", opName);
            desc.AddInput(tensor);
            desc.AddInput(dims);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ReverseSequence
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="seq_lengths">Input to the operation. </param>
        /// <param name="seq_dim">seq dim</param>
        /// <param name="batch_dim">batch dim</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation ReverseSequence(Output input, Output seq_lengths, long seq_dim, long batch_dim = 0, String opName = "ReverseSequence") 
        {
            OperationDescription desc = NewOperation("ReverseSequence", opName);
            desc.AddInput(input);
            desc.AddInput(seq_lengths);
            desc.SetAttr("seq_dim", seq_dim);
            if (batch_dim != 0)
                desc.SetAttr("batch_dim", batch_dim);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ReverseV2
        /// </summary>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="axis">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation ReverseV2(Output tensor, Output axis, String opName = "ReverseV2") 
        {
            OperationDescription desc = NewOperation("ReverseV2", opName);
            desc.AddInput(tensor);
            desc.AddInput(axis);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RewriteDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="rewrite_name">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation RewriteDataset(Output input_dataset, Output rewrite_name, DataType[] output_types, long[][] output_shapes, String opName = "RewriteDataset") 
        {
            OperationDescription desc = NewOperation("RewriteDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(rewrite_name);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RFFT
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="fft_length">Input to the operation. </param>
        /// <param name="Tcomplex">Tcomplex</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RFFT(Output input, Output fft_length, DataType? Tcomplex = null, String opName = "RFFT") 
        {
            OperationDescription desc = NewOperation("RFFT", opName);
            desc.AddInput(input);
            desc.AddInput(fft_length);
            if (Tcomplex.HasValue)
                desc.SetAttr("Tcomplex", Tcomplex.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RFFT2D
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="fft_length">Input to the operation. </param>
        /// <param name="Tcomplex">Tcomplex</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RFFT2D(Output input, Output fft_length, DataType? Tcomplex = null, String opName = "RFFT2D") 
        {
            OperationDescription desc = NewOperation("RFFT2D", opName);
            desc.AddInput(input);
            desc.AddInput(fft_length);
            if (Tcomplex.HasValue)
                desc.SetAttr("Tcomplex", Tcomplex.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RFFT3D
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="fft_length">Input to the operation. </param>
        /// <param name="Tcomplex">Tcomplex</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RFFT3D(Output input, Output fft_length, DataType? Tcomplex = null, String opName = "RFFT3D") 
        {
            OperationDescription desc = NewOperation("RFFT3D", opName);
            desc.AddInput(input);
            desc.AddInput(fft_length);
            if (Tcomplex.HasValue)
                desc.SetAttr("Tcomplex", Tcomplex.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RFFTND
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="fft_length">Input to the operation. </param>
        /// <param name="axes">Input to the operation. </param>
        /// <param name="Tcomplex">Tcomplex</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RFFTND(Output input, Output fft_length, Output axes, DataType? Tcomplex = null, String opName = "RFFTND") 
        {
            OperationDescription desc = NewOperation("RFFTND", opName);
            desc.AddInput(input);
            desc.AddInput(fft_length);
            desc.AddInput(axes);
            if (Tcomplex.HasValue)
                desc.SetAttr("Tcomplex", Tcomplex.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RGBToHSV
        /// </summary>
        /// <param name="images">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RGBToHSV(Output images, String opName = "RGBToHSV") 
        {
            OperationDescription desc = NewOperation("RGBToHSV", opName);
            desc.AddInput(images);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RightShift
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation RightShift(Output x, Output y, String opName = "RightShift") 
        {
            OperationDescription desc = NewOperation("RightShift", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Rint
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Rint(Output x, String opName = "Rint") 
        {
            OperationDescription desc = NewOperation("Rint", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscAbs
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation RiscAbs(Output x, String opName = "RiscAbs") 
        {
            OperationDescription desc = NewOperation("RiscAbs", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscAdd
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation RiscAdd(Output x, Output y, String opName = "RiscAdd") 
        {
            OperationDescription desc = NewOperation("RiscAdd", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscBinaryArithmetic
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="op_type">op type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation RiscBinaryArithmetic(Output x, Output y, string op_type, String opName = "RiscBinaryArithmetic") 
        {
            OperationDescription desc = NewOperation("RiscBinaryArithmetic", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            desc.SetAttr("op_type", op_type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscBinaryComparison
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="op_type">op type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtBool).
        /// </returns>
        public Operation RiscBinaryComparison(Output x, Output y, string op_type, String opName = "RiscBinaryComparison") 
        {
            OperationDescription desc = NewOperation("RiscBinaryComparison", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            desc.SetAttr("op_type", op_type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscBitcast
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="DstT">DstT</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation RiscBitcast(Output x, DataType DstT, String opName = "RiscBitcast") 
        {
            OperationDescription desc = NewOperation("RiscBitcast", opName);
            desc.AddInput(x);
            desc.SetAttr("DstT", DstT);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscBroadcast
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RiscBroadcast(Output input, Output shape, String opName = "RiscBroadcast") 
        {
            OperationDescription desc = NewOperation("RiscBroadcast", opName);
            desc.AddInput(input);
            desc.AddInput(shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscCast
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="DstT">DstT</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation RiscCast(Output x, DataType DstT, String opName = "RiscCast") 
        {
            OperationDescription desc = NewOperation("RiscCast", opName);
            desc.AddInput(x);
            desc.SetAttr("DstT", DstT);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscCeil
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation RiscCeil(Output x, String opName = "RiscCeil") 
        {
            OperationDescription desc = NewOperation("RiscCeil", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscCholesky
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RiscCholesky(Output input, String opName = "RiscCholesky") 
        {
            OperationDescription desc = NewOperation("RiscCholesky", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscConcat
        /// </summary>
        /// <param name="values">Input to the operation. </param>
        /// <param name="axis">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RiscConcat(Output values, Output axis, String opName = "RiscConcat") 
        {
            OperationDescription desc = NewOperation("RiscConcat", opName);
            desc.AddInput(values);
            desc.AddInput(axis);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscCondition
        /// </summary>
        /// <param name="pred">Input to the operation. </param>
        /// <param name="input_true">Input to the operation. </param>
        /// <param name="input_false">Input to the operation. </param>
        /// <param name="DstT">DstT</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        // The following attributes are not known: func_true: func; func_false: func
        public Operation RiscCondition(Output pred, Output input_true, Output input_false, DataType DstT, String opName = "RiscCondition") 
        {
            OperationDescription desc = NewOperation("RiscCondition", opName);
            desc.AddInput(pred);
            desc.AddInput(input_true);
            desc.AddInput(input_false);
            desc.SetAttr("DstT", DstT);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscConv
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="filter">Input to the operation. </param>
        /// <param name="strides">strides</param>
        /// <param name="data_format">data format</param>
        /// <param name="dilations">dilations</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RiscConv(Output input, Output filter, long[] strides, string data_format = null, long[] dilations = null, String opName = "RiscConv") 
        {
            OperationDescription desc = NewOperation("RiscConv", opName);
            desc.AddInput(input);
            desc.AddInput(filter);
            desc.SetAttr("strides", strides);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            if (dilations != null) desc.SetAttr("dilations", dilations);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscCos
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation RiscCos(Output x, String opName = "RiscCos") 
        {
            OperationDescription desc = NewOperation("RiscCos", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscDiv
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation RiscDiv(Output x, Output y, String opName = "RiscDiv") 
        {
            OperationDescription desc = NewOperation("RiscDiv", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscDot
        /// </summary>
        /// <param name="a">Input to the operation. </param>
        /// <param name="b">Input to the operation. </param>
        /// <param name="transpose_a">transpose a</param>
        /// <param name="transpose_b">transpose b</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] product(type: DtInvalid).
        /// </returns>
        public Operation RiscDot(Output a, Output b, bool transpose_a = false, bool transpose_b = false, String opName = "RiscDot") 
        {
            OperationDescription desc = NewOperation("RiscDot", opName);
            desc.AddInput(a);
            desc.AddInput(b);
            if (transpose_a != false)
                desc.SetAttr("transpose_a", transpose_a);
            if (transpose_b != false)
                desc.SetAttr("transpose_b", transpose_b);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscExp
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation RiscExp(Output x, String opName = "RiscExp") 
        {
            OperationDescription desc = NewOperation("RiscExp", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscFft
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RiscFft(Output input, String opName = "RiscFft") 
        {
            OperationDescription desc = NewOperation("RiscFft", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscFloor
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation RiscFloor(Output x, String opName = "RiscFloor") 
        {
            OperationDescription desc = NewOperation("RiscFloor", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscGather
        /// </summary>
        /// <param name="parameters">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="axis">Input to the operation. </param>
        /// <param name="batch_dims">batch dims</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RiscGather(Output parameters, Output indices, Output axis, long batch_dims = 0, String opName = "RiscGather") 
        {
            OperationDescription desc = NewOperation("RiscGather", opName);
            desc.AddInput(parameters);
            desc.AddInput(indices);
            desc.AddInput(axis);
            if (batch_dims != 0)
                desc.SetAttr("batch_dims", batch_dims);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscImag
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="Tout">Tout</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RiscImag(Output input, DataType? Tout = null, String opName = "RiscImag") 
        {
            OperationDescription desc = NewOperation("RiscImag", opName);
            desc.AddInput(input);
            if (Tout.HasValue)
                desc.SetAttr("Tout", Tout.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscIsFinite
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtBool).
        /// </returns>
        public Operation RiscIsFinite(Output x, String opName = "RiscIsFinite") 
        {
            OperationDescription desc = NewOperation("RiscIsFinite", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscLog
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation RiscLog(Output x, String opName = "RiscLog") 
        {
            OperationDescription desc = NewOperation("RiscLog", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscLogicalAnd
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtBool).
        /// </returns>
        public Operation RiscLogicalAnd(Output x, Output y, String opName = "RiscLogicalAnd") 
        {
            OperationDescription desc = NewOperation("RiscLogicalAnd", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscLogicalNot
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtBool).
        /// </returns>
        public Operation RiscLogicalNot(Output x, String opName = "RiscLogicalNot") 
        {
            OperationDescription desc = NewOperation("RiscLogicalNot", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscLogicalOr
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtBool).
        /// </returns>
        public Operation RiscLogicalOr(Output x, Output y, String opName = "RiscLogicalOr") 
        {
            OperationDescription desc = NewOperation("RiscLogicalOr", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscMax
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] max(type: DtInvalid).
        /// </returns>
        public Operation RiscMax(Output x, Output y, String opName = "RiscMax") 
        {
            OperationDescription desc = NewOperation("RiscMax", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscMin
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation RiscMin(Output x, Output y, String opName = "RiscMin") 
        {
            OperationDescription desc = NewOperation("RiscMin", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscMul
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation RiscMul(Output x, Output y, String opName = "RiscMul") 
        {
            OperationDescription desc = NewOperation("RiscMul", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscNeg
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation RiscNeg(Output x, String opName = "RiscNeg") 
        {
            OperationDescription desc = NewOperation("RiscNeg", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscPad
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="paddings">Input to the operation. </param>
        /// <param name="constant_values">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RiscPad(Output input, Output paddings, Output constant_values, String opName = "RiscPad") 
        {
            OperationDescription desc = NewOperation("RiscPad", opName);
            desc.AddInput(input);
            desc.AddInput(paddings);
            desc.AddInput(constant_values);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscPool
        /// </summary>
        /// <param name="value">Input to the operation. </param>
        /// <param name="ksize">ksize</param>
        /// <param name="strides">strides</param>
        /// <param name="pooling_type">pooling type</param>
        /// <param name="data_format">data format</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RiscPool(Output value, long[] ksize, long[] strides, string pooling_type, string data_format = null, String opName = "RiscPool") 
        {
            OperationDescription desc = NewOperation("RiscPool", opName);
            desc.AddInput(value);
            desc.SetAttr("ksize", ksize);
            desc.SetAttr("strides", strides);
            desc.SetAttr("pooling_type", pooling_type);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscPow
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation RiscPow(Output x, Output y, String opName = "RiscPow") 
        {
            OperationDescription desc = NewOperation("RiscPow", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscRandomUniform
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="seed">seed</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtFloat).
        /// </returns>
        public Operation RiscRandomUniform(Output shape, long seed = 0, String opName = "RiscRandomUniform") 
        {
            OperationDescription desc = NewOperation("RiscRandomUniform", opName);
            desc.AddInput(shape);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscReal
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="Tout">Tout</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RiscReal(Output input, DataType? Tout = null, String opName = "RiscReal") 
        {
            OperationDescription desc = NewOperation("RiscReal", opName);
            desc.AddInput(input);
            if (Tout.HasValue)
                desc.SetAttr("Tout", Tout.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscReduce
        /// </summary>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="axis">Input to the operation. </param>
        /// <param name="reduce_type">reduce type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RiscReduce(Output tensor, Output axis, string reduce_type, String opName = "RiscReduce") 
        {
            OperationDescription desc = NewOperation("RiscReduce", opName);
            desc.AddInput(tensor);
            desc.AddInput(axis);
            desc.SetAttr("reduce_type", reduce_type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscRem
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation RiscRem(Output x, Output y, String opName = "RiscRem") 
        {
            OperationDescription desc = NewOperation("RiscRem", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscReshape
        /// </summary>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RiscReshape(Output tensor, Output shape, String opName = "RiscReshape") 
        {
            OperationDescription desc = NewOperation("RiscReshape", opName);
            desc.AddInput(tensor);
            desc.AddInput(shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscReverse
        /// </summary>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="axis">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RiscReverse(Output tensor, Output axis, String opName = "RiscReverse") 
        {
            OperationDescription desc = NewOperation("RiscReverse", opName);
            desc.AddInput(tensor);
            desc.AddInput(axis);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscScatter
        /// </summary>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RiscScatter(Output indices, Output updates, Output shape, String opName = "RiscScatter") 
        {
            OperationDescription desc = NewOperation("RiscScatter", opName);
            desc.AddInput(indices);
            desc.AddInput(updates);
            desc.AddInput(shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscShape
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="out_type">out type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RiscShape(Output input, DataType? out_type = null, String opName = "RiscShape") 
        {
            OperationDescription desc = NewOperation("RiscShape", opName);
            desc.AddInput(input);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscSign
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation RiscSign(Output x, String opName = "RiscSign") 
        {
            OperationDescription desc = NewOperation("RiscSign", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscSlice
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="begin">Input to the operation. </param>
        /// <param name="size">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RiscSlice(Output input, Output begin, Output size, String opName = "RiscSlice") 
        {
            OperationDescription desc = NewOperation("RiscSlice", opName);
            desc.AddInput(input);
            desc.AddInput(begin);
            desc.AddInput(size);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscSort
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="axis">Input to the operation. </param>
        /// <param name="direction">direction</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RiscSort(Output input, Output axis, string direction, String opName = "RiscSort") 
        {
            OperationDescription desc = NewOperation("RiscSort", opName);
            desc.AddInput(input);
            desc.AddInput(axis);
            desc.SetAttr("direction", direction);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscSqueeze
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="squeeze_dims">squeeze dims</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RiscSqueeze(Output input, long[] squeeze_dims = null, String opName = "RiscSqueeze") 
        {
            OperationDescription desc = NewOperation("RiscSqueeze", opName);
            desc.AddInput(input);
            if (squeeze_dims != null) desc.SetAttr("squeeze_dims", squeeze_dims);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscSub
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation RiscSub(Output x, Output y, String opName = "RiscSub") 
        {
            OperationDescription desc = NewOperation("RiscSub", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscTranspose
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="perm">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation RiscTranspose(Output x, Output perm, String opName = "RiscTranspose") 
        {
            OperationDescription desc = NewOperation("RiscTranspose", opName);
            desc.AddInput(x);
            desc.AddInput(perm);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscTriangularSolve
        /// </summary>
        /// <param name="matrix">Input to the operation. </param>
        /// <param name="rhs">Input to the operation. </param>
        /// <param name="lower">lower</param>
        /// <param name="adjoint">adjoint</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation RiscTriangularSolve(Output matrix, Output rhs, bool lower = true, bool adjoint = false, String opName = "RiscTriangularSolve") 
        {
            OperationDescription desc = NewOperation("RiscTriangularSolve", opName);
            desc.AddInput(matrix);
            desc.AddInput(rhs);
            if (lower != true)
                desc.SetAttr("lower", lower);
            if (adjoint != false)
                desc.SetAttr("adjoint", adjoint);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscUnary
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="op_type">op type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation RiscUnary(Output x, string op_type, String opName = "RiscUnary") 
        {
            OperationDescription desc = NewOperation("RiscUnary", opName);
            desc.AddInput(x);
            desc.SetAttr("op_type", op_type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RiscWhile
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="parallel_iterations">parallel iterations</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        // The following attributes are not known: cond: func; body: func
        public Operation RiscWhile(Output input, long[][] output_shapes = null, long parallel_iterations = 10, String opName = "RiscWhile") 
        {
            OperationDescription desc = NewOperation("RiscWhile", opName);
            desc.AddInput(input);
            if (output_shapes != null) desc.SetAttrShapeList("output_shapes", output_shapes);
            if (parallel_iterations != 10)
                desc.SetAttr("parallel_iterations", parallel_iterations);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RngReadAndSkip
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="alg">Input to the operation. </param>
        /// <param name="delta">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] value(type: DtInt64).
        /// </returns>
        public Operation RngReadAndSkip(Output resource, Output alg, Output delta, String opName = "RngReadAndSkip") 
        {
            OperationDescription desc = NewOperation("RngReadAndSkip", opName);
            desc.AddInput(resource);
            desc.AddInput(alg);
            desc.AddInput(delta);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RngSkip
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="algorithm">Input to the operation. </param>
        /// <param name="delta">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation RngSkip(Output resource, Output algorithm, Output delta, String opName = "RngSkip") 
        {
            OperationDescription desc = NewOperation("RngSkip", opName);
            desc.AddInput(resource);
            desc.AddInput(algorithm);
            desc.AddInput(delta);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Roll
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="shift">Input to the operation. </param>
        /// <param name="axis">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Roll(Output input, Output shift, Output axis, String opName = "Roll") 
        {
            OperationDescription desc = NewOperation("Roll", opName);
            desc.AddInput(input);
            desc.AddInput(shift);
            desc.AddInput(axis);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Round
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Round(Output x, String opName = "Round") 
        {
            OperationDescription desc = NewOperation("Round", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Rsqrt
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Rsqrt(Output x, String opName = "Rsqrt") 
        {
            OperationDescription desc = NewOperation("Rsqrt", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// RsqrtGrad
        /// </summary>
        /// <param name="y">Input to the operation. </param>
        /// <param name="dy">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation RsqrtGrad(Output y, Output dy, String opName = "RsqrtGrad") 
        {
            OperationDescription desc = NewOperation("RsqrtGrad", opName);
            desc.AddInput(y);
            desc.AddInput(dy);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SampleDistortedBoundingBox
        /// </summary>
        /// <param name="image_size">Input to the operation. </param>
        /// <param name="bounding_boxes">Input to the operation. </param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="min_object_covered">min object covered</param>
        /// <param name="aspect_ratio_range">aspect ratio range</param>
        /// <param name="area_range">area range</param>
        /// <param name="max_attempts">max attempts</param>
        /// <param name="use_image_if_no_bounding_boxes">use image if no bounding boxes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] begin(type: DtInvalid).
        /// [1] size(type: DtInvalid).
        /// [2] bboxes(type: DtFloat).
        /// </returns>
        public Operation SampleDistortedBoundingBox(Output image_size, Output bounding_boxes, long seed = 0, long seed2 = 0, float min_object_covered = 0.1f, float[] aspect_ratio_range = null, float[] area_range = null, long max_attempts = 100, bool use_image_if_no_bounding_boxes = false, String opName = "SampleDistortedBoundingBox") 
        {
            OperationDescription desc = NewOperation("SampleDistortedBoundingBox", opName);
            desc.AddInput(image_size);
            desc.AddInput(bounding_boxes);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            if (min_object_covered != 0.1f)
                desc.SetAttr("min_object_covered", min_object_covered);
            if (aspect_ratio_range != null) desc.SetAttr("aspect_ratio_range", aspect_ratio_range);
            if (area_range != null) desc.SetAttr("area_range", area_range);
            if (max_attempts != 100)
                desc.SetAttr("max_attempts", max_attempts);
            if (use_image_if_no_bounding_boxes != false)
                desc.SetAttr("use_image_if_no_bounding_boxes", use_image_if_no_bounding_boxes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SampleDistortedBoundingBoxV2
        /// </summary>
        /// <param name="image_size">Input to the operation. </param>
        /// <param name="bounding_boxes">Input to the operation. </param>
        /// <param name="min_object_covered">Input to the operation. </param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="aspect_ratio_range">aspect ratio range</param>
        /// <param name="area_range">area range</param>
        /// <param name="max_attempts">max attempts</param>
        /// <param name="use_image_if_no_bounding_boxes">use image if no bounding boxes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] begin(type: DtInvalid).
        /// [1] size(type: DtInvalid).
        /// [2] bboxes(type: DtFloat).
        /// </returns>
        public Operation SampleDistortedBoundingBoxV2(Output image_size, Output bounding_boxes, Output min_object_covered, long seed = 0, long seed2 = 0, float[] aspect_ratio_range = null, float[] area_range = null, long max_attempts = 100, bool use_image_if_no_bounding_boxes = false, String opName = "SampleDistortedBoundingBoxV2") 
        {
            OperationDescription desc = NewOperation("SampleDistortedBoundingBoxV2", opName);
            desc.AddInput(image_size);
            desc.AddInput(bounding_boxes);
            desc.AddInput(min_object_covered);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            if (aspect_ratio_range != null) desc.SetAttr("aspect_ratio_range", aspect_ratio_range);
            if (area_range != null) desc.SetAttr("area_range", area_range);
            if (max_attempts != 100)
                desc.SetAttr("max_attempts", max_attempts);
            if (use_image_if_no_bounding_boxes != false)
                desc.SetAttr("use_image_if_no_bounding_boxes", use_image_if_no_bounding_boxes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SamplingDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="rate">Input to the operation. </param>
        /// <param name="seed">Input to the operation. </param>
        /// <param name="seed2">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation SamplingDataset(Output input_dataset, Output rate, Output seed, Output seed2, DataType[] output_types, long[][] output_shapes, String opName = "SamplingDataset") 
        {
            OperationDescription desc = NewOperation("SamplingDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(rate);
            desc.AddInput(seed);
            desc.AddInput(seed2);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Save
        /// </summary>
        /// <param name="filename">Input to the operation. </param>
        /// <param name="tensor_names">Input to the operation. </param>
        /// <param name="data">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation Save(Output filename, Output tensor_names, Output data, String opName = "Save") 
        {
            OperationDescription desc = NewOperation("Save", opName);
            desc.AddInput(filename);
            desc.AddInput(tensor_names);
            desc.AddInput(data);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SaveDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="path">Input to the operation. </param>
        /// <param name="shard_func_other_args">Input to the operation. </param>
        /// <param name="compression">compression</param>
        /// <param name="use_shard_func">use shard func</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        // The following attributes are not known: shard_func: func
        public Operation SaveDataset(Output input_dataset, Output path, Output shard_func_other_args, string compression = null, bool use_shard_func = true, String opName = "SaveDataset") 
        {
            OperationDescription desc = NewOperation("SaveDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(path);
            desc.AddInput(shard_func_other_args);
            if (compression != null)
                 desc.SetAttr("compression", compression);
            if (use_shard_func != true)
                desc.SetAttr("use_shard_func", use_shard_func);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SaveDatasetV2
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="path">Input to the operation. </param>
        /// <param name="shard_func_other_args">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="compression">compression</param>
        /// <param name="use_shard_func">use shard func</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: shard_func: func
        public Operation SaveDatasetV2(Output input_dataset, Output path, Output shard_func_other_args, DataType[] output_types, long[][] output_shapes, string compression = null, bool use_shard_func = true, String opName = "SaveDatasetV2") 
        {
            OperationDescription desc = NewOperation("SaveDatasetV2", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(path);
            desc.AddInput(shard_func_other_args);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (compression != null)
                 desc.SetAttr("compression", compression);
            if (use_shard_func != true)
                desc.SetAttr("use_shard_func", use_shard_func);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SaveSlices
        /// </summary>
        /// <param name="filename">Input to the operation. </param>
        /// <param name="tensor_names">Input to the operation. </param>
        /// <param name="shapes_and_slices">Input to the operation. </param>
        /// <param name="data">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation SaveSlices(Output filename, Output tensor_names, Output shapes_and_slices, Output data, String opName = "SaveSlices") 
        {
            OperationDescription desc = NewOperation("SaveSlices", opName);
            desc.AddInput(filename);
            desc.AddInput(tensor_names);
            desc.AddInput(shapes_and_slices);
            desc.AddInput(data);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SaveV2
        /// </summary>
        /// <param name="prefix">Input to the operation. </param>
        /// <param name="tensor_names">Input to the operation. </param>
        /// <param name="shape_and_slices">Input to the operation. </param>
        /// <param name="tensors">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation SaveV2(Output prefix, Output tensor_names, Output shape_and_slices, Output tensors, String opName = "SaveV2") 
        {
            OperationDescription desc = NewOperation("SaveV2", opName);
            desc.AddInput(prefix);
            desc.AddInput(tensor_names);
            desc.AddInput(shape_and_slices);
            desc.AddInput(tensors);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ScalarSummary
        /// </summary>
        /// <param name="tags">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] summary(type: DtString).
        /// </returns>
        public Operation ScalarSummary(Output tags, Output values, String opName = "ScalarSummary") 
        {
            OperationDescription desc = NewOperation("ScalarSummary", opName);
            desc.AddInput(tags);
            desc.AddInput(values);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ScaleAndTranslate
        /// </summary>
        /// <param name="images">Input to the operation. </param>
        /// <param name="size">Input to the operation. </param>
        /// <param name="scale">Input to the operation. </param>
        /// <param name="translation">Input to the operation. </param>
        /// <param name="kernel_type">kernel type</param>
        /// <param name="antialias">antialias</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] resized_images(type: DtFloat).
        /// </returns>
        public Operation ScaleAndTranslate(Output images, Output size, Output scale, Output translation, string kernel_type = null, bool antialias = true, String opName = "ScaleAndTranslate") 
        {
            OperationDescription desc = NewOperation("ScaleAndTranslate", opName);
            desc.AddInput(images);
            desc.AddInput(size);
            desc.AddInput(scale);
            desc.AddInput(translation);
            if (kernel_type != null)
                 desc.SetAttr("kernel_type", kernel_type);
            if (antialias != true)
                desc.SetAttr("antialias", antialias);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ScaleAndTranslateGrad
        /// </summary>
        /// <param name="grads">Input to the operation. </param>
        /// <param name="original_image">Input to the operation. </param>
        /// <param name="scale">Input to the operation. </param>
        /// <param name="translation">Input to the operation. </param>
        /// <param name="kernel_type">kernel type</param>
        /// <param name="antialias">antialias</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation ScaleAndTranslateGrad(Output grads, Output original_image, Output scale, Output translation, string kernel_type = null, bool antialias = true, String opName = "ScaleAndTranslateGrad") 
        {
            OperationDescription desc = NewOperation("ScaleAndTranslateGrad", opName);
            desc.AddInput(grads);
            desc.AddInput(original_image);
            desc.AddInput(scale);
            desc.AddInput(translation);
            if (kernel_type != null)
                 desc.SetAttr("kernel_type", kernel_type);
            if (antialias != true)
                desc.SetAttr("antialias", antialias);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ScanDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="initial_state">Input to the operation. </param>
        /// <param name="other_arguments">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="preserve_cardinality">preserve cardinality</param>
        /// <param name="use_default_device">use default device</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: f: func
        public Operation ScanDataset(Output input_dataset, Output initial_state, Output other_arguments, DataType[] output_types, long[][] output_shapes, bool preserve_cardinality = false, bool use_default_device = true, string metadata = null, String opName = "ScanDataset") 
        {
            OperationDescription desc = NewOperation("ScanDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(initial_state);
            desc.AddInput(other_arguments);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (preserve_cardinality != false)
                desc.SetAttr("preserve_cardinality", preserve_cardinality);
            if (use_default_device != true)
                desc.SetAttr("use_default_device", use_default_device);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ScatterAdd
        /// </summary>
        /// <param name="reference">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_ref(type: DtInvalid).
        /// </returns>
        public Operation ScatterAdd(Output reference, Output indices, Output updates, bool use_locking = false, String opName = "ScatterAdd") 
        {
            OperationDescription desc = NewOperation("ScatterAdd", opName);
            desc.AddInput(reference);
            desc.AddInput(indices);
            desc.AddInput(updates);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ScatterDiv
        /// </summary>
        /// <param name="reference">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_ref(type: DtInvalid).
        /// </returns>
        public Operation ScatterDiv(Output reference, Output indices, Output updates, bool use_locking = false, String opName = "ScatterDiv") 
        {
            OperationDescription desc = NewOperation("ScatterDiv", opName);
            desc.AddInput(reference);
            desc.AddInput(indices);
            desc.AddInput(updates);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ScatterMax
        /// </summary>
        /// <param name="reference">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_ref(type: DtInvalid).
        /// </returns>
        public Operation ScatterMax(Output reference, Output indices, Output updates, bool use_locking = false, String opName = "ScatterMax") 
        {
            OperationDescription desc = NewOperation("ScatterMax", opName);
            desc.AddInput(reference);
            desc.AddInput(indices);
            desc.AddInput(updates);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ScatterMin
        /// </summary>
        /// <param name="reference">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_ref(type: DtInvalid).
        /// </returns>
        public Operation ScatterMin(Output reference, Output indices, Output updates, bool use_locking = false, String opName = "ScatterMin") 
        {
            OperationDescription desc = NewOperation("ScatterMin", opName);
            desc.AddInput(reference);
            desc.AddInput(indices);
            desc.AddInput(updates);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ScatterMul
        /// </summary>
        /// <param name="reference">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_ref(type: DtInvalid).
        /// </returns>
        public Operation ScatterMul(Output reference, Output indices, Output updates, bool use_locking = false, String opName = "ScatterMul") 
        {
            OperationDescription desc = NewOperation("ScatterMul", opName);
            desc.AddInput(reference);
            desc.AddInput(indices);
            desc.AddInput(updates);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ScatterNd
        /// </summary>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation ScatterNd(Output indices, Output updates, Output shape, String opName = "ScatterNd") 
        {
            OperationDescription desc = NewOperation("ScatterNd", opName);
            desc.AddInput(indices);
            desc.AddInput(updates);
            desc.AddInput(shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ScatterNdAdd
        /// </summary>
        /// <param name="reference">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_ref(type: DtInvalid).
        /// </returns>
        public Operation ScatterNdAdd(Output reference, Output indices, Output updates, bool use_locking = false, String opName = "ScatterNdAdd") 
        {
            OperationDescription desc = NewOperation("ScatterNdAdd", opName);
            desc.AddInput(reference);
            desc.AddInput(indices);
            desc.AddInput(updates);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ScatterNdMax
        /// </summary>
        /// <param name="reference">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_ref(type: DtInvalid).
        /// </returns>
        public Operation ScatterNdMax(Output reference, Output indices, Output updates, bool use_locking = false, String opName = "ScatterNdMax") 
        {
            OperationDescription desc = NewOperation("ScatterNdMax", opName);
            desc.AddInput(reference);
            desc.AddInput(indices);
            desc.AddInput(updates);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ScatterNdMin
        /// </summary>
        /// <param name="reference">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_ref(type: DtInvalid).
        /// </returns>
        public Operation ScatterNdMin(Output reference, Output indices, Output updates, bool use_locking = false, String opName = "ScatterNdMin") 
        {
            OperationDescription desc = NewOperation("ScatterNdMin", opName);
            desc.AddInput(reference);
            desc.AddInput(indices);
            desc.AddInput(updates);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ScatterNdNonAliasingAdd
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation ScatterNdNonAliasingAdd(Output input, Output indices, Output updates, String opName = "ScatterNdNonAliasingAdd") 
        {
            OperationDescription desc = NewOperation("ScatterNdNonAliasingAdd", opName);
            desc.AddInput(input);
            desc.AddInput(indices);
            desc.AddInput(updates);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ScatterNdSub
        /// </summary>
        /// <param name="reference">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_ref(type: DtInvalid).
        /// </returns>
        public Operation ScatterNdSub(Output reference, Output indices, Output updates, bool use_locking = false, String opName = "ScatterNdSub") 
        {
            OperationDescription desc = NewOperation("ScatterNdSub", opName);
            desc.AddInput(reference);
            desc.AddInput(indices);
            desc.AddInput(updates);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ScatterNdUpdate
        /// </summary>
        /// <param name="reference">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_ref(type: DtInvalid).
        /// </returns>
        public Operation ScatterNdUpdate(Output reference, Output indices, Output updates, bool use_locking = true, String opName = "ScatterNdUpdate") 
        {
            OperationDescription desc = NewOperation("ScatterNdUpdate", opName);
            desc.AddInput(reference);
            desc.AddInput(indices);
            desc.AddInput(updates);
            if (use_locking != true)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ScatterSub
        /// </summary>
        /// <param name="reference">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_ref(type: DtInvalid).
        /// </returns>
        public Operation ScatterSub(Output reference, Output indices, Output updates, bool use_locking = false, String opName = "ScatterSub") 
        {
            OperationDescription desc = NewOperation("ScatterSub", opName);
            desc.AddInput(reference);
            desc.AddInput(indices);
            desc.AddInput(updates);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ScatterUpdate
        /// </summary>
        /// <param name="reference">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_ref(type: DtInvalid).
        /// </returns>
        public Operation ScatterUpdate(Output reference, Output indices, Output updates, bool use_locking = true, String opName = "ScatterUpdate") 
        {
            OperationDescription desc = NewOperation("ScatterUpdate", opName);
            desc.AddInput(reference);
            desc.AddInput(indices);
            desc.AddInput(updates);
            if (use_locking != true)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SdcaFprint
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInt64).
        /// </returns>
        public Operation SdcaFprint(Output input, String opName = "SdcaFprint") 
        {
            OperationDescription desc = NewOperation("SdcaFprint", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SdcaOptimizer
        /// </summary>
        /// <param name="sparse_example_indices">Input to the operation. </param>
        /// <param name="sparse_feature_indices">Input to the operation. </param>
        /// <param name="sparse_feature_values">Input to the operation. </param>
        /// <param name="dense_features">Input to the operation. </param>
        /// <param name="example_weights">Input to the operation. </param>
        /// <param name="example_labels">Input to the operation. </param>
        /// <param name="sparse_indices">Input to the operation. </param>
        /// <param name="sparse_weights">Input to the operation. </param>
        /// <param name="dense_weights">Input to the operation. </param>
        /// <param name="example_state_data">Input to the operation. </param>
        /// <param name="loss_type">loss type</param>
        /// <param name="l1">l1</param>
        /// <param name="l2">l2</param>
        /// <param name="num_loss_partitions">num loss partitions</param>
        /// <param name="num_inner_iterations">num inner iterations</param>
        /// <param name="adaptative">adaptative</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out_example_state_data(type: DtFloat).
        /// [1] out_delta_sparse_weights(type: DtFloat).
        /// [2] out_delta_dense_weights(type: DtFloat).
        /// </returns>
        public Operation SdcaOptimizer(Output sparse_example_indices, Output sparse_feature_indices, Output sparse_feature_values, Output dense_features, Output example_weights, Output example_labels, Output sparse_indices, Output sparse_weights, Output dense_weights, Output example_state_data, string loss_type, float l1, float l2, long num_loss_partitions, long num_inner_iterations, bool adaptative = false, String opName = "SdcaOptimizer") 
        {
            OperationDescription desc = NewOperation("SdcaOptimizer", opName);
            desc.AddInput(sparse_example_indices);
            desc.AddInput(sparse_feature_indices);
            desc.AddInput(sparse_feature_values);
            desc.AddInput(dense_features);
            desc.AddInput(example_weights);
            desc.AddInput(example_labels);
            desc.AddInput(sparse_indices);
            desc.AddInput(sparse_weights);
            desc.AddInput(dense_weights);
            desc.AddInput(example_state_data);
            desc.SetAttr("loss_type", loss_type);
            desc.SetAttr("l1", l1);
            desc.SetAttr("l2", l2);
            desc.SetAttr("num_loss_partitions", num_loss_partitions);
            desc.SetAttr("num_inner_iterations", num_inner_iterations);
            if (adaptative != false)
                desc.SetAttr("adaptative", adaptative);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SdcaOptimizerV2
        /// </summary>
        /// <param name="sparse_example_indices">Input to the operation. </param>
        /// <param name="sparse_feature_indices">Input to the operation. </param>
        /// <param name="sparse_feature_values">Input to the operation. </param>
        /// <param name="dense_features">Input to the operation. </param>
        /// <param name="example_weights">Input to the operation. </param>
        /// <param name="example_labels">Input to the operation. </param>
        /// <param name="sparse_indices">Input to the operation. </param>
        /// <param name="sparse_weights">Input to the operation. </param>
        /// <param name="dense_weights">Input to the operation. </param>
        /// <param name="example_state_data">Input to the operation. </param>
        /// <param name="loss_type">loss type</param>
        /// <param name="l1">l1</param>
        /// <param name="l2">l2</param>
        /// <param name="num_loss_partitions">num loss partitions</param>
        /// <param name="num_inner_iterations">num inner iterations</param>
        /// <param name="adaptive">adaptive</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out_example_state_data(type: DtFloat).
        /// [1] out_delta_sparse_weights(type: DtFloat).
        /// [2] out_delta_dense_weights(type: DtFloat).
        /// </returns>
        public Operation SdcaOptimizerV2(Output sparse_example_indices, Output sparse_feature_indices, Output sparse_feature_values, Output dense_features, Output example_weights, Output example_labels, Output sparse_indices, Output sparse_weights, Output dense_weights, Output example_state_data, string loss_type, float l1, float l2, long num_loss_partitions, long num_inner_iterations, bool adaptive = false, String opName = "SdcaOptimizerV2") 
        {
            OperationDescription desc = NewOperation("SdcaOptimizerV2", opName);
            desc.AddInput(sparse_example_indices);
            desc.AddInput(sparse_feature_indices);
            desc.AddInput(sparse_feature_values);
            desc.AddInput(dense_features);
            desc.AddInput(example_weights);
            desc.AddInput(example_labels);
            desc.AddInput(sparse_indices);
            desc.AddInput(sparse_weights);
            desc.AddInput(dense_weights);
            desc.AddInput(example_state_data);
            desc.SetAttr("loss_type", loss_type);
            desc.SetAttr("l1", l1);
            desc.SetAttr("l2", l2);
            desc.SetAttr("num_loss_partitions", num_loss_partitions);
            desc.SetAttr("num_inner_iterations", num_inner_iterations);
            if (adaptive != false)
                desc.SetAttr("adaptive", adaptive);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SdcaShrinkL1
        /// </summary>
        /// <param name="weights">Input to the operation. </param>
        /// <param name="l1">l1</param>
        /// <param name="l2">l2</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation SdcaShrinkL1(Output weights, float l1, float l2, String opName = "SdcaShrinkL1") 
        {
            OperationDescription desc = NewOperation("SdcaShrinkL1", opName);
            desc.AddInput(weights);
            desc.SetAttr("l1", l1);
            desc.SetAttr("l2", l2);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SegmentMax
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="segment_ids">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SegmentMax(Output data, Output segment_ids, String opName = "SegmentMax") 
        {
            OperationDescription desc = NewOperation("SegmentMax", opName);
            desc.AddInput(data);
            desc.AddInput(segment_ids);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SegmentMaxV2
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="segment_ids">Input to the operation. </param>
        /// <param name="num_segments">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SegmentMaxV2(Output data, Output segment_ids, Output num_segments, String opName = "SegmentMaxV2") 
        {
            OperationDescription desc = NewOperation("SegmentMaxV2", opName);
            desc.AddInput(data);
            desc.AddInput(segment_ids);
            desc.AddInput(num_segments);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SegmentMean
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="segment_ids">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SegmentMean(Output data, Output segment_ids, String opName = "SegmentMean") 
        {
            OperationDescription desc = NewOperation("SegmentMean", opName);
            desc.AddInput(data);
            desc.AddInput(segment_ids);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SegmentMin
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="segment_ids">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SegmentMin(Output data, Output segment_ids, String opName = "SegmentMin") 
        {
            OperationDescription desc = NewOperation("SegmentMin", opName);
            desc.AddInput(data);
            desc.AddInput(segment_ids);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SegmentMinV2
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="segment_ids">Input to the operation. </param>
        /// <param name="num_segments">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SegmentMinV2(Output data, Output segment_ids, Output num_segments, String opName = "SegmentMinV2") 
        {
            OperationDescription desc = NewOperation("SegmentMinV2", opName);
            desc.AddInput(data);
            desc.AddInput(segment_ids);
            desc.AddInput(num_segments);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SegmentProd
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="segment_ids">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SegmentProd(Output data, Output segment_ids, String opName = "SegmentProd") 
        {
            OperationDescription desc = NewOperation("SegmentProd", opName);
            desc.AddInput(data);
            desc.AddInput(segment_ids);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SegmentProdV2
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="segment_ids">Input to the operation. </param>
        /// <param name="num_segments">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SegmentProdV2(Output data, Output segment_ids, Output num_segments, String opName = "SegmentProdV2") 
        {
            OperationDescription desc = NewOperation("SegmentProdV2", opName);
            desc.AddInput(data);
            desc.AddInput(segment_ids);
            desc.AddInput(num_segments);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SegmentSum
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="segment_ids">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SegmentSum(Output data, Output segment_ids, String opName = "SegmentSum") 
        {
            OperationDescription desc = NewOperation("SegmentSum", opName);
            desc.AddInput(data);
            desc.AddInput(segment_ids);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SegmentSumV2
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="segment_ids">Input to the operation. </param>
        /// <param name="num_segments">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SegmentSumV2(Output data, Output segment_ids, Output num_segments, String opName = "SegmentSumV2") 
        {
            OperationDescription desc = NewOperation("SegmentSumV2", opName);
            desc.AddInput(data);
            desc.AddInput(segment_ids);
            desc.AddInput(num_segments);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Select
        /// </summary>
        /// <param name="condition">Input to the operation. </param>
        /// <param name="t">Input to the operation. </param>
        /// <param name="e">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Select(Output condition, Output t, Output e, String opName = "Select") 
        {
            OperationDescription desc = NewOperation("Select", opName);
            desc.AddInput(condition);
            desc.AddInput(t);
            desc.AddInput(e);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SelectV2
        /// </summary>
        /// <param name="condition">Input to the operation. </param>
        /// <param name="t">Input to the operation. </param>
        /// <param name="e">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SelectV2(Output condition, Output t, Output e, String opName = "SelectV2") 
        {
            OperationDescription desc = NewOperation("SelectV2", opName);
            desc.AddInput(condition);
            desc.AddInput(t);
            desc.AddInput(e);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SelfAdjointEig
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SelfAdjointEig(Output input, String opName = "SelfAdjointEig") 
        {
            OperationDescription desc = NewOperation("SelfAdjointEig", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SelfAdjointEigV2
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="compute_v">compute v</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] e(type: DtInvalid).
        /// [1] v(type: DtInvalid).
        /// </returns>
        public Operation SelfAdjointEigV2(Output input, bool compute_v = true, String opName = "SelfAdjointEigV2") 
        {
            OperationDescription desc = NewOperation("SelfAdjointEigV2", opName);
            desc.AddInput(input);
            if (compute_v != true)
                desc.SetAttr("compute_v", compute_v);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Selu
        /// </summary>
        /// <param name="features">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] activations(type: DtInvalid).
        /// </returns>
        public Operation Selu(Output features, String opName = "Selu") 
        {
            OperationDescription desc = NewOperation("Selu", opName);
            desc.AddInput(features);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SeluGrad
        /// </summary>
        /// <param name="gradients">Input to the operation. </param>
        /// <param name="outputs">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] backprops(type: DtInvalid).
        /// </returns>
        public Operation SeluGrad(Output gradients, Output outputs, String opName = "SeluGrad") 
        {
            OperationDescription desc = NewOperation("SeluGrad", opName);
            desc.AddInput(gradients);
            desc.AddInput(outputs);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Send
        /// </summary>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="tensor_name">tensor name</param>
        /// <param name="send_device">send device</param>
        /// <param name="send_device_incarnation">send device incarnation</param>
        /// <param name="recv_device">recv device</param>
        /// <param name="client_terminated">client terminated</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation Send(Output tensor, string tensor_name, string send_device, long send_device_incarnation, string recv_device, bool client_terminated = false, String opName = "Send") 
        {
            OperationDescription desc = NewOperation("Send", opName);
            desc.AddInput(tensor);
            desc.SetAttr("tensor_name", tensor_name);
            desc.SetAttr("send_device", send_device);
            desc.SetAttr("send_device_incarnation", send_device_incarnation);
            desc.SetAttr("recv_device", recv_device);
            if (client_terminated != false)
                desc.SetAttr("client_terminated", client_terminated);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SendTPUEmbeddingGradients
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="learning_rates">Input to the operation. </param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation SendTPUEmbeddingGradients(Output inputs, Output learning_rates, string config, String opName = "SendTPUEmbeddingGradients") 
        {
            OperationDescription desc = NewOperation("SendTPUEmbeddingGradients", opName);
            desc.AddInput(inputs);
            desc.AddInput(learning_rates);
            desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SerializeIterator
        /// </summary>
        /// <param name="resource_handle">Input to the operation. </param>
        /// <param name="external_state_policy">external state policy</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] serialized(type: DtVariant).
        /// </returns>
        public Operation SerializeIterator(Output resource_handle, long external_state_policy = 0, String opName = "SerializeIterator") 
        {
            OperationDescription desc = NewOperation("SerializeIterator", opName);
            desc.AddInput(resource_handle);
            if (external_state_policy != 0)
                desc.SetAttr("external_state_policy", external_state_policy);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SerializeManySparse
        /// </summary>
        /// <param name="sparse_indices">Input to the operation. </param>
        /// <param name="sparse_values">Input to the operation. </param>
        /// <param name="sparse_shape">Input to the operation. </param>
        /// <param name="out_type">out type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] serialized_sparse(type: DtInvalid).
        /// </returns>
        public Operation SerializeManySparse(Output sparse_indices, Output sparse_values, Output sparse_shape, DataType? out_type = null, String opName = "SerializeManySparse") 
        {
            OperationDescription desc = NewOperation("SerializeManySparse", opName);
            desc.AddInput(sparse_indices);
            desc.AddInput(sparse_values);
            desc.AddInput(sparse_shape);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SerializeSparse
        /// </summary>
        /// <param name="sparse_indices">Input to the operation. </param>
        /// <param name="sparse_values">Input to the operation. </param>
        /// <param name="sparse_shape">Input to the operation. </param>
        /// <param name="out_type">out type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] serialized_sparse(type: DtInvalid).
        /// </returns>
        public Operation SerializeSparse(Output sparse_indices, Output sparse_values, Output sparse_shape, DataType? out_type = null, String opName = "SerializeSparse") 
        {
            OperationDescription desc = NewOperation("SerializeSparse", opName);
            desc.AddInput(sparse_indices);
            desc.AddInput(sparse_values);
            desc.AddInput(sparse_shape);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SerializeTensor
        /// </summary>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] serialized(type: DtString).
        /// </returns>
        public Operation SerializeTensor(Output tensor, String opName = "SerializeTensor") 
        {
            OperationDescription desc = NewOperation("SerializeTensor", opName);
            desc.AddInput(tensor);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SetSize
        /// </summary>
        /// <param name="set_indices">Input to the operation. </param>
        /// <param name="set_values">Input to the operation. </param>
        /// <param name="set_shape">Input to the operation. </param>
        /// <param name="validate_indices">validate indices</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] size(type: DtInt32).
        /// </returns>
        public Operation SetSize(Output set_indices, Output set_values, Output set_shape, bool validate_indices = true, String opName = "SetSize") 
        {
            OperationDescription desc = NewOperation("SetSize", opName);
            desc.AddInput(set_indices);
            desc.AddInput(set_values);
            desc.AddInput(set_shape);
            if (validate_indices != true)
                desc.SetAttr("validate_indices", validate_indices);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SetStatsAggregatorDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="stats_aggregator">Input to the operation. </param>
        /// <param name="tag">Input to the operation. </param>
        /// <param name="counter_prefix">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation SetStatsAggregatorDataset(Output input_dataset, Output stats_aggregator, Output tag, Output counter_prefix, DataType[] output_types, long[][] output_shapes, String opName = "SetStatsAggregatorDataset") 
        {
            OperationDescription desc = NewOperation("SetStatsAggregatorDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(stats_aggregator);
            desc.AddInput(tag);
            desc.AddInput(counter_prefix);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Shape
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="out_type">out type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Shape(Output input, DataType? out_type = null, String opName = "Shape") 
        {
            OperationDescription desc = NewOperation("Shape", opName);
            desc.AddInput(input);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ShapeN
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="out_type">out type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation ShapeN(Output input, DataType? out_type = null, String opName = "ShapeN") 
        {
            OperationDescription desc = NewOperation("ShapeN", opName);
            desc.AddInput(input);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ShardDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="num_shards">Input to the operation. </param>
        /// <param name="index">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="require_non_empty">require non empty</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ShardDataset(Output input_dataset, Output num_shards, Output index, DataType[] output_types, long[][] output_shapes, bool require_non_empty = false, string metadata = null, String opName = "ShardDataset") 
        {
            OperationDescription desc = NewOperation("ShardDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(num_shards);
            desc.AddInput(index);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (require_non_empty != false)
                desc.SetAttr("require_non_empty", require_non_empty);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ShardedFilename
        /// </summary>
        /// <param name="basename">Input to the operation. </param>
        /// <param name="shard">Input to the operation. </param>
        /// <param name="num_shards">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] filename(type: DtString).
        /// </returns>
        public Operation ShardedFilename(Output basename, Output shard, Output num_shards, String opName = "ShardedFilename") 
        {
            OperationDescription desc = NewOperation("ShardedFilename", opName);
            desc.AddInput(basename);
            desc.AddInput(shard);
            desc.AddInput(num_shards);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ShardedFilespec
        /// </summary>
        /// <param name="basename">Input to the operation. </param>
        /// <param name="num_shards">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] filename(type: DtString).
        /// </returns>
        public Operation ShardedFilespec(Output basename, Output num_shards, String opName = "ShardedFilespec") 
        {
            OperationDescription desc = NewOperation("ShardedFilespec", opName);
            desc.AddInput(basename);
            desc.AddInput(num_shards);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ShuffleAndRepeatDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="buffer_size">Input to the operation. </param>
        /// <param name="seed">Input to the operation. </param>
        /// <param name="seed2">Input to the operation. </param>
        /// <param name="count">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="reshuffle_each_iteration">reshuffle each iteration</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ShuffleAndRepeatDataset(Output input_dataset, Output buffer_size, Output seed, Output seed2, Output count, DataType[] output_types, long[][] output_shapes, bool reshuffle_each_iteration = true, string metadata = null, String opName = "ShuffleAndRepeatDataset") 
        {
            OperationDescription desc = NewOperation("ShuffleAndRepeatDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(buffer_size);
            desc.AddInput(seed);
            desc.AddInput(seed2);
            desc.AddInput(count);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (reshuffle_each_iteration != true)
                desc.SetAttr("reshuffle_each_iteration", reshuffle_each_iteration);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ShuffleAndRepeatDatasetV2
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="buffer_size">Input to the operation. </param>
        /// <param name="seed">Input to the operation. </param>
        /// <param name="seed2">Input to the operation. </param>
        /// <param name="count">Input to the operation. </param>
        /// <param name="seed_generator">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="reshuffle_each_iteration">reshuffle each iteration</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ShuffleAndRepeatDatasetV2(Output input_dataset, Output buffer_size, Output seed, Output seed2, Output count, Output seed_generator, DataType[] output_types, long[][] output_shapes, bool reshuffle_each_iteration = true, string metadata = null, String opName = "ShuffleAndRepeatDatasetV2") 
        {
            OperationDescription desc = NewOperation("ShuffleAndRepeatDatasetV2", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(buffer_size);
            desc.AddInput(seed);
            desc.AddInput(seed2);
            desc.AddInput(count);
            desc.AddInput(seed_generator);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (reshuffle_each_iteration != true)
                desc.SetAttr("reshuffle_each_iteration", reshuffle_each_iteration);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ShuffleDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="buffer_size">Input to the operation. </param>
        /// <param name="seed">Input to the operation. </param>
        /// <param name="seed2">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="reshuffle_each_iteration">reshuffle each iteration</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ShuffleDataset(Output input_dataset, Output buffer_size, Output seed, Output seed2, DataType[] output_types, long[][] output_shapes, bool reshuffle_each_iteration = true, string metadata = null, String opName = "ShuffleDataset") 
        {
            OperationDescription desc = NewOperation("ShuffleDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(buffer_size);
            desc.AddInput(seed);
            desc.AddInput(seed2);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (reshuffle_each_iteration != true)
                desc.SetAttr("reshuffle_each_iteration", reshuffle_each_iteration);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ShuffleDatasetV2
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="buffer_size">Input to the operation. </param>
        /// <param name="seed_generator">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ShuffleDatasetV2(Output input_dataset, Output buffer_size, Output seed_generator, DataType[] output_types, long[][] output_shapes, string metadata = null, String opName = "ShuffleDatasetV2") 
        {
            OperationDescription desc = NewOperation("ShuffleDatasetV2", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(buffer_size);
            desc.AddInput(seed_generator);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ShuffleDatasetV3
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="buffer_size">Input to the operation. </param>
        /// <param name="seed">Input to the operation. </param>
        /// <param name="seed2">Input to the operation. </param>
        /// <param name="seed_generator">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="reshuffle_each_iteration">reshuffle each iteration</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ShuffleDatasetV3(Output input_dataset, Output buffer_size, Output seed, Output seed2, Output seed_generator, DataType[] output_types, long[][] output_shapes, bool reshuffle_each_iteration = true, string metadata = null, String opName = "ShuffleDatasetV3") 
        {
            OperationDescription desc = NewOperation("ShuffleDatasetV3", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(buffer_size);
            desc.AddInput(seed);
            desc.AddInput(seed2);
            desc.AddInput(seed_generator);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (reshuffle_each_iteration != true)
                desc.SetAttr("reshuffle_each_iteration", reshuffle_each_iteration);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ShutdownDistributedTPU
        /// </summary>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation ShutdownDistributedTPU(String opName = "ShutdownDistributedTPU") 
        {
            OperationDescription desc = NewOperation("ShutdownDistributedTPU", opName);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ShutdownTPUSystem
        /// </summary>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] success(type: DtBool).
        /// </returns>
        public Operation ShutdownTPUSystem(String opName = "ShutdownTPUSystem") 
        {
            OperationDescription desc = NewOperation("ShutdownTPUSystem", opName);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Sigmoid
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Sigmoid(Output x, String opName = "Sigmoid") 
        {
            OperationDescription desc = NewOperation("Sigmoid", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SigmoidGrad
        /// </summary>
        /// <param name="y">Input to the operation. </param>
        /// <param name="dy">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation SigmoidGrad(Output y, Output dy, String opName = "SigmoidGrad") 
        {
            OperationDescription desc = NewOperation("SigmoidGrad", opName);
            desc.AddInput(y);
            desc.AddInput(dy);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Sign
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Sign(Output x, String opName = "Sign") 
        {
            OperationDescription desc = NewOperation("Sign", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Sin
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Sin(Output x, String opName = "Sin") 
        {
            OperationDescription desc = NewOperation("Sin", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Sinh
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Sinh(Output x, String opName = "Sinh") 
        {
            OperationDescription desc = NewOperation("Sinh", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Size
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="out_type">out type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Size(Output input, DataType? out_type = null, String opName = "Size") 
        {
            OperationDescription desc = NewOperation("Size", opName);
            desc.AddInput(input);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SkipDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="count">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation SkipDataset(Output input_dataset, Output count, DataType[] output_types, long[][] output_shapes, string metadata = null, String opName = "SkipDataset") 
        {
            OperationDescription desc = NewOperation("SkipDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(count);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Skipgram
        /// </summary>
        /// <param name="filename">filename</param>
        /// <param name="batch_size">batch size</param>
        /// <param name="window_size">window size</param>
        /// <param name="min_count">min count</param>
        /// <param name="subsample">subsample</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] vocab_word(type: DtString).
        /// [1] vocab_freq(type: DtInt32).
        /// [2] words_per_epoch(type: DtInt64).
        /// [3] current_epoch(type: DtInt32).
        /// [4] total_words_processed(type: DtInt64).
        /// [5] examples(type: DtInt32).
        /// [6] labels(type: DtInt32).
        /// </returns>
        public Operation Skipgram(string filename, long batch_size, long window_size = 5, long min_count = 5, float subsample = 0.001f, String opName = "Skipgram") 
        {
            OperationDescription desc = NewOperation("Skipgram", opName);
            desc.SetAttr("filename", filename);
            desc.SetAttr("batch_size", batch_size);
            if (window_size != 5)
                desc.SetAttr("window_size", window_size);
            if (min_count != 5)
                desc.SetAttr("min_count", min_count);
            if (subsample != 0.001f)
                desc.SetAttr("subsample", subsample);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SleepDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="sleep_microseconds">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation SleepDataset(Output input_dataset, Output sleep_microseconds, DataType[] output_types, long[][] output_shapes, String opName = "SleepDataset") 
        {
            OperationDescription desc = NewOperation("SleepDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(sleep_microseconds);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Slice
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="begin">Input to the operation. </param>
        /// <param name="size">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Slice(Output input, Output begin, Output size, String opName = "Slice") 
        {
            OperationDescription desc = NewOperation("Slice", opName);
            desc.AddInput(input);
            desc.AddInput(begin);
            desc.AddInput(size);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SlidingWindowDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="window_size">Input to the operation. </param>
        /// <param name="window_shift">Input to the operation. </param>
        /// <param name="window_stride">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="drop_remainder">drop remainder</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation SlidingWindowDataset(Output input_dataset, Output window_size, Output window_shift, Output window_stride, DataType[] output_types, long[][] output_shapes, bool drop_remainder = true, String opName = "SlidingWindowDataset") 
        {
            OperationDescription desc = NewOperation("SlidingWindowDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(window_size);
            desc.AddInput(window_shift);
            desc.AddInput(window_stride);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (drop_remainder != true)
                desc.SetAttr("drop_remainder", drop_remainder);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Snapshot
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Snapshot(Output input, String opName = "Snapshot") 
        {
            OperationDescription desc = NewOperation("Snapshot", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SnapshotChunkDataset
        /// </summary>
        /// <param name="chunk_file">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="compression">compression</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation SnapshotChunkDataset(Output chunk_file, DataType[] output_types, long[][] output_shapes, string compression = null, String opName = "SnapshotChunkDataset") 
        {
            OperationDescription desc = NewOperation("SnapshotChunkDataset", opName);
            desc.AddInput(chunk_file);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (compression != null)
                 desc.SetAttr("compression", compression);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SnapshotDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="path">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="compression">compression</param>
        /// <param name="reader_path_prefix">reader path prefix</param>
        /// <param name="writer_path_prefix">writer path prefix</param>
        /// <param name="shard_size_bytes">shard size bytes</param>
        /// <param name="pending_snapshot_expiry_seconds">pending snapshot expiry seconds</param>
        /// <param name="num_reader_threads">num reader threads</param>
        /// <param name="reader_buffer_size">reader buffer size</param>
        /// <param name="num_writer_threads">num writer threads</param>
        /// <param name="writer_buffer_size">writer buffer size</param>
        /// <param name="shuffle_on_read">shuffle on read</param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="mode">mode</param>
        /// <param name="snapshot_name">snapshot name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation SnapshotDataset(Output input_dataset, Output path, DataType[] output_types, long[][] output_shapes, string compression = null, string reader_path_prefix = null, string writer_path_prefix = null, long shard_size_bytes = 10737418240, long pending_snapshot_expiry_seconds = 86400, long num_reader_threads = 1, long reader_buffer_size = 1, long num_writer_threads = 1, long writer_buffer_size = 1, bool shuffle_on_read = false, long seed = 0, long seed2 = 0, string mode = null, string snapshot_name = null, String opName = "SnapshotDataset") 
        {
            OperationDescription desc = NewOperation("SnapshotDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(path);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (compression != null)
                 desc.SetAttr("compression", compression);
            if (reader_path_prefix != null)
                 desc.SetAttr("reader_path_prefix", reader_path_prefix);
            if (writer_path_prefix != null)
                 desc.SetAttr("writer_path_prefix", writer_path_prefix);
            if (shard_size_bytes != 10737418240)
                desc.SetAttr("shard_size_bytes", shard_size_bytes);
            if (pending_snapshot_expiry_seconds != 86400)
                desc.SetAttr("pending_snapshot_expiry_seconds", pending_snapshot_expiry_seconds);
            if (num_reader_threads != 1)
                desc.SetAttr("num_reader_threads", num_reader_threads);
            if (reader_buffer_size != 1)
                desc.SetAttr("reader_buffer_size", reader_buffer_size);
            if (num_writer_threads != 1)
                desc.SetAttr("num_writer_threads", num_writer_threads);
            if (writer_buffer_size != 1)
                desc.SetAttr("writer_buffer_size", writer_buffer_size);
            if (shuffle_on_read != false)
                desc.SetAttr("shuffle_on_read", shuffle_on_read);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            if (mode != null)
                 desc.SetAttr("mode", mode);
            if (snapshot_name != null)
                 desc.SetAttr("snapshot_name", snapshot_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SnapshotDatasetReader
        /// </summary>
        /// <param name="shard_dir">Input to the operation. </param>
        /// <param name="start_index">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="version">version</param>
        /// <param name="compression">compression</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation SnapshotDatasetReader(Output shard_dir, Output start_index, DataType[] output_types, long[][] output_shapes, long version, string compression = null, String opName = "SnapshotDatasetReader") 
        {
            OperationDescription desc = NewOperation("SnapshotDatasetReader", opName);
            desc.AddInput(shard_dir);
            desc.AddInput(start_index);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            desc.SetAttr("version", version);
            if (compression != null)
                 desc.SetAttr("compression", compression);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SnapshotDatasetV2
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="path">Input to the operation. </param>
        /// <param name="reader_func_other_args">Input to the operation. </param>
        /// <param name="shard_func_other_args">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="compression">compression</param>
        /// <param name="reader_prefix">reader prefix</param>
        /// <param name="writer_prefix">writer prefix</param>
        /// <param name="hash_valid">hash valid</param>
        /// <param name="hash">hash</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: reader_func: func; shard_func: func
        public Operation SnapshotDatasetV2(Output input_dataset, Output path, Output reader_func_other_args, Output shard_func_other_args, DataType[] output_types, long[][] output_shapes, string compression = null, string reader_prefix = null, string writer_prefix = null, bool hash_valid = false, long hash = 0, string metadata = null, String opName = "SnapshotDatasetV2") 
        {
            OperationDescription desc = NewOperation("SnapshotDatasetV2", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(path);
            desc.AddInput(reader_func_other_args);
            desc.AddInput(shard_func_other_args);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (compression != null)
                 desc.SetAttr("compression", compression);
            if (reader_prefix != null)
                 desc.SetAttr("reader_prefix", reader_prefix);
            if (writer_prefix != null)
                 desc.SetAttr("writer_prefix", writer_prefix);
            if (hash_valid != false)
                desc.SetAttr("hash_valid", hash_valid);
            if (hash != 0)
                desc.SetAttr("hash", hash);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SnapshotNestedDatasetReader
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation SnapshotNestedDatasetReader(Output inputs, DataType[] output_types, long[][] output_shapes, String opName = "SnapshotNestedDatasetReader") 
        {
            OperationDescription desc = NewOperation("SnapshotNestedDatasetReader", opName);
            desc.AddInput(inputs);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SobolSample
        /// </summary>
        /// <param name="dim">Input to the operation. </param>
        /// <param name="num_results">Input to the operation. </param>
        /// <param name="skip">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] samples(type: DtInvalid).
        /// </returns>
        public Operation SobolSample(Output dim, Output num_results, Output skip, DataType? dtype = null, String opName = "SobolSample") 
        {
            OperationDescription desc = NewOperation("SobolSample", opName);
            desc.AddInput(dim);
            desc.AddInput(num_results);
            desc.AddInput(skip);
            if (dtype.HasValue)
                desc.SetAttr("dtype", dtype.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Softmax
        /// </summary>
        /// <param name="logits">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] softmax(type: DtInvalid).
        /// </returns>
        public Operation Softmax(Output logits, String opName = "Softmax") 
        {
            OperationDescription desc = NewOperation("Softmax", opName);
            desc.AddInput(logits);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SoftmaxCrossEntropyWithLogits
        /// </summary>
        /// <param name="features">Input to the operation. </param>
        /// <param name="labels">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] loss(type: DtInvalid).
        /// [1] backprop(type: DtInvalid).
        /// </returns>
        public Operation SoftmaxCrossEntropyWithLogits(Output features, Output labels, String opName = "SoftmaxCrossEntropyWithLogits") 
        {
            OperationDescription desc = NewOperation("SoftmaxCrossEntropyWithLogits", opName);
            desc.AddInput(features);
            desc.AddInput(labels);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Softplus
        /// </summary>
        /// <param name="features">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] activations(type: DtInvalid).
        /// </returns>
        public Operation Softplus(Output features, String opName = "Softplus") 
        {
            OperationDescription desc = NewOperation("Softplus", opName);
            desc.AddInput(features);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SoftplusGrad
        /// </summary>
        /// <param name="gradients">Input to the operation. </param>
        /// <param name="features">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] backprops(type: DtInvalid).
        /// </returns>
        public Operation SoftplusGrad(Output gradients, Output features, String opName = "SoftplusGrad") 
        {
            OperationDescription desc = NewOperation("SoftplusGrad", opName);
            desc.AddInput(gradients);
            desc.AddInput(features);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Softsign
        /// </summary>
        /// <param name="features">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] activations(type: DtInvalid).
        /// </returns>
        public Operation Softsign(Output features, String opName = "Softsign") 
        {
            OperationDescription desc = NewOperation("Softsign", opName);
            desc.AddInput(features);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SoftsignGrad
        /// </summary>
        /// <param name="gradients">Input to the operation. </param>
        /// <param name="features">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] backprops(type: DtInvalid).
        /// </returns>
        public Operation SoftsignGrad(Output gradients, Output features, String opName = "SoftsignGrad") 
        {
            OperationDescription desc = NewOperation("SoftsignGrad", opName);
            desc.AddInput(gradients);
            desc.AddInput(features);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SortListOfSparseCoreCooTensors
        /// </summary>
        /// <param name="row_ids_list">Input to the operation. </param>
        /// <param name="col_ids_list">Input to the operation. </param>
        /// <param name="gains_list">Input to the operation. </param>
        /// <param name="sample_count_list">sample count list</param>
        /// <param name="col_offset_list">col offset list</param>
        /// <param name="num_replica">num replica</param>
        /// <param name="table_vocab_size">table vocab size</param>
        /// <param name="feature_width">feature width</param>
        /// <param name="num_sc_per_chip">num sc per chip</param>
        /// <param name="max_ids_per_sparse_core">max ids per sparse core</param>
        /// <param name="max_unique_ids_per_sparse_core">max unique ids per sparse core</param>
        /// <param name="table_name">table name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] sorted_row_ids(type: DtInt32).
        /// [1] sorted_col_ids(type: DtInt32).
        /// [2] sorted_gains(type: DtFloat).
        /// [3] id_counts(type: DtInt32).
        /// </returns>
        public Operation SortListOfSparseCoreCooTensors(Output row_ids_list, Output col_ids_list, Output gains_list, long[] sample_count_list, long[] col_offset_list, long num_replica, long table_vocab_size, long feature_width, long num_sc_per_chip, long max_ids_per_sparse_core, long max_unique_ids_per_sparse_core, string table_name, String opName = "SortListOfSparseCoreCooTensors") 
        {
            OperationDescription desc = NewOperation("SortListOfSparseCoreCooTensors", opName);
            desc.AddInput(row_ids_list);
            desc.AddInput(col_ids_list);
            desc.AddInput(gains_list);
            desc.SetAttr("sample_count_list", sample_count_list);
            desc.SetAttr("col_offset_list", col_offset_list);
            desc.SetAttr("num_replica", num_replica);
            desc.SetAttr("table_vocab_size", table_vocab_size);
            desc.SetAttr("feature_width", feature_width);
            desc.SetAttr("num_sc_per_chip", num_sc_per_chip);
            desc.SetAttr("max_ids_per_sparse_core", max_ids_per_sparse_core);
            desc.SetAttr("max_unique_ids_per_sparse_core", max_unique_ids_per_sparse_core);
            desc.SetAttr("table_name", table_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SpaceToBatch
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="paddings">Input to the operation. </param>
        /// <param name="block_size">block size</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SpaceToBatch(Output input, Output paddings, long block_size, String opName = "SpaceToBatch") 
        {
            OperationDescription desc = NewOperation("SpaceToBatch", opName);
            desc.AddInput(input);
            desc.AddInput(paddings);
            desc.SetAttr("block_size", block_size);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SpaceToBatchND
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="block_shape">Input to the operation. </param>
        /// <param name="paddings">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SpaceToBatchND(Output input, Output block_shape, Output paddings, String opName = "SpaceToBatchND") 
        {
            OperationDescription desc = NewOperation("SpaceToBatchND", opName);
            desc.AddInput(input);
            desc.AddInput(block_shape);
            desc.AddInput(paddings);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SpaceToDepth
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="block_size">block size</param>
        /// <param name="data_format">data format</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SpaceToDepth(Output input, long block_size, string data_format = null, String opName = "SpaceToDepth") 
        {
            OperationDescription desc = NewOperation("SpaceToDepth", opName);
            desc.AddInput(input);
            desc.SetAttr("block_size", block_size);
            if (data_format != null)
                 desc.SetAttr("data_format", data_format);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseAccumulatorApplyGradient
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="local_step">Input to the operation. </param>
        /// <param name="gradient_indices">Input to the operation. </param>
        /// <param name="gradient_values">Input to the operation. </param>
        /// <param name="gradient_shape">Input to the operation. </param>
        /// <param name="has_known_shape">has known shape</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation SparseAccumulatorApplyGradient(Output handle, Output local_step, Output gradient_indices, Output gradient_values, Output gradient_shape, bool has_known_shape, String opName = "SparseAccumulatorApplyGradient") 
        {
            OperationDescription desc = NewOperation("SparseAccumulatorApplyGradient", opName);
            desc.AddInput(handle);
            desc.AddInput(local_step);
            desc.AddInput(gradient_indices);
            desc.AddInput(gradient_values);
            desc.AddInput(gradient_shape);
            desc.SetAttr("has_known_shape", has_known_shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseAccumulatorTakeGradient
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="num_required">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] indices(type: DtInt64).
        /// [1] values(type: DtInvalid).
        /// [2] shape(type: DtInt64).
        /// </returns>
        public Operation SparseAccumulatorTakeGradient(Output handle, Output num_required, DataType dtype, String opName = "SparseAccumulatorTakeGradient") 
        {
            OperationDescription desc = NewOperation("SparseAccumulatorTakeGradient", opName);
            desc.AddInput(handle);
            desc.AddInput(num_required);
            desc.SetAttr("dtype", dtype);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseAdd
        /// </summary>
        /// <param name="a_indices">Input to the operation. </param>
        /// <param name="a_values">Input to the operation. </param>
        /// <param name="a_shape">Input to the operation. </param>
        /// <param name="b_indices">Input to the operation. </param>
        /// <param name="b_values">Input to the operation. </param>
        /// <param name="b_shape">Input to the operation. </param>
        /// <param name="thresh">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] sum_indices(type: DtInt64).
        /// [1] sum_values(type: DtInvalid).
        /// [2] sum_shape(type: DtInt64).
        /// </returns>
        public Operation SparseAdd(Output a_indices, Output a_values, Output a_shape, Output b_indices, Output b_values, Output b_shape, Output thresh, String opName = "SparseAdd") 
        {
            OperationDescription desc = NewOperation("SparseAdd", opName);
            desc.AddInput(a_indices);
            desc.AddInput(a_values);
            desc.AddInput(a_shape);
            desc.AddInput(b_indices);
            desc.AddInput(b_values);
            desc.AddInput(b_shape);
            desc.AddInput(thresh);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseAddGrad
        /// </summary>
        /// <param name="backprop_val_grad">Input to the operation. </param>
        /// <param name="a_indices">Input to the operation. </param>
        /// <param name="b_indices">Input to the operation. </param>
        /// <param name="sum_indices">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] a_val_grad(type: DtInvalid).
        /// [1] b_val_grad(type: DtInvalid).
        /// </returns>
        public Operation SparseAddGrad(Output backprop_val_grad, Output a_indices, Output b_indices, Output sum_indices, String opName = "SparseAddGrad") 
        {
            OperationDescription desc = NewOperation("SparseAddGrad", opName);
            desc.AddInput(backprop_val_grad);
            desc.AddInput(a_indices);
            desc.AddInput(b_indices);
            desc.AddInput(sum_indices);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseApplyAdadelta
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="accum_update">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="rho">Input to the operation. </param>
        /// <param name="epsilon">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation SparseApplyAdadelta(Output var, Output accum, Output accum_update, Output lr, Output rho, Output epsilon, Output grad, Output indices, bool use_locking = false, String opName = "SparseApplyAdadelta") 
        {
            OperationDescription desc = NewOperation("SparseApplyAdadelta", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(accum_update);
            desc.AddInput(lr);
            desc.AddInput(rho);
            desc.AddInput(epsilon);
            desc.AddInput(grad);
            desc.AddInput(indices);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseApplyAdagrad
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="update_slots">update slots</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation SparseApplyAdagrad(Output var, Output accum, Output lr, Output grad, Output indices, bool use_locking = false, bool update_slots = true, String opName = "SparseApplyAdagrad") 
        {
            OperationDescription desc = NewOperation("SparseApplyAdagrad", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(lr);
            desc.AddInput(grad);
            desc.AddInput(indices);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            if (update_slots != true)
                desc.SetAttr("update_slots", update_slots);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseApplyAdagradDA
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="gradient_accumulator">Input to the operation. </param>
        /// <param name="gradient_squared_accumulator">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="l1">Input to the operation. </param>
        /// <param name="l2">Input to the operation. </param>
        /// <param name="global_step">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation SparseApplyAdagradDA(Output var, Output gradient_accumulator, Output gradient_squared_accumulator, Output grad, Output indices, Output lr, Output l1, Output l2, Output global_step, bool use_locking = false, String opName = "SparseApplyAdagradDA") 
        {
            OperationDescription desc = NewOperation("SparseApplyAdagradDA", opName);
            desc.AddInput(var);
            desc.AddInput(gradient_accumulator);
            desc.AddInput(gradient_squared_accumulator);
            desc.AddInput(grad);
            desc.AddInput(indices);
            desc.AddInput(lr);
            desc.AddInput(l1);
            desc.AddInput(l2);
            desc.AddInput(global_step);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseApplyAdagradV2
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="epsilon">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="update_slots">update slots</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation SparseApplyAdagradV2(Output var, Output accum, Output lr, Output epsilon, Output grad, Output indices, bool use_locking = false, bool update_slots = true, String opName = "SparseApplyAdagradV2") 
        {
            OperationDescription desc = NewOperation("SparseApplyAdagradV2", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(lr);
            desc.AddInput(epsilon);
            desc.AddInput(grad);
            desc.AddInput(indices);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            if (update_slots != true)
                desc.SetAttr("update_slots", update_slots);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseApplyCenteredRMSProp
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="mg">Input to the operation. </param>
        /// <param name="ms">Input to the operation. </param>
        /// <param name="mom">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="rho">Input to the operation. </param>
        /// <param name="momentum">Input to the operation. </param>
        /// <param name="epsilon">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation SparseApplyCenteredRMSProp(Output var, Output mg, Output ms, Output mom, Output lr, Output rho, Output momentum, Output epsilon, Output grad, Output indices, bool use_locking = false, String opName = "SparseApplyCenteredRMSProp") 
        {
            OperationDescription desc = NewOperation("SparseApplyCenteredRMSProp", opName);
            desc.AddInput(var);
            desc.AddInput(mg);
            desc.AddInput(ms);
            desc.AddInput(mom);
            desc.AddInput(lr);
            desc.AddInput(rho);
            desc.AddInput(momentum);
            desc.AddInput(epsilon);
            desc.AddInput(grad);
            desc.AddInput(indices);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseApplyFtrl
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="linear">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="l1">Input to the operation. </param>
        /// <param name="l2">Input to the operation. </param>
        /// <param name="lr_power">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="multiply_linear_by_lr">multiply linear by lr</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation SparseApplyFtrl(Output var, Output accum, Output linear, Output grad, Output indices, Output lr, Output l1, Output l2, Output lr_power, bool use_locking = false, bool multiply_linear_by_lr = false, String opName = "SparseApplyFtrl") 
        {
            OperationDescription desc = NewOperation("SparseApplyFtrl", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(linear);
            desc.AddInput(grad);
            desc.AddInput(indices);
            desc.AddInput(lr);
            desc.AddInput(l1);
            desc.AddInput(l2);
            desc.AddInput(lr_power);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            if (multiply_linear_by_lr != false)
                desc.SetAttr("multiply_linear_by_lr", multiply_linear_by_lr);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseApplyFtrlV2
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="linear">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="l1">Input to the operation. </param>
        /// <param name="l2">Input to the operation. </param>
        /// <param name="l2_shrinkage">Input to the operation. </param>
        /// <param name="lr_power">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="multiply_linear_by_lr">multiply linear by lr</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation SparseApplyFtrlV2(Output var, Output accum, Output linear, Output grad, Output indices, Output lr, Output l1, Output l2, Output l2_shrinkage, Output lr_power, bool use_locking = false, bool multiply_linear_by_lr = false, String opName = "SparseApplyFtrlV2") 
        {
            OperationDescription desc = NewOperation("SparseApplyFtrlV2", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(linear);
            desc.AddInput(grad);
            desc.AddInput(indices);
            desc.AddInput(lr);
            desc.AddInput(l1);
            desc.AddInput(l2);
            desc.AddInput(l2_shrinkage);
            desc.AddInput(lr_power);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            if (multiply_linear_by_lr != false)
                desc.SetAttr("multiply_linear_by_lr", multiply_linear_by_lr);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseApplyMomentum
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="momentum">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="use_nesterov">use nesterov</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation SparseApplyMomentum(Output var, Output accum, Output lr, Output grad, Output indices, Output momentum, bool use_locking = false, bool use_nesterov = false, String opName = "SparseApplyMomentum") 
        {
            OperationDescription desc = NewOperation("SparseApplyMomentum", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(lr);
            desc.AddInput(grad);
            desc.AddInput(indices);
            desc.AddInput(momentum);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            if (use_nesterov != false)
                desc.SetAttr("use_nesterov", use_nesterov);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseApplyProximalAdagrad
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="accum">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="l1">Input to the operation. </param>
        /// <param name="l2">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation SparseApplyProximalAdagrad(Output var, Output accum, Output lr, Output l1, Output l2, Output grad, Output indices, bool use_locking = false, String opName = "SparseApplyProximalAdagrad") 
        {
            OperationDescription desc = NewOperation("SparseApplyProximalAdagrad", opName);
            desc.AddInput(var);
            desc.AddInput(accum);
            desc.AddInput(lr);
            desc.AddInput(l1);
            desc.AddInput(l2);
            desc.AddInput(grad);
            desc.AddInput(indices);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseApplyProximalGradientDescent
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="alpha">Input to the operation. </param>
        /// <param name="l1">Input to the operation. </param>
        /// <param name="l2">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation SparseApplyProximalGradientDescent(Output var, Output alpha, Output l1, Output l2, Output grad, Output indices, bool use_locking = false, String opName = "SparseApplyProximalGradientDescent") 
        {
            OperationDescription desc = NewOperation("SparseApplyProximalGradientDescent", opName);
            desc.AddInput(var);
            desc.AddInput(alpha);
            desc.AddInput(l1);
            desc.AddInput(l2);
            desc.AddInput(grad);
            desc.AddInput(indices);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseApplyRMSProp
        /// </summary>
        /// <param name="var">Input to the operation. </param>
        /// <param name="ms">Input to the operation. </param>
        /// <param name="mom">Input to the operation. </param>
        /// <param name="lr">Input to the operation. </param>
        /// <param name="rho">Input to the operation. </param>
        /// <param name="momentum">Input to the operation. </param>
        /// <param name="epsilon">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="use_locking">use locking</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] out(type: DtInvalid).
        /// </returns>
        public Operation SparseApplyRMSProp(Output var, Output ms, Output mom, Output lr, Output rho, Output momentum, Output epsilon, Output grad, Output indices, bool use_locking = false, String opName = "SparseApplyRMSProp") 
        {
            OperationDescription desc = NewOperation("SparseApplyRMSProp", opName);
            desc.AddInput(var);
            desc.AddInput(ms);
            desc.AddInput(mom);
            desc.AddInput(lr);
            desc.AddInput(rho);
            desc.AddInput(momentum);
            desc.AddInput(epsilon);
            desc.AddInput(grad);
            desc.AddInput(indices);
            if (use_locking != false)
                desc.SetAttr("use_locking", use_locking);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseBincount
        /// </summary>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="dense_shape">Input to the operation. </param>
        /// <param name="size">Input to the operation. </param>
        /// <param name="weights">Input to the operation. </param>
        /// <param name="binary_output">binary output</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SparseBincount(Output indices, Output values, Output dense_shape, Output size, Output weights, bool binary_output = false, String opName = "SparseBincount") 
        {
            OperationDescription desc = NewOperation("SparseBincount", opName);
            desc.AddInput(indices);
            desc.AddInput(values);
            desc.AddInput(dense_shape);
            desc.AddInput(size);
            desc.AddInput(weights);
            if (binary_output != false)
                desc.SetAttr("binary_output", binary_output);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseConcat
        /// </summary>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="shapes">Input to the operation. </param>
        /// <param name="concat_dim">concat dim</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_indices(type: DtInt64).
        /// [1] output_values(type: DtInvalid).
        /// [2] output_shape(type: DtInt64).
        /// </returns>
        public Operation SparseConcat(Output indices, Output values, Output shapes, long concat_dim, String opName = "SparseConcat") 
        {
            OperationDescription desc = NewOperation("SparseConcat", opName);
            desc.AddInput(indices);
            desc.AddInput(values);
            desc.AddInput(shapes);
            desc.SetAttr("concat_dim", concat_dim);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseConditionalAccumulator
        /// </summary>
        /// <param name="dtype">dtype</param>
        /// <param name="shape">shape</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="reduction_type">reduction type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtString).
        /// </returns>
        public Operation SparseConditionalAccumulator(DataType dtype, long[] shape, string container = null, string shared_name = null, string reduction_type = null, String opName = "SparseConditionalAccumulator") 
        {
            OperationDescription desc = NewOperation("SparseConditionalAccumulator", opName);
            desc.SetAttr("dtype", dtype);
            desc.SetAttrShape("shape", shape);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            if (reduction_type != null)
                 desc.SetAttr("reduction_type", reduction_type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseCountSparseOutput
        /// </summary>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="dense_shape">Input to the operation. </param>
        /// <param name="weights">Input to the operation. </param>
        /// <param name="binary_output">binary output</param>
        /// <param name="minlength">minlength</param>
        /// <param name="maxlength">maxlength</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_indices(type: DtInt64).
        /// [1] output_values(type: DtInvalid).
        /// [2] output_dense_shape(type: DtInt64).
        /// </returns>
        public Operation SparseCountSparseOutput(Output indices, Output values, Output dense_shape, Output weights, bool binary_output, long minlength = -1, long maxlength = -1, String opName = "SparseCountSparseOutput") 
        {
            OperationDescription desc = NewOperation("SparseCountSparseOutput", opName);
            desc.AddInput(indices);
            desc.AddInput(values);
            desc.AddInput(dense_shape);
            desc.AddInput(weights);
            desc.SetAttr("binary_output", binary_output);
            if (minlength != -1)
                desc.SetAttr("minlength", minlength);
            if (maxlength != -1)
                desc.SetAttr("maxlength", maxlength);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseCross
        /// </summary>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="shapes">Input to the operation. </param>
        /// <param name="dense_inputs">Input to the operation. </param>
        /// <param name="hashed_output">hashed output</param>
        /// <param name="num_buckets">num buckets</param>
        /// <param name="hash_key">hash key</param>
        /// <param name="out_type">out type</param>
        /// <param name="internal_type">internal type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_indices(type: DtInt64).
        /// [1] output_values(type: DtInvalid).
        /// [2] output_shape(type: DtInt64).
        /// </returns>
        public Operation SparseCross(Output indices, Output values, Output shapes, Output dense_inputs, bool hashed_output, long num_buckets, long hash_key, DataType out_type, DataType internal_type, String opName = "SparseCross") 
        {
            OperationDescription desc = NewOperation("SparseCross", opName);
            desc.AddInput(indices);
            desc.AddInput(values);
            desc.AddInput(shapes);
            desc.AddInput(dense_inputs);
            desc.SetAttr("hashed_output", hashed_output);
            desc.SetAttr("num_buckets", num_buckets);
            desc.SetAttr("hash_key", hash_key);
            desc.SetAttr("out_type", out_type);
            desc.SetAttr("internal_type", internal_type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseCrossHashed
        /// </summary>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="shapes">Input to the operation. </param>
        /// <param name="dense_inputs">Input to the operation. </param>
        /// <param name="num_buckets">Input to the operation. </param>
        /// <param name="strong_hash">Input to the operation. </param>
        /// <param name="salt">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_indices(type: DtInt64).
        /// [1] output_values(type: DtInt64).
        /// [2] output_shape(type: DtInt64).
        /// </returns>
        public Operation SparseCrossHashed(Output indices, Output values, Output shapes, Output dense_inputs, Output num_buckets, Output strong_hash, Output salt, String opName = "SparseCrossHashed") 
        {
            OperationDescription desc = NewOperation("SparseCrossHashed", opName);
            desc.AddInput(indices);
            desc.AddInput(values);
            desc.AddInput(shapes);
            desc.AddInput(dense_inputs);
            desc.AddInput(num_buckets);
            desc.AddInput(strong_hash);
            desc.AddInput(salt);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseCrossV2
        /// </summary>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="shapes">Input to the operation. </param>
        /// <param name="dense_inputs">Input to the operation. </param>
        /// <param name="sep">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_indices(type: DtInt64).
        /// [1] output_values(type: DtString).
        /// [2] output_shape(type: DtInt64).
        /// </returns>
        public Operation SparseCrossV2(Output indices, Output values, Output shapes, Output dense_inputs, Output sep, String opName = "SparseCrossV2") 
        {
            OperationDescription desc = NewOperation("SparseCrossV2", opName);
            desc.AddInput(indices);
            desc.AddInput(values);
            desc.AddInput(shapes);
            desc.AddInput(dense_inputs);
            desc.AddInput(sep);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseDenseCwiseAdd
        /// </summary>
        /// <param name="sp_indices">Input to the operation. </param>
        /// <param name="sp_values">Input to the operation. </param>
        /// <param name="sp_shape">Input to the operation. </param>
        /// <param name="dense">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SparseDenseCwiseAdd(Output sp_indices, Output sp_values, Output sp_shape, Output dense, String opName = "SparseDenseCwiseAdd") 
        {
            OperationDescription desc = NewOperation("SparseDenseCwiseAdd", opName);
            desc.AddInput(sp_indices);
            desc.AddInput(sp_values);
            desc.AddInput(sp_shape);
            desc.AddInput(dense);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseDenseCwiseDiv
        /// </summary>
        /// <param name="sp_indices">Input to the operation. </param>
        /// <param name="sp_values">Input to the operation. </param>
        /// <param name="sp_shape">Input to the operation. </param>
        /// <param name="dense">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SparseDenseCwiseDiv(Output sp_indices, Output sp_values, Output sp_shape, Output dense, String opName = "SparseDenseCwiseDiv") 
        {
            OperationDescription desc = NewOperation("SparseDenseCwiseDiv", opName);
            desc.AddInput(sp_indices);
            desc.AddInput(sp_values);
            desc.AddInput(sp_shape);
            desc.AddInput(dense);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseDenseCwiseMul
        /// </summary>
        /// <param name="sp_indices">Input to the operation. </param>
        /// <param name="sp_values">Input to the operation. </param>
        /// <param name="sp_shape">Input to the operation. </param>
        /// <param name="dense">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SparseDenseCwiseMul(Output sp_indices, Output sp_values, Output sp_shape, Output dense, String opName = "SparseDenseCwiseMul") 
        {
            OperationDescription desc = NewOperation("SparseDenseCwiseMul", opName);
            desc.AddInput(sp_indices);
            desc.AddInput(sp_values);
            desc.AddInput(sp_shape);
            desc.AddInput(dense);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseFillEmptyRows
        /// </summary>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="dense_shape">Input to the operation. </param>
        /// <param name="default_value">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_indices(type: DtInt64).
        /// [1] output_values(type: DtInvalid).
        /// [2] empty_row_indicator(type: DtBool).
        /// [3] reverse_index_map(type: DtInt64).
        /// </returns>
        public Operation SparseFillEmptyRows(Output indices, Output values, Output dense_shape, Output default_value, String opName = "SparseFillEmptyRows") 
        {
            OperationDescription desc = NewOperation("SparseFillEmptyRows", opName);
            desc.AddInput(indices);
            desc.AddInput(values);
            desc.AddInput(dense_shape);
            desc.AddInput(default_value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseFillEmptyRowsGrad
        /// </summary>
        /// <param name="reverse_index_map">Input to the operation. </param>
        /// <param name="grad_values">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] d_values(type: DtInvalid).
        /// [1] d_default_value(type: DtInvalid).
        /// </returns>
        public Operation SparseFillEmptyRowsGrad(Output reverse_index_map, Output grad_values, String opName = "SparseFillEmptyRowsGrad") 
        {
            OperationDescription desc = NewOperation("SparseFillEmptyRowsGrad", opName);
            desc.AddInput(reverse_index_map);
            desc.AddInput(grad_values);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseMatMul
        /// </summary>
        /// <param name="a">Input to the operation. </param>
        /// <param name="b">Input to the operation. </param>
        /// <param name="transpose_a">transpose a</param>
        /// <param name="transpose_b">transpose b</param>
        /// <param name="a_is_sparse">a is sparse</param>
        /// <param name="b_is_sparse">b is sparse</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] product(type: DtFloat).
        /// </returns>
        public Operation SparseMatMul(Output a, Output b, bool transpose_a = false, bool transpose_b = false, bool a_is_sparse = false, bool b_is_sparse = false, String opName = "SparseMatMul") 
        {
            OperationDescription desc = NewOperation("SparseMatMul", opName);
            desc.AddInput(a);
            desc.AddInput(b);
            if (transpose_a != false)
                desc.SetAttr("transpose_a", transpose_a);
            if (transpose_b != false)
                desc.SetAttr("transpose_b", transpose_b);
            if (a_is_sparse != false)
                desc.SetAttr("a_is_sparse", a_is_sparse);
            if (b_is_sparse != false)
                desc.SetAttr("b_is_sparse", b_is_sparse);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseMatrixAdd
        /// </summary>
        /// <param name="a">Input to the operation. </param>
        /// <param name="b">Input to the operation. </param>
        /// <param name="alpha">Input to the operation. </param>
        /// <param name="beta">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] c(type: DtVariant).
        /// </returns>
        public Operation SparseMatrixAdd(Output a, Output b, Output alpha, Output beta, String opName = "SparseMatrixAdd") 
        {
            OperationDescription desc = NewOperation("SparseMatrixAdd", opName);
            desc.AddInput(a);
            desc.AddInput(b);
            desc.AddInput(alpha);
            desc.AddInput(beta);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseMatrixMatMul
        /// </summary>
        /// <param name="a">Input to the operation. </param>
        /// <param name="b">Input to the operation. </param>
        /// <param name="transpose_a">transpose a</param>
        /// <param name="transpose_b">transpose b</param>
        /// <param name="adjoint_a">adjoint a</param>
        /// <param name="adjoint_b">adjoint b</param>
        /// <param name="transpose_output">transpose output</param>
        /// <param name="conjugate_output">conjugate output</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SparseMatrixMatMul(Output a, Output b, bool transpose_a = false, bool transpose_b = false, bool adjoint_a = false, bool adjoint_b = false, bool transpose_output = false, bool conjugate_output = false, String opName = "SparseMatrixMatMul") 
        {
            OperationDescription desc = NewOperation("SparseMatrixMatMul", opName);
            desc.AddInput(a);
            desc.AddInput(b);
            if (transpose_a != false)
                desc.SetAttr("transpose_a", transpose_a);
            if (transpose_b != false)
                desc.SetAttr("transpose_b", transpose_b);
            if (adjoint_a != false)
                desc.SetAttr("adjoint_a", adjoint_a);
            if (adjoint_b != false)
                desc.SetAttr("adjoint_b", adjoint_b);
            if (transpose_output != false)
                desc.SetAttr("transpose_output", transpose_output);
            if (conjugate_output != false)
                desc.SetAttr("conjugate_output", conjugate_output);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseMatrixMul
        /// </summary>
        /// <param name="a">Input to the operation. </param>
        /// <param name="b">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtVariant).
        /// </returns>
        public Operation SparseMatrixMul(Output a, Output b, String opName = "SparseMatrixMul") 
        {
            OperationDescription desc = NewOperation("SparseMatrixMul", opName);
            desc.AddInput(a);
            desc.AddInput(b);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseMatrixNNZ
        /// </summary>
        /// <param name="sparse_matrix">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] nnz(type: DtInt32).
        /// </returns>
        public Operation SparseMatrixNNZ(Output sparse_matrix, String opName = "SparseMatrixNNZ") 
        {
            OperationDescription desc = NewOperation("SparseMatrixNNZ", opName);
            desc.AddInput(sparse_matrix);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseMatrixOrderingAMD
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInt32).
        /// </returns>
        public Operation SparseMatrixOrderingAMD(Output input, String opName = "SparseMatrixOrderingAMD") 
        {
            OperationDescription desc = NewOperation("SparseMatrixOrderingAMD", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseMatrixSoftmax
        /// </summary>
        /// <param name="logits">Input to the operation. </param>
        /// <param name="type">type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] softmax(type: DtVariant).
        /// </returns>
        public Operation SparseMatrixSoftmax(Output logits, DataType type, String opName = "SparseMatrixSoftmax") 
        {
            OperationDescription desc = NewOperation("SparseMatrixSoftmax", opName);
            desc.AddInput(logits);
            desc.SetAttr("type", type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseMatrixSoftmaxGrad
        /// </summary>
        /// <param name="softmax">Input to the operation. </param>
        /// <param name="grad_softmax">Input to the operation. </param>
        /// <param name="type">type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] gradient(type: DtVariant).
        /// </returns>
        public Operation SparseMatrixSoftmaxGrad(Output softmax, Output grad_softmax, DataType type, String opName = "SparseMatrixSoftmaxGrad") 
        {
            OperationDescription desc = NewOperation("SparseMatrixSoftmaxGrad", opName);
            desc.AddInput(softmax);
            desc.AddInput(grad_softmax);
            desc.SetAttr("type", type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseMatrixSparseCholesky
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="permutation">Input to the operation. </param>
        /// <param name="type">type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtVariant).
        /// </returns>
        public Operation SparseMatrixSparseCholesky(Output input, Output permutation, DataType type, String opName = "SparseMatrixSparseCholesky") 
        {
            OperationDescription desc = NewOperation("SparseMatrixSparseCholesky", opName);
            desc.AddInput(input);
            desc.AddInput(permutation);
            desc.SetAttr("type", type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseMatrixSparseMatMul
        /// </summary>
        /// <param name="a">Input to the operation. </param>
        /// <param name="b">Input to the operation. </param>
        /// <param name="type">type</param>
        /// <param name="transpose_a">transpose a</param>
        /// <param name="transpose_b">transpose b</param>
        /// <param name="adjoint_a">adjoint a</param>
        /// <param name="adjoint_b">adjoint b</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] c(type: DtVariant).
        /// </returns>
        public Operation SparseMatrixSparseMatMul(Output a, Output b, DataType type, bool transpose_a = false, bool transpose_b = false, bool adjoint_a = false, bool adjoint_b = false, String opName = "SparseMatrixSparseMatMul") 
        {
            OperationDescription desc = NewOperation("SparseMatrixSparseMatMul", opName);
            desc.AddInput(a);
            desc.AddInput(b);
            desc.SetAttr("type", type);
            if (transpose_a != false)
                desc.SetAttr("transpose_a", transpose_a);
            if (transpose_b != false)
                desc.SetAttr("transpose_b", transpose_b);
            if (adjoint_a != false)
                desc.SetAttr("adjoint_a", adjoint_a);
            if (adjoint_b != false)
                desc.SetAttr("adjoint_b", adjoint_b);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseMatrixTranspose
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="type">type</param>
        /// <param name="conjugate">conjugate</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtVariant).
        /// </returns>
        public Operation SparseMatrixTranspose(Output input, DataType type, bool conjugate = false, String opName = "SparseMatrixTranspose") 
        {
            OperationDescription desc = NewOperation("SparseMatrixTranspose", opName);
            desc.AddInput(input);
            desc.SetAttr("type", type);
            if (conjugate != false)
                desc.SetAttr("conjugate", conjugate);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseMatrixZeros
        /// </summary>
        /// <param name="dense_shape">Input to the operation. </param>
        /// <param name="type">type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] sparse_matrix(type: DtVariant).
        /// </returns>
        public Operation SparseMatrixZeros(Output dense_shape, DataType type, String opName = "SparseMatrixZeros") 
        {
            OperationDescription desc = NewOperation("SparseMatrixZeros", opName);
            desc.AddInput(dense_shape);
            desc.SetAttr("type", type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseReduceMax
        /// </summary>
        /// <param name="input_indices">Input to the operation. </param>
        /// <param name="input_values">Input to the operation. </param>
        /// <param name="input_shape">Input to the operation. </param>
        /// <param name="reduction_axes">Input to the operation. </param>
        /// <param name="keep_dims">keep dims</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SparseReduceMax(Output input_indices, Output input_values, Output input_shape, Output reduction_axes, bool keep_dims = false, String opName = "SparseReduceMax") 
        {
            OperationDescription desc = NewOperation("SparseReduceMax", opName);
            desc.AddInput(input_indices);
            desc.AddInput(input_values);
            desc.AddInput(input_shape);
            desc.AddInput(reduction_axes);
            if (keep_dims != false)
                desc.SetAttr("keep_dims", keep_dims);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseReduceMaxSparse
        /// </summary>
        /// <param name="input_indices">Input to the operation. </param>
        /// <param name="input_values">Input to the operation. </param>
        /// <param name="input_shape">Input to the operation. </param>
        /// <param name="reduction_axes">Input to the operation. </param>
        /// <param name="keep_dims">keep dims</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_indices(type: DtInt64).
        /// [1] output_values(type: DtInvalid).
        /// [2] output_shape(type: DtInt64).
        /// </returns>
        public Operation SparseReduceMaxSparse(Output input_indices, Output input_values, Output input_shape, Output reduction_axes, bool keep_dims = false, String opName = "SparseReduceMaxSparse") 
        {
            OperationDescription desc = NewOperation("SparseReduceMaxSparse", opName);
            desc.AddInput(input_indices);
            desc.AddInput(input_values);
            desc.AddInput(input_shape);
            desc.AddInput(reduction_axes);
            if (keep_dims != false)
                desc.SetAttr("keep_dims", keep_dims);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseReduceSum
        /// </summary>
        /// <param name="input_indices">Input to the operation. </param>
        /// <param name="input_values">Input to the operation. </param>
        /// <param name="input_shape">Input to the operation. </param>
        /// <param name="reduction_axes">Input to the operation. </param>
        /// <param name="keep_dims">keep dims</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SparseReduceSum(Output input_indices, Output input_values, Output input_shape, Output reduction_axes, bool keep_dims = false, String opName = "SparseReduceSum") 
        {
            OperationDescription desc = NewOperation("SparseReduceSum", opName);
            desc.AddInput(input_indices);
            desc.AddInput(input_values);
            desc.AddInput(input_shape);
            desc.AddInput(reduction_axes);
            if (keep_dims != false)
                desc.SetAttr("keep_dims", keep_dims);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseReduceSumSparse
        /// </summary>
        /// <param name="input_indices">Input to the operation. </param>
        /// <param name="input_values">Input to the operation. </param>
        /// <param name="input_shape">Input to the operation. </param>
        /// <param name="reduction_axes">Input to the operation. </param>
        /// <param name="keep_dims">keep dims</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_indices(type: DtInt64).
        /// [1] output_values(type: DtInvalid).
        /// [2] output_shape(type: DtInt64).
        /// </returns>
        public Operation SparseReduceSumSparse(Output input_indices, Output input_values, Output input_shape, Output reduction_axes, bool keep_dims = false, String opName = "SparseReduceSumSparse") 
        {
            OperationDescription desc = NewOperation("SparseReduceSumSparse", opName);
            desc.AddInput(input_indices);
            desc.AddInput(input_values);
            desc.AddInput(input_shape);
            desc.AddInput(reduction_axes);
            if (keep_dims != false)
                desc.SetAttr("keep_dims", keep_dims);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseReorder
        /// </summary>
        /// <param name="input_indices">Input to the operation. </param>
        /// <param name="input_values">Input to the operation. </param>
        /// <param name="input_shape">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_indices(type: DtInt64).
        /// [1] output_values(type: DtInvalid).
        /// </returns>
        public Operation SparseReorder(Output input_indices, Output input_values, Output input_shape, String opName = "SparseReorder") 
        {
            OperationDescription desc = NewOperation("SparseReorder", opName);
            desc.AddInput(input_indices);
            desc.AddInput(input_values);
            desc.AddInput(input_shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseReshape
        /// </summary>
        /// <param name="input_indices">Input to the operation. </param>
        /// <param name="input_shape">Input to the operation. </param>
        /// <param name="new_shape">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_indices(type: DtInt64).
        /// [1] output_shape(type: DtInt64).
        /// </returns>
        public Operation SparseReshape(Output input_indices, Output input_shape, Output new_shape, String opName = "SparseReshape") 
        {
            OperationDescription desc = NewOperation("SparseReshape", opName);
            desc.AddInput(input_indices);
            desc.AddInput(input_shape);
            desc.AddInput(new_shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseSegmentMean
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="segment_ids">Input to the operation. </param>
        /// <param name="sparse_gradient">sparse gradient</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SparseSegmentMean(Output data, Output indices, Output segment_ids, bool sparse_gradient = false, String opName = "SparseSegmentMean") 
        {
            OperationDescription desc = NewOperation("SparseSegmentMean", opName);
            desc.AddInput(data);
            desc.AddInput(indices);
            desc.AddInput(segment_ids);
            if (sparse_gradient != false)
                desc.SetAttr("sparse_gradient", sparse_gradient);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseSegmentMeanGrad
        /// </summary>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="segment_ids">Input to the operation. </param>
        /// <param name="output_dim0">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SparseSegmentMeanGrad(Output grad, Output indices, Output segment_ids, Output output_dim0, String opName = "SparseSegmentMeanGrad") 
        {
            OperationDescription desc = NewOperation("SparseSegmentMeanGrad", opName);
            desc.AddInput(grad);
            desc.AddInput(indices);
            desc.AddInput(segment_ids);
            desc.AddInput(output_dim0);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseSegmentMeanGradV2
        /// </summary>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="segment_ids">Input to the operation. </param>
        /// <param name="dense_output_dim0">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] sorted_unique_indices(type: DtInvalid).
        /// </returns>
        public Operation SparseSegmentMeanGradV2(Output grad, Output indices, Output segment_ids, Output dense_output_dim0, String opName = "SparseSegmentMeanGradV2") 
        {
            OperationDescription desc = NewOperation("SparseSegmentMeanGradV2", opName);
            desc.AddInput(grad);
            desc.AddInput(indices);
            desc.AddInput(segment_ids);
            desc.AddInput(dense_output_dim0);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseSegmentMeanWithNumSegments
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="segment_ids">Input to the operation. </param>
        /// <param name="num_segments">Input to the operation. </param>
        /// <param name="sparse_gradient">sparse gradient</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SparseSegmentMeanWithNumSegments(Output data, Output indices, Output segment_ids, Output num_segments, bool sparse_gradient = false, String opName = "SparseSegmentMeanWithNumSegments") 
        {
            OperationDescription desc = NewOperation("SparseSegmentMeanWithNumSegments", opName);
            desc.AddInput(data);
            desc.AddInput(indices);
            desc.AddInput(segment_ids);
            desc.AddInput(num_segments);
            if (sparse_gradient != false)
                desc.SetAttr("sparse_gradient", sparse_gradient);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseSegmentSqrtN
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="segment_ids">Input to the operation. </param>
        /// <param name="sparse_gradient">sparse gradient</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SparseSegmentSqrtN(Output data, Output indices, Output segment_ids, bool sparse_gradient = false, String opName = "SparseSegmentSqrtN") 
        {
            OperationDescription desc = NewOperation("SparseSegmentSqrtN", opName);
            desc.AddInput(data);
            desc.AddInput(indices);
            desc.AddInput(segment_ids);
            if (sparse_gradient != false)
                desc.SetAttr("sparse_gradient", sparse_gradient);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseSegmentSqrtNGrad
        /// </summary>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="segment_ids">Input to the operation. </param>
        /// <param name="output_dim0">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SparseSegmentSqrtNGrad(Output grad, Output indices, Output segment_ids, Output output_dim0, String opName = "SparseSegmentSqrtNGrad") 
        {
            OperationDescription desc = NewOperation("SparseSegmentSqrtNGrad", opName);
            desc.AddInput(grad);
            desc.AddInput(indices);
            desc.AddInput(segment_ids);
            desc.AddInput(output_dim0);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseSegmentSqrtNGradV2
        /// </summary>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="segment_ids">Input to the operation. </param>
        /// <param name="dense_output_dim0">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] sorted_unique_indices(type: DtInvalid).
        /// </returns>
        public Operation SparseSegmentSqrtNGradV2(Output grad, Output indices, Output segment_ids, Output dense_output_dim0, String opName = "SparseSegmentSqrtNGradV2") 
        {
            OperationDescription desc = NewOperation("SparseSegmentSqrtNGradV2", opName);
            desc.AddInput(grad);
            desc.AddInput(indices);
            desc.AddInput(segment_ids);
            desc.AddInput(dense_output_dim0);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseSegmentSqrtNWithNumSegments
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="segment_ids">Input to the operation. </param>
        /// <param name="num_segments">Input to the operation. </param>
        /// <param name="sparse_gradient">sparse gradient</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SparseSegmentSqrtNWithNumSegments(Output data, Output indices, Output segment_ids, Output num_segments, bool sparse_gradient = false, String opName = "SparseSegmentSqrtNWithNumSegments") 
        {
            OperationDescription desc = NewOperation("SparseSegmentSqrtNWithNumSegments", opName);
            desc.AddInput(data);
            desc.AddInput(indices);
            desc.AddInput(segment_ids);
            desc.AddInput(num_segments);
            if (sparse_gradient != false)
                desc.SetAttr("sparse_gradient", sparse_gradient);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseSegmentSum
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="segment_ids">Input to the operation. </param>
        /// <param name="sparse_gradient">sparse gradient</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SparseSegmentSum(Output data, Output indices, Output segment_ids, bool sparse_gradient = false, String opName = "SparseSegmentSum") 
        {
            OperationDescription desc = NewOperation("SparseSegmentSum", opName);
            desc.AddInput(data);
            desc.AddInput(indices);
            desc.AddInput(segment_ids);
            if (sparse_gradient != false)
                desc.SetAttr("sparse_gradient", sparse_gradient);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseSegmentSumGrad
        /// </summary>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="segment_ids">Input to the operation. </param>
        /// <param name="output_dim0">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SparseSegmentSumGrad(Output grad, Output indices, Output segment_ids, Output output_dim0, String opName = "SparseSegmentSumGrad") 
        {
            OperationDescription desc = NewOperation("SparseSegmentSumGrad", opName);
            desc.AddInput(grad);
            desc.AddInput(indices);
            desc.AddInput(segment_ids);
            desc.AddInput(output_dim0);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseSegmentSumGradV2
        /// </summary>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="segment_ids">Input to the operation. </param>
        /// <param name="dense_output_dim0">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// [1] sorted_unique_indices(type: DtInvalid).
        /// </returns>
        public Operation SparseSegmentSumGradV2(Output grad, Output indices, Output segment_ids, Output dense_output_dim0, String opName = "SparseSegmentSumGradV2") 
        {
            OperationDescription desc = NewOperation("SparseSegmentSumGradV2", opName);
            desc.AddInput(grad);
            desc.AddInput(indices);
            desc.AddInput(segment_ids);
            desc.AddInput(dense_output_dim0);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseSegmentSumWithNumSegments
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="segment_ids">Input to the operation. </param>
        /// <param name="num_segments">Input to the operation. </param>
        /// <param name="sparse_gradient">sparse gradient</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SparseSegmentSumWithNumSegments(Output data, Output indices, Output segment_ids, Output num_segments, bool sparse_gradient = false, String opName = "SparseSegmentSumWithNumSegments") 
        {
            OperationDescription desc = NewOperation("SparseSegmentSumWithNumSegments", opName);
            desc.AddInput(data);
            desc.AddInput(indices);
            desc.AddInput(segment_ids);
            desc.AddInput(num_segments);
            if (sparse_gradient != false)
                desc.SetAttr("sparse_gradient", sparse_gradient);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseSlice
        /// </summary>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="start">Input to the operation. </param>
        /// <param name="size">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_indices(type: DtInt64).
        /// [1] output_values(type: DtInvalid).
        /// [2] output_shape(type: DtInt64).
        /// </returns>
        public Operation SparseSlice(Output indices, Output values, Output shape, Output start, Output size, String opName = "SparseSlice") 
        {
            OperationDescription desc = NewOperation("SparseSlice", opName);
            desc.AddInput(indices);
            desc.AddInput(values);
            desc.AddInput(shape);
            desc.AddInput(start);
            desc.AddInput(size);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseSliceGrad
        /// </summary>
        /// <param name="backprop_val_grad">Input to the operation. </param>
        /// <param name="input_indices">Input to the operation. </param>
        /// <param name="input_start">Input to the operation. </param>
        /// <param name="output_indices">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] val_grad(type: DtInvalid).
        /// </returns>
        public Operation SparseSliceGrad(Output backprop_val_grad, Output input_indices, Output input_start, Output output_indices, String opName = "SparseSliceGrad") 
        {
            OperationDescription desc = NewOperation("SparseSliceGrad", opName);
            desc.AddInput(backprop_val_grad);
            desc.AddInput(input_indices);
            desc.AddInput(input_start);
            desc.AddInput(output_indices);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseSoftmax
        /// </summary>
        /// <param name="sp_indices">Input to the operation. </param>
        /// <param name="sp_values">Input to the operation. </param>
        /// <param name="sp_shape">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SparseSoftmax(Output sp_indices, Output sp_values, Output sp_shape, String opName = "SparseSoftmax") 
        {
            OperationDescription desc = NewOperation("SparseSoftmax", opName);
            desc.AddInput(sp_indices);
            desc.AddInput(sp_values);
            desc.AddInput(sp_shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseSoftmaxCrossEntropyWithLogits
        /// </summary>
        /// <param name="features">Input to the operation. </param>
        /// <param name="labels">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] loss(type: DtInvalid).
        /// [1] backprop(type: DtInvalid).
        /// </returns>
        public Operation SparseSoftmaxCrossEntropyWithLogits(Output features, Output labels, String opName = "SparseSoftmaxCrossEntropyWithLogits") 
        {
            OperationDescription desc = NewOperation("SparseSoftmaxCrossEntropyWithLogits", opName);
            desc.AddInput(features);
            desc.AddInput(labels);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseSparseMaximum
        /// </summary>
        /// <param name="a_indices">Input to the operation. </param>
        /// <param name="a_values">Input to the operation. </param>
        /// <param name="a_shape">Input to the operation. </param>
        /// <param name="b_indices">Input to the operation. </param>
        /// <param name="b_values">Input to the operation. </param>
        /// <param name="b_shape">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_indices(type: DtInt64).
        /// [1] output_values(type: DtInvalid).
        /// </returns>
        public Operation SparseSparseMaximum(Output a_indices, Output a_values, Output a_shape, Output b_indices, Output b_values, Output b_shape, String opName = "SparseSparseMaximum") 
        {
            OperationDescription desc = NewOperation("SparseSparseMaximum", opName);
            desc.AddInput(a_indices);
            desc.AddInput(a_values);
            desc.AddInput(a_shape);
            desc.AddInput(b_indices);
            desc.AddInput(b_values);
            desc.AddInput(b_shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseSparseMinimum
        /// </summary>
        /// <param name="a_indices">Input to the operation. </param>
        /// <param name="a_values">Input to the operation. </param>
        /// <param name="a_shape">Input to the operation. </param>
        /// <param name="b_indices">Input to the operation. </param>
        /// <param name="b_values">Input to the operation. </param>
        /// <param name="b_shape">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_indices(type: DtInt64).
        /// [1] output_values(type: DtInvalid).
        /// </returns>
        public Operation SparseSparseMinimum(Output a_indices, Output a_values, Output a_shape, Output b_indices, Output b_values, Output b_shape, String opName = "SparseSparseMinimum") 
        {
            OperationDescription desc = NewOperation("SparseSparseMinimum", opName);
            desc.AddInput(a_indices);
            desc.AddInput(a_values);
            desc.AddInput(a_shape);
            desc.AddInput(b_indices);
            desc.AddInput(b_values);
            desc.AddInput(b_shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseSplit
        /// </summary>
        /// <param name="split_dim">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="num_split">num split</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_indices(type: DtInt64).
        /// [1] output_values(type: DtInvalid).
        /// [2] output_shape(type: DtInt64).
        /// </returns>
        public Operation SparseSplit(Output split_dim, Output indices, Output values, Output shape, long num_split, String opName = "SparseSplit") 
        {
            OperationDescription desc = NewOperation("SparseSplit", opName);
            desc.AddInput(split_dim);
            desc.AddInput(indices);
            desc.AddInput(values);
            desc.AddInput(shape);
            desc.SetAttr("num_split", num_split);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseTensorDenseAdd
        /// </summary>
        /// <param name="a_indices">Input to the operation. </param>
        /// <param name="a_values">Input to the operation. </param>
        /// <param name="a_shape">Input to the operation. </param>
        /// <param name="b">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SparseTensorDenseAdd(Output a_indices, Output a_values, Output a_shape, Output b, String opName = "SparseTensorDenseAdd") 
        {
            OperationDescription desc = NewOperation("SparseTensorDenseAdd", opName);
            desc.AddInput(a_indices);
            desc.AddInput(a_values);
            desc.AddInput(a_shape);
            desc.AddInput(b);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseTensorDenseMatMul
        /// </summary>
        /// <param name="a_indices">Input to the operation. </param>
        /// <param name="a_values">Input to the operation. </param>
        /// <param name="a_shape">Input to the operation. </param>
        /// <param name="b">Input to the operation. </param>
        /// <param name="adjoint_a">adjoint a</param>
        /// <param name="adjoint_b">adjoint b</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] product(type: DtInvalid).
        /// </returns>
        public Operation SparseTensorDenseMatMul(Output a_indices, Output a_values, Output a_shape, Output b, bool adjoint_a = false, bool adjoint_b = false, String opName = "SparseTensorDenseMatMul") 
        {
            OperationDescription desc = NewOperation("SparseTensorDenseMatMul", opName);
            desc.AddInput(a_indices);
            desc.AddInput(a_values);
            desc.AddInput(a_shape);
            desc.AddInput(b);
            if (adjoint_a != false)
                desc.SetAttr("adjoint_a", adjoint_a);
            if (adjoint_b != false)
                desc.SetAttr("adjoint_b", adjoint_b);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseTensorSliceDataset
        /// </summary>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="dense_shape">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation SparseTensorSliceDataset(Output indices, Output values, Output dense_shape, String opName = "SparseTensorSliceDataset") 
        {
            OperationDescription desc = NewOperation("SparseTensorSliceDataset", opName);
            desc.AddInput(indices);
            desc.AddInput(values);
            desc.AddInput(dense_shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseTensorToCSRSparseMatrix
        /// </summary>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="dense_shape">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] sparse_matrix(type: DtVariant).
        /// </returns>
        public Operation SparseTensorToCSRSparseMatrix(Output indices, Output values, Output dense_shape, String opName = "SparseTensorToCSRSparseMatrix") 
        {
            OperationDescription desc = NewOperation("SparseTensorToCSRSparseMatrix", opName);
            desc.AddInput(indices);
            desc.AddInput(values);
            desc.AddInput(dense_shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseToDense
        /// </summary>
        /// <param name="sparse_indices">Input to the operation. </param>
        /// <param name="output_shape">Input to the operation. </param>
        /// <param name="sparse_values">Input to the operation. </param>
        /// <param name="default_value">Input to the operation. </param>
        /// <param name="validate_indices">validate indices</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] dense(type: DtInvalid).
        /// </returns>
        public Operation SparseToDense(Output sparse_indices, Output output_shape, Output sparse_values, Output default_value, bool validate_indices = true, String opName = "SparseToDense") 
        {
            OperationDescription desc = NewOperation("SparseToDense", opName);
            desc.AddInput(sparse_indices);
            desc.AddInput(output_shape);
            desc.AddInput(sparse_values);
            desc.AddInput(default_value);
            if (validate_indices != true)
                desc.SetAttr("validate_indices", validate_indices);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SparseToSparseSetOperation
        /// </summary>
        /// <param name="set1_indices">Input to the operation. </param>
        /// <param name="set1_values">Input to the operation. </param>
        /// <param name="set1_shape">Input to the operation. </param>
        /// <param name="set2_indices">Input to the operation. </param>
        /// <param name="set2_values">Input to the operation. </param>
        /// <param name="set2_shape">Input to the operation. </param>
        /// <param name="set_operation">set operation</param>
        /// <param name="validate_indices">validate indices</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] result_indices(type: DtInt64).
        /// [1] result_values(type: DtInvalid).
        /// [2] result_shape(type: DtInt64).
        /// </returns>
        public Operation SparseToSparseSetOperation(Output set1_indices, Output set1_values, Output set1_shape, Output set2_indices, Output set2_values, Output set2_shape, string set_operation, bool validate_indices = true, String opName = "SparseToSparseSetOperation") 
        {
            OperationDescription desc = NewOperation("SparseToSparseSetOperation", opName);
            desc.AddInput(set1_indices);
            desc.AddInput(set1_values);
            desc.AddInput(set1_shape);
            desc.AddInput(set2_indices);
            desc.AddInput(set2_values);
            desc.AddInput(set2_shape);
            desc.SetAttr("set_operation", set_operation);
            if (validate_indices != true)
                desc.SetAttr("validate_indices", validate_indices);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Spence
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Spence(Output x, String opName = "Spence") 
        {
            OperationDescription desc = NewOperation("Spence", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Split
        /// </summary>
        /// <param name="split_dim">Input to the operation. </param>
        /// <param name="value">Input to the operation. </param>
        /// <param name="num_split">num split</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Split(Output split_dim, Output value, long num_split, String opName = "Split") 
        {
            OperationDescription desc = NewOperation("Split", opName);
            desc.AddInput(split_dim);
            desc.AddInput(value);
            desc.SetAttr("num_split", num_split);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SplitDedupData
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="integer_type">integer type</param>
        /// <param name="float_type">float type</param>
        /// <param name="tuple_mask">tuple mask</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] integer_tensor(type: DtInvalid).
        /// [1] float_tensor(type: DtInvalid).
        /// </returns>
        public Operation SplitDedupData(Output input, DataType integer_type, DataType float_type, string tuple_mask, string config = null, String opName = "SplitDedupData") 
        {
            OperationDescription desc = NewOperation("SplitDedupData", opName);
            desc.AddInput(input);
            desc.SetAttr("integer_type", integer_type);
            desc.SetAttr("float_type", float_type);
            desc.SetAttr("tuple_mask", tuple_mask);
            if (config != null)
                 desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SplitV
        /// </summary>
        /// <param name="value">Input to the operation. </param>
        /// <param name="size_splits">Input to the operation. </param>
        /// <param name="split_dim">Input to the operation. </param>
        /// <param name="num_split">num split</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation SplitV(Output value, Output size_splits, Output split_dim, long num_split, String opName = "SplitV") 
        {
            OperationDescription desc = NewOperation("SplitV", opName);
            desc.AddInput(value);
            desc.AddInput(size_splits);
            desc.AddInput(split_dim);
            desc.SetAttr("num_split", num_split);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SqlDataset
        /// </summary>
        /// <param name="driver_name">Input to the operation. </param>
        /// <param name="data_source_name">Input to the operation. </param>
        /// <param name="query">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation SqlDataset(Output driver_name, Output data_source_name, Output query, DataType[] output_types, long[][] output_shapes, String opName = "SqlDataset") 
        {
            OperationDescription desc = NewOperation("SqlDataset", opName);
            desc.AddInput(driver_name);
            desc.AddInput(data_source_name);
            desc.AddInput(query);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Sqrt
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Sqrt(Output x, String opName = "Sqrt") 
        {
            OperationDescription desc = NewOperation("Sqrt", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SqrtGrad
        /// </summary>
        /// <param name="y">Input to the operation. </param>
        /// <param name="dy">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation SqrtGrad(Output y, Output dy, String opName = "SqrtGrad") 
        {
            OperationDescription desc = NewOperation("SqrtGrad", opName);
            desc.AddInput(y);
            desc.AddInput(dy);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Square
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Square(Output x, String opName = "Square") 
        {
            OperationDescription desc = NewOperation("Square", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SquaredDifference
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation SquaredDifference(Output x, Output y, String opName = "SquaredDifference") 
        {
            OperationDescription desc = NewOperation("SquaredDifference", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Squeeze
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="squeeze_dims">squeeze dims</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Squeeze(Output input, long[] squeeze_dims = null, String opName = "Squeeze") 
        {
            OperationDescription desc = NewOperation("Squeeze", opName);
            desc.AddInput(input);
            if (squeeze_dims != null) desc.SetAttr("squeeze_dims", squeeze_dims);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Stack
        /// </summary>
        /// <param name="elem_type">elem type</param>
        /// <param name="stack_name">stack name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtString).
        /// </returns>
        public Operation Stack(DataType elem_type, string stack_name = null, String opName = "Stack") 
        {
            OperationDescription desc = NewOperation("Stack", opName);
            desc.SetAttr("elem_type", elem_type);
            if (stack_name != null)
                 desc.SetAttr("stack_name", stack_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StackClose
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation StackClose(Output handle, String opName = "StackClose") 
        {
            OperationDescription desc = NewOperation("StackClose", opName);
            desc.AddInput(handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StackCloseV2
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation StackCloseV2(Output handle, String opName = "StackCloseV2") 
        {
            OperationDescription desc = NewOperation("StackCloseV2", opName);
            desc.AddInput(handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StackPop
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="elem_type">elem type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] elem(type: DtInvalid).
        /// </returns>
        public Operation StackPop(Output handle, DataType elem_type, String opName = "StackPop") 
        {
            OperationDescription desc = NewOperation("StackPop", opName);
            desc.AddInput(handle);
            desc.SetAttr("elem_type", elem_type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StackPopV2
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="elem_type">elem type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] elem(type: DtInvalid).
        /// </returns>
        public Operation StackPopV2(Output handle, DataType elem_type, String opName = "StackPopV2") 
        {
            OperationDescription desc = NewOperation("StackPopV2", opName);
            desc.AddInput(handle);
            desc.SetAttr("elem_type", elem_type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StackPush
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="elem">Input to the operation. </param>
        /// <param name="swap_memory">swap memory</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StackPush(Output handle, Output elem, bool swap_memory = false, String opName = "StackPush") 
        {
            OperationDescription desc = NewOperation("StackPush", opName);
            desc.AddInput(handle);
            desc.AddInput(elem);
            if (swap_memory != false)
                desc.SetAttr("swap_memory", swap_memory);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StackPushV2
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="elem">Input to the operation. </param>
        /// <param name="swap_memory">swap memory</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StackPushV2(Output handle, Output elem, bool swap_memory = false, String opName = "StackPushV2") 
        {
            OperationDescription desc = NewOperation("StackPushV2", opName);
            desc.AddInput(handle);
            desc.AddInput(elem);
            if (swap_memory != false)
                desc.SetAttr("swap_memory", swap_memory);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StackV2
        /// </summary>
        /// <param name="max_size">Input to the operation. </param>
        /// <param name="elem_type">elem type</param>
        /// <param name="stack_name">stack name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// </returns>
        public Operation StackV2(Output max_size, DataType elem_type, string stack_name = null, String opName = "StackV2") 
        {
            OperationDescription desc = NewOperation("StackV2", opName);
            desc.AddInput(max_size);
            desc.SetAttr("elem_type", elem_type);
            if (stack_name != null)
                 desc.SetAttr("stack_name", stack_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Stage
        /// </summary>
        /// <param name="values">Input to the operation. </param>
        /// <param name="capacity">capacity</param>
        /// <param name="memory_limit">memory limit</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation Stage(Output values, long capacity = 0, long memory_limit = 0, string container = null, string shared_name = null, String opName = "Stage") 
        {
            OperationDescription desc = NewOperation("Stage", opName);
            desc.AddInput(values);
            if (capacity != 0)
                desc.SetAttr("capacity", capacity);
            if (memory_limit != 0)
                desc.SetAttr("memory_limit", memory_limit);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StageClear
        /// </summary>
        /// <param name="dtypes">dtypes</param>
        /// <param name="capacity">capacity</param>
        /// <param name="memory_limit">memory limit</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation StageClear(DataType[] dtypes, long capacity = 0, long memory_limit = 0, string container = null, string shared_name = null, String opName = "StageClear") 
        {
            OperationDescription desc = NewOperation("StageClear", opName);
            desc.SetAttr("dtypes", dtypes);
            if (capacity != 0)
                desc.SetAttr("capacity", capacity);
            if (memory_limit != 0)
                desc.SetAttr("memory_limit", memory_limit);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StagePeek
        /// </summary>
        /// <param name="index">Input to the operation. </param>
        /// <param name="dtypes">dtypes</param>
        /// <param name="capacity">capacity</param>
        /// <param name="memory_limit">memory limit</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] values(type: DtInvalid).
        /// </returns>
        public Operation StagePeek(Output index, DataType[] dtypes, long capacity = 0, long memory_limit = 0, string container = null, string shared_name = null, String opName = "StagePeek") 
        {
            OperationDescription desc = NewOperation("StagePeek", opName);
            desc.AddInput(index);
            desc.SetAttr("dtypes", dtypes);
            if (capacity != 0)
                desc.SetAttr("capacity", capacity);
            if (memory_limit != 0)
                desc.SetAttr("memory_limit", memory_limit);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StageSize
        /// </summary>
        /// <param name="dtypes">dtypes</param>
        /// <param name="capacity">capacity</param>
        /// <param name="memory_limit">memory limit</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] size(type: DtInt32).
        /// </returns>
        public Operation StageSize(DataType[] dtypes, long capacity = 0, long memory_limit = 0, string container = null, string shared_name = null, String opName = "StageSize") 
        {
            OperationDescription desc = NewOperation("StageSize", opName);
            desc.SetAttr("dtypes", dtypes);
            if (capacity != 0)
                desc.SetAttr("capacity", capacity);
            if (memory_limit != 0)
                desc.SetAttr("memory_limit", memory_limit);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatefulPartitionedCall
        /// </summary>
        /// <param name="args">Input to the operation. </param>
        /// <param name="Tout">Tout</param>
        /// <param name="config">config</param>
        /// <param name="config_proto">config proto</param>
        /// <param name="executor_type">executor type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        // The following attributes are not known: f: func
        public Operation StatefulPartitionedCall(Output args, DataType[] Tout, string config = null, string config_proto = null, string executor_type = null, String opName = "StatefulPartitionedCall") 
        {
            OperationDescription desc = NewOperation("StatefulPartitionedCall", opName);
            desc.AddInput(args);
            desc.SetAttr("Tout", Tout);
            if (config != null)
                 desc.SetAttr("config", config);
            if (config_proto != null)
                 desc.SetAttr("config_proto", config_proto);
            if (executor_type != null)
                 desc.SetAttr("executor_type", executor_type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatefulRandomBinomial
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="algorithm">Input to the operation. </param>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="counts">Input to the operation. </param>
        /// <param name="probs">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StatefulRandomBinomial(Output resource, Output algorithm, Output shape, Output counts, Output probs, DataType? dtype = null, String opName = "StatefulRandomBinomial") 
        {
            OperationDescription desc = NewOperation("StatefulRandomBinomial", opName);
            desc.AddInput(resource);
            desc.AddInput(algorithm);
            desc.AddInput(shape);
            desc.AddInput(counts);
            desc.AddInput(probs);
            if (dtype.HasValue)
                desc.SetAttr("dtype", dtype.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatefulStandardNormal
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StatefulStandardNormal(Output resource, Output shape, DataType? dtype = null, String opName = "StatefulStandardNormal") 
        {
            OperationDescription desc = NewOperation("StatefulStandardNormal", opName);
            desc.AddInput(resource);
            desc.AddInput(shape);
            if (dtype.HasValue)
                desc.SetAttr("dtype", dtype.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatefulStandardNormalV2
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="algorithm">Input to the operation. </param>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StatefulStandardNormalV2(Output resource, Output algorithm, Output shape, DataType? dtype = null, String opName = "StatefulStandardNormalV2") 
        {
            OperationDescription desc = NewOperation("StatefulStandardNormalV2", opName);
            desc.AddInput(resource);
            desc.AddInput(algorithm);
            desc.AddInput(shape);
            if (dtype.HasValue)
                desc.SetAttr("dtype", dtype.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatefulTruncatedNormal
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="algorithm">Input to the operation. </param>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StatefulTruncatedNormal(Output resource, Output algorithm, Output shape, DataType? dtype = null, String opName = "StatefulTruncatedNormal") 
        {
            OperationDescription desc = NewOperation("StatefulTruncatedNormal", opName);
            desc.AddInput(resource);
            desc.AddInput(algorithm);
            desc.AddInput(shape);
            if (dtype.HasValue)
                desc.SetAttr("dtype", dtype.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatefulUniform
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="algorithm">Input to the operation. </param>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StatefulUniform(Output resource, Output algorithm, Output shape, DataType? dtype = null, String opName = "StatefulUniform") 
        {
            OperationDescription desc = NewOperation("StatefulUniform", opName);
            desc.AddInput(resource);
            desc.AddInput(algorithm);
            desc.AddInput(shape);
            if (dtype.HasValue)
                desc.SetAttr("dtype", dtype.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatefulUniformFullInt
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="algorithm">Input to the operation. </param>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StatefulUniformFullInt(Output resource, Output algorithm, Output shape, DataType? dtype = null, String opName = "StatefulUniformFullInt") 
        {
            OperationDescription desc = NewOperation("StatefulUniformFullInt", opName);
            desc.AddInput(resource);
            desc.AddInput(algorithm);
            desc.AddInput(shape);
            if (dtype.HasValue)
                desc.SetAttr("dtype", dtype.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatefulUniformInt
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="algorithm">Input to the operation. </param>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="minval">Input to the operation. </param>
        /// <param name="maxval">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StatefulUniformInt(Output resource, Output algorithm, Output shape, Output minval, Output maxval, String opName = "StatefulUniformInt") 
        {
            OperationDescription desc = NewOperation("StatefulUniformInt", opName);
            desc.AddInput(resource);
            desc.AddInput(algorithm);
            desc.AddInput(shape);
            desc.AddInput(minval);
            desc.AddInput(maxval);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatelessCase
        /// </summary>
        /// <param name="branch_index">Input to the operation. </param>
        /// <param name="input">Input to the operation. </param>
        /// <param name="Tout">Tout</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        // The following attributes are not known: branches: list(func)
        public Operation StatelessCase(Output branch_index, Output input, DataType[] Tout, long[][] output_shapes = null, String opName = "StatelessCase") 
        {
            OperationDescription desc = NewOperation("StatelessCase", opName);
            desc.AddInput(branch_index);
            desc.AddInput(input);
            desc.SetAttr("Tout", Tout);
            if (output_shapes != null) desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatelessIf
        /// </summary>
        /// <param name="cond">Input to the operation. </param>
        /// <param name="input">Input to the operation. </param>
        /// <param name="Tout">Tout</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        // The following attributes are not known: then_branch: func; else_branch: func
        public Operation StatelessIf(Output cond, Output input, DataType[] Tout, long[][] output_shapes = null, String opName = "StatelessIf") 
        {
            OperationDescription desc = NewOperation("StatelessIf", opName);
            desc.AddInput(cond);
            desc.AddInput(input);
            desc.SetAttr("Tout", Tout);
            if (output_shapes != null) desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatelessMultinomial
        /// </summary>
        /// <param name="logits">Input to the operation. </param>
        /// <param name="num_samples">Input to the operation. </param>
        /// <param name="seed">Input to the operation. </param>
        /// <param name="output_dtype">output dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StatelessMultinomial(Output logits, Output num_samples, Output seed, DataType? output_dtype = null, String opName = "StatelessMultinomial") 
        {
            OperationDescription desc = NewOperation("StatelessMultinomial", opName);
            desc.AddInput(logits);
            desc.AddInput(num_samples);
            desc.AddInput(seed);
            if (output_dtype.HasValue)
                desc.SetAttr("output_dtype", output_dtype.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatelessParameterizedTruncatedNormal
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="seed">Input to the operation. </param>
        /// <param name="means">Input to the operation. </param>
        /// <param name="stddevs">Input to the operation. </param>
        /// <param name="minvals">Input to the operation. </param>
        /// <param name="maxvals">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StatelessParameterizedTruncatedNormal(Output shape, Output seed, Output means, Output stddevs, Output minvals, Output maxvals, String opName = "StatelessParameterizedTruncatedNormal") 
        {
            OperationDescription desc = NewOperation("StatelessParameterizedTruncatedNormal", opName);
            desc.AddInput(shape);
            desc.AddInput(seed);
            desc.AddInput(means);
            desc.AddInput(stddevs);
            desc.AddInput(minvals);
            desc.AddInput(maxvals);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatelessRandomBinomial
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="seed">Input to the operation. </param>
        /// <param name="counts">Input to the operation. </param>
        /// <param name="probs">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StatelessRandomBinomial(Output shape, Output seed, Output counts, Output probs, DataType? dtype = null, String opName = "StatelessRandomBinomial") 
        {
            OperationDescription desc = NewOperation("StatelessRandomBinomial", opName);
            desc.AddInput(shape);
            desc.AddInput(seed);
            desc.AddInput(counts);
            desc.AddInput(probs);
            if (dtype.HasValue)
                desc.SetAttr("dtype", dtype.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatelessRandomGammaV2
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="seed">Input to the operation. </param>
        /// <param name="alpha">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StatelessRandomGammaV2(Output shape, Output seed, Output alpha, String opName = "StatelessRandomGammaV2") 
        {
            OperationDescription desc = NewOperation("StatelessRandomGammaV2", opName);
            desc.AddInput(shape);
            desc.AddInput(seed);
            desc.AddInput(alpha);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatelessRandomGammaV3
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="key">Input to the operation. </param>
        /// <param name="counter">Input to the operation. </param>
        /// <param name="alg">Input to the operation. </param>
        /// <param name="alpha">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StatelessRandomGammaV3(Output shape, Output key, Output counter, Output alg, Output alpha, String opName = "StatelessRandomGammaV3") 
        {
            OperationDescription desc = NewOperation("StatelessRandomGammaV3", opName);
            desc.AddInput(shape);
            desc.AddInput(key);
            desc.AddInput(counter);
            desc.AddInput(alg);
            desc.AddInput(alpha);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatelessRandomGetAlg
        /// </summary>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] alg(type: DtInt32).
        /// </returns>
        public Operation StatelessRandomGetAlg(String opName = "StatelessRandomGetAlg") 
        {
            OperationDescription desc = NewOperation("StatelessRandomGetAlg", opName);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatelessRandomGetKeyCounter
        /// </summary>
        /// <param name="seed">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] key(type: DtUint64).
        /// [1] counter(type: DtUint64).
        /// </returns>
        public Operation StatelessRandomGetKeyCounter(Output seed, String opName = "StatelessRandomGetKeyCounter") 
        {
            OperationDescription desc = NewOperation("StatelessRandomGetKeyCounter", opName);
            desc.AddInput(seed);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatelessRandomGetKeyCounterAlg
        /// </summary>
        /// <param name="seed">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] key(type: DtUint64).
        /// [1] counter(type: DtUint64).
        /// [2] alg(type: DtInt32).
        /// </returns>
        public Operation StatelessRandomGetKeyCounterAlg(Output seed, String opName = "StatelessRandomGetKeyCounterAlg") 
        {
            OperationDescription desc = NewOperation("StatelessRandomGetKeyCounterAlg", opName);
            desc.AddInput(seed);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatelessRandomNormal
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="seed">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StatelessRandomNormal(Output shape, Output seed, DataType? dtype = null, String opName = "StatelessRandomNormal") 
        {
            OperationDescription desc = NewOperation("StatelessRandomNormal", opName);
            desc.AddInput(shape);
            desc.AddInput(seed);
            if (dtype.HasValue)
                desc.SetAttr("dtype", dtype.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatelessRandomNormalV2
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="key">Input to the operation. </param>
        /// <param name="counter">Input to the operation. </param>
        /// <param name="alg">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StatelessRandomNormalV2(Output shape, Output key, Output counter, Output alg, DataType? dtype = null, String opName = "StatelessRandomNormalV2") 
        {
            OperationDescription desc = NewOperation("StatelessRandomNormalV2", opName);
            desc.AddInput(shape);
            desc.AddInput(key);
            desc.AddInput(counter);
            desc.AddInput(alg);
            if (dtype.HasValue)
                desc.SetAttr("dtype", dtype.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatelessRandomPoisson
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="seed">Input to the operation. </param>
        /// <param name="lam">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StatelessRandomPoisson(Output shape, Output seed, Output lam, DataType dtype, String opName = "StatelessRandomPoisson") 
        {
            OperationDescription desc = NewOperation("StatelessRandomPoisson", opName);
            desc.AddInput(shape);
            desc.AddInput(seed);
            desc.AddInput(lam);
            desc.SetAttr("dtype", dtype);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatelessRandomUniform
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="seed">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StatelessRandomUniform(Output shape, Output seed, DataType? dtype = null, String opName = "StatelessRandomUniform") 
        {
            OperationDescription desc = NewOperation("StatelessRandomUniform", opName);
            desc.AddInput(shape);
            desc.AddInput(seed);
            if (dtype.HasValue)
                desc.SetAttr("dtype", dtype.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatelessRandomUniformFullInt
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="seed">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StatelessRandomUniformFullInt(Output shape, Output seed, DataType? dtype = null, String opName = "StatelessRandomUniformFullInt") 
        {
            OperationDescription desc = NewOperation("StatelessRandomUniformFullInt", opName);
            desc.AddInput(shape);
            desc.AddInput(seed);
            if (dtype.HasValue)
                desc.SetAttr("dtype", dtype.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatelessRandomUniformFullIntV2
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="key">Input to the operation. </param>
        /// <param name="counter">Input to the operation. </param>
        /// <param name="alg">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StatelessRandomUniformFullIntV2(Output shape, Output key, Output counter, Output alg, DataType? dtype = null, String opName = "StatelessRandomUniformFullIntV2") 
        {
            OperationDescription desc = NewOperation("StatelessRandomUniformFullIntV2", opName);
            desc.AddInput(shape);
            desc.AddInput(key);
            desc.AddInput(counter);
            desc.AddInput(alg);
            if (dtype.HasValue)
                desc.SetAttr("dtype", dtype.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatelessRandomUniformInt
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="seed">Input to the operation. </param>
        /// <param name="minval">Input to the operation. </param>
        /// <param name="maxval">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StatelessRandomUniformInt(Output shape, Output seed, Output minval, Output maxval, String opName = "StatelessRandomUniformInt") 
        {
            OperationDescription desc = NewOperation("StatelessRandomUniformInt", opName);
            desc.AddInput(shape);
            desc.AddInput(seed);
            desc.AddInput(minval);
            desc.AddInput(maxval);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatelessRandomUniformIntV2
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="key">Input to the operation. </param>
        /// <param name="counter">Input to the operation. </param>
        /// <param name="alg">Input to the operation. </param>
        /// <param name="minval">Input to the operation. </param>
        /// <param name="maxval">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StatelessRandomUniformIntV2(Output shape, Output key, Output counter, Output alg, Output minval, Output maxval, String opName = "StatelessRandomUniformIntV2") 
        {
            OperationDescription desc = NewOperation("StatelessRandomUniformIntV2", opName);
            desc.AddInput(shape);
            desc.AddInput(key);
            desc.AddInput(counter);
            desc.AddInput(alg);
            desc.AddInput(minval);
            desc.AddInput(maxval);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatelessRandomUniformV2
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="key">Input to the operation. </param>
        /// <param name="counter">Input to the operation. </param>
        /// <param name="alg">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StatelessRandomUniformV2(Output shape, Output key, Output counter, Output alg, DataType? dtype = null, String opName = "StatelessRandomUniformV2") 
        {
            OperationDescription desc = NewOperation("StatelessRandomUniformV2", opName);
            desc.AddInput(shape);
            desc.AddInput(key);
            desc.AddInput(counter);
            desc.AddInput(alg);
            if (dtype.HasValue)
                desc.SetAttr("dtype", dtype.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatelessSampleDistortedBoundingBox
        /// </summary>
        /// <param name="image_size">Input to the operation. </param>
        /// <param name="bounding_boxes">Input to the operation. </param>
        /// <param name="min_object_covered">Input to the operation. </param>
        /// <param name="seed">Input to the operation. </param>
        /// <param name="aspect_ratio_range">aspect ratio range</param>
        /// <param name="area_range">area range</param>
        /// <param name="max_attempts">max attempts</param>
        /// <param name="use_image_if_no_bounding_boxes">use image if no bounding boxes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] begin(type: DtInvalid).
        /// [1] size(type: DtInvalid).
        /// [2] bboxes(type: DtFloat).
        /// </returns>
        public Operation StatelessSampleDistortedBoundingBox(Output image_size, Output bounding_boxes, Output min_object_covered, Output seed, float[] aspect_ratio_range = null, float[] area_range = null, long max_attempts = 100, bool use_image_if_no_bounding_boxes = false, String opName = "StatelessSampleDistortedBoundingBox") 
        {
            OperationDescription desc = NewOperation("StatelessSampleDistortedBoundingBox", opName);
            desc.AddInput(image_size);
            desc.AddInput(bounding_boxes);
            desc.AddInput(min_object_covered);
            desc.AddInput(seed);
            if (aspect_ratio_range != null) desc.SetAttr("aspect_ratio_range", aspect_ratio_range);
            if (area_range != null) desc.SetAttr("area_range", area_range);
            if (max_attempts != 100)
                desc.SetAttr("max_attempts", max_attempts);
            if (use_image_if_no_bounding_boxes != false)
                desc.SetAttr("use_image_if_no_bounding_boxes", use_image_if_no_bounding_boxes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatelessShuffle
        /// </summary>
        /// <param name="value">Input to the operation. </param>
        /// <param name="key">Input to the operation. </param>
        /// <param name="counter">Input to the operation. </param>
        /// <param name="alg">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StatelessShuffle(Output value, Output key, Output counter, Output alg, String opName = "StatelessShuffle") 
        {
            OperationDescription desc = NewOperation("StatelessShuffle", opName);
            desc.AddInput(value);
            desc.AddInput(key);
            desc.AddInput(counter);
            desc.AddInput(alg);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatelessTruncatedNormal
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="seed">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StatelessTruncatedNormal(Output shape, Output seed, DataType? dtype = null, String opName = "StatelessTruncatedNormal") 
        {
            OperationDescription desc = NewOperation("StatelessTruncatedNormal", opName);
            desc.AddInput(shape);
            desc.AddInput(seed);
            if (dtype.HasValue)
                desc.SetAttr("dtype", dtype.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatelessTruncatedNormalV2
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="key">Input to the operation. </param>
        /// <param name="counter">Input to the operation. </param>
        /// <param name="alg">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StatelessTruncatedNormalV2(Output shape, Output key, Output counter, Output alg, DataType? dtype = null, String opName = "StatelessTruncatedNormalV2") 
        {
            OperationDescription desc = NewOperation("StatelessTruncatedNormalV2", opName);
            desc.AddInput(shape);
            desc.AddInput(key);
            desc.AddInput(counter);
            desc.AddInput(alg);
            if (dtype.HasValue)
                desc.SetAttr("dtype", dtype.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatelessWhile
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="parallel_iterations">parallel iterations</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        // The following attributes are not known: cond: func; body: func
        public Operation StatelessWhile(Output input, long[][] output_shapes = null, long parallel_iterations = 10, String opName = "StatelessWhile") 
        {
            OperationDescription desc = NewOperation("StatelessWhile", opName);
            desc.AddInput(input);
            if (output_shapes != null) desc.SetAttrShapeList("output_shapes", output_shapes);
            if (parallel_iterations != 10)
                desc.SetAttr("parallel_iterations", parallel_iterations);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StaticRegexFullMatch
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="pattern">pattern</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtBool).
        /// </returns>
        public Operation StaticRegexFullMatch(Output input, string pattern, String opName = "StaticRegexFullMatch") 
        {
            OperationDescription desc = NewOperation("StaticRegexFullMatch", opName);
            desc.AddInput(input);
            desc.SetAttr("pattern", pattern);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StaticRegexReplace
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="pattern">pattern</param>
        /// <param name="rewrite">rewrite</param>
        /// <param name="replace_global">replace global</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtString).
        /// </returns>
        public Operation StaticRegexReplace(Output input, string pattern, string rewrite, bool replace_global = true, String opName = "StaticRegexReplace") 
        {
            OperationDescription desc = NewOperation("StaticRegexReplace", opName);
            desc.AddInput(input);
            desc.SetAttr("pattern", pattern);
            desc.SetAttr("rewrite", rewrite);
            if (replace_global != true)
                desc.SetAttr("replace_global", replace_global);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatsAggregatorHandle
        /// </summary>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// </returns>
        public Operation StatsAggregatorHandle(string container = null, string shared_name = null, String opName = "StatsAggregatorHandle") 
        {
            OperationDescription desc = NewOperation("StatsAggregatorHandle", opName);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatsAggregatorHandleV2
        /// </summary>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// </returns>
        public Operation StatsAggregatorHandleV2(string container = null, string shared_name = null, String opName = "StatsAggregatorHandleV2") 
        {
            OperationDescription desc = NewOperation("StatsAggregatorHandleV2", opName);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatsAggregatorSetSummaryWriter
        /// </summary>
        /// <param name="stats_aggregator">Input to the operation. </param>
        /// <param name="summary">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation StatsAggregatorSetSummaryWriter(Output stats_aggregator, Output summary, String opName = "StatsAggregatorSetSummaryWriter") 
        {
            OperationDescription desc = NewOperation("StatsAggregatorSetSummaryWriter", opName);
            desc.AddInput(stats_aggregator);
            desc.AddInput(summary);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StatsAggregatorSummary
        /// </summary>
        /// <param name="iterator">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] summary(type: DtString).
        /// </returns>
        public Operation StatsAggregatorSummary(Output iterator, String opName = "StatsAggregatorSummary") 
        {
            OperationDescription desc = NewOperation("StatsAggregatorSummary", opName);
            desc.AddInput(iterator);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StochasticCastToInt
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="key">Input to the operation. </param>
        /// <param name="counter">Input to the operation. </param>
        /// <param name="alg">Input to the operation. </param>
        /// <param name="Tout">Tout</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StochasticCastToInt(Output input, Output key, Output counter, Output alg, DataType Tout, String opName = "StochasticCastToInt") 
        {
            OperationDescription desc = NewOperation("StochasticCastToInt", opName);
            desc.AddInput(input);
            desc.AddInput(key);
            desc.AddInput(counter);
            desc.AddInput(alg);
            desc.SetAttr("Tout", Tout);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StopGradient
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StopGradient(Output input, String opName = "StopGradient") 
        {
            OperationDescription desc = NewOperation("StopGradient", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StoreMinibatchStatisticsInFdo
        /// </summary>
        /// <param name="program_key">Input to the operation. </param>
        /// <param name="max_ids">Input to the operation. </param>
        /// <param name="max_uniques">Input to the operation. </param>
        /// <param name="sample_count">sample count</param>
        /// <param name="num_replica">num replica</param>
        /// <param name="feature_width">feature width</param>
        /// <param name="num_sc_per_chip">num sc per chip</param>
        /// <param name="table_name">table name</param>
        /// <param name="mini_batch_splits">mini batch splits</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation StoreMinibatchStatisticsInFdo(Output program_key, Output max_ids, Output max_uniques, long sample_count, long num_replica, long feature_width, long num_sc_per_chip, string table_name, string mini_batch_splits, String opName = "StoreMinibatchStatisticsInFdo") 
        {
            OperationDescription desc = NewOperation("StoreMinibatchStatisticsInFdo", opName);
            desc.AddInput(program_key);
            desc.AddInput(max_ids);
            desc.AddInput(max_uniques);
            desc.SetAttr("sample_count", sample_count);
            desc.SetAttr("num_replica", num_replica);
            desc.SetAttr("feature_width", feature_width);
            desc.SetAttr("num_sc_per_chip", num_sc_per_chip);
            desc.SetAttr("table_name", table_name);
            desc.SetAttr("mini_batch_splits", mini_batch_splits);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StridedSlice
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="begin">Input to the operation. </param>
        /// <param name="end">Input to the operation. </param>
        /// <param name="strides">Input to the operation. </param>
        /// <param name="begin_mask">begin mask</param>
        /// <param name="end_mask">end mask</param>
        /// <param name="ellipsis_mask">ellipsis mask</param>
        /// <param name="new_axis_mask">new axis mask</param>
        /// <param name="shrink_axis_mask">shrink axis mask</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StridedSlice(Output input, Output begin, Output end, Output strides, long begin_mask = 0, long end_mask = 0, long ellipsis_mask = 0, long new_axis_mask = 0, long shrink_axis_mask = 0, String opName = "StridedSlice") 
        {
            OperationDescription desc = NewOperation("StridedSlice", opName);
            desc.AddInput(input);
            desc.AddInput(begin);
            desc.AddInput(end);
            desc.AddInput(strides);
            if (begin_mask != 0)
                desc.SetAttr("begin_mask", begin_mask);
            if (end_mask != 0)
                desc.SetAttr("end_mask", end_mask);
            if (ellipsis_mask != 0)
                desc.SetAttr("ellipsis_mask", ellipsis_mask);
            if (new_axis_mask != 0)
                desc.SetAttr("new_axis_mask", new_axis_mask);
            if (shrink_axis_mask != 0)
                desc.SetAttr("shrink_axis_mask", shrink_axis_mask);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StridedSliceAssign
        /// </summary>
        /// <param name="reference">Input to the operation. </param>
        /// <param name="begin">Input to the operation. </param>
        /// <param name="end">Input to the operation. </param>
        /// <param name="strides">Input to the operation. </param>
        /// <param name="value">Input to the operation. </param>
        /// <param name="begin_mask">begin mask</param>
        /// <param name="end_mask">end mask</param>
        /// <param name="ellipsis_mask">ellipsis mask</param>
        /// <param name="new_axis_mask">new axis mask</param>
        /// <param name="shrink_axis_mask">shrink axis mask</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_ref(type: DtInvalid).
        /// </returns>
        public Operation StridedSliceAssign(Output reference, Output begin, Output end, Output strides, Output value, long begin_mask = 0, long end_mask = 0, long ellipsis_mask = 0, long new_axis_mask = 0, long shrink_axis_mask = 0, String opName = "StridedSliceAssign") 
        {
            OperationDescription desc = NewOperation("StridedSliceAssign", opName);
            desc.AddInput(reference);
            desc.AddInput(begin);
            desc.AddInput(end);
            desc.AddInput(strides);
            desc.AddInput(value);
            if (begin_mask != 0)
                desc.SetAttr("begin_mask", begin_mask);
            if (end_mask != 0)
                desc.SetAttr("end_mask", end_mask);
            if (ellipsis_mask != 0)
                desc.SetAttr("ellipsis_mask", ellipsis_mask);
            if (new_axis_mask != 0)
                desc.SetAttr("new_axis_mask", new_axis_mask);
            if (shrink_axis_mask != 0)
                desc.SetAttr("shrink_axis_mask", shrink_axis_mask);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StridedSliceGrad
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="begin">Input to the operation. </param>
        /// <param name="end">Input to the operation. </param>
        /// <param name="strides">Input to the operation. </param>
        /// <param name="dy">Input to the operation. </param>
        /// <param name="begin_mask">begin mask</param>
        /// <param name="end_mask">end mask</param>
        /// <param name="ellipsis_mask">ellipsis mask</param>
        /// <param name="new_axis_mask">new axis mask</param>
        /// <param name="shrink_axis_mask">shrink axis mask</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StridedSliceGrad(Output shape, Output begin, Output end, Output strides, Output dy, long begin_mask = 0, long end_mask = 0, long ellipsis_mask = 0, long new_axis_mask = 0, long shrink_axis_mask = 0, String opName = "StridedSliceGrad") 
        {
            OperationDescription desc = NewOperation("StridedSliceGrad", opName);
            desc.AddInput(shape);
            desc.AddInput(begin);
            desc.AddInput(end);
            desc.AddInput(strides);
            desc.AddInput(dy);
            if (begin_mask != 0)
                desc.SetAttr("begin_mask", begin_mask);
            if (end_mask != 0)
                desc.SetAttr("end_mask", end_mask);
            if (ellipsis_mask != 0)
                desc.SetAttr("ellipsis_mask", ellipsis_mask);
            if (new_axis_mask != 0)
                desc.SetAttr("new_axis_mask", new_axis_mask);
            if (shrink_axis_mask != 0)
                desc.SetAttr("shrink_axis_mask", shrink_axis_mask);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StringFormat
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="template">template</param>
        /// <param name="placeholder">placeholder</param>
        /// <param name="summarize">summarize</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtString).
        /// </returns>
        public Operation StringFormat(Output inputs, string template = null, string placeholder = null, long summarize = 3, String opName = "StringFormat") 
        {
            OperationDescription desc = NewOperation("StringFormat", opName);
            desc.AddInput(inputs);
            if (template != null)
                 desc.SetAttr("template", template);
            if (placeholder != null)
                 desc.SetAttr("placeholder", placeholder);
            if (summarize != 3)
                desc.SetAttr("summarize", summarize);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StringJoin
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="separator">separator</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtString).
        /// </returns>
        public Operation StringJoin(Output inputs, string separator = null, String opName = "StringJoin") 
        {
            OperationDescription desc = NewOperation("StringJoin", opName);
            desc.AddInput(inputs);
            if (separator != null)
                 desc.SetAttr("separator", separator);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StringLength
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="unit">unit</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInt32).
        /// </returns>
        public Operation StringLength(Output input, string unit = null, String opName = "StringLength") 
        {
            OperationDescription desc = NewOperation("StringLength", opName);
            desc.AddInput(input);
            if (unit != null)
                 desc.SetAttr("unit", unit);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StringLower
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="encoding">encoding</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtString).
        /// </returns>
        public Operation StringLower(Output input, string encoding = null, String opName = "StringLower") 
        {
            OperationDescription desc = NewOperation("StringLower", opName);
            desc.AddInput(input);
            if (encoding != null)
                 desc.SetAttr("encoding", encoding);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StringNGrams
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="data_splits">Input to the operation. </param>
        /// <param name="separator">separator</param>
        /// <param name="ngram_widths">ngram widths</param>
        /// <param name="left_pad">left pad</param>
        /// <param name="right_pad">right pad</param>
        /// <param name="pad_width">pad width</param>
        /// <param name="preserve_short_sequences">preserve short sequences</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] ngrams(type: DtString).
        /// [1] ngrams_splits(type: DtInvalid).
        /// </returns>
        public Operation StringNGrams(Output data, Output data_splits, string separator, long[] ngram_widths, string left_pad, string right_pad, long pad_width, bool preserve_short_sequences, String opName = "StringNGrams") 
        {
            OperationDescription desc = NewOperation("StringNGrams", opName);
            desc.AddInput(data);
            desc.AddInput(data_splits);
            desc.SetAttr("separator", separator);
            desc.SetAttr("ngram_widths", ngram_widths);
            desc.SetAttr("left_pad", left_pad);
            desc.SetAttr("right_pad", right_pad);
            desc.SetAttr("pad_width", pad_width);
            desc.SetAttr("preserve_short_sequences", preserve_short_sequences);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StringSplit
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="delimiter">Input to the operation. </param>
        /// <param name="skip_empty">skip empty</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] indices(type: DtInt64).
        /// [1] values(type: DtString).
        /// [2] shape(type: DtInt64).
        /// </returns>
        public Operation StringSplit(Output input, Output delimiter, bool skip_empty = true, String opName = "StringSplit") 
        {
            OperationDescription desc = NewOperation("StringSplit", opName);
            desc.AddInput(input);
            desc.AddInput(delimiter);
            if (skip_empty != true)
                desc.SetAttr("skip_empty", skip_empty);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StringSplitV2
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="sep">Input to the operation. </param>
        /// <param name="maxsplit">maxsplit</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] indices(type: DtInt64).
        /// [1] values(type: DtString).
        /// [2] shape(type: DtInt64).
        /// </returns>
        public Operation StringSplitV2(Output input, Output sep, long maxsplit = -1, String opName = "StringSplitV2") 
        {
            OperationDescription desc = NewOperation("StringSplitV2", opName);
            desc.AddInput(input);
            desc.AddInput(sep);
            if (maxsplit != -1)
                desc.SetAttr("maxsplit", maxsplit);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StringStrip
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtString).
        /// </returns>
        public Operation StringStrip(Output input, String opName = "StringStrip") 
        {
            OperationDescription desc = NewOperation("StringStrip", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StringToHashBucket
        /// </summary>
        /// <param name="string_tensor">Input to the operation. </param>
        /// <param name="num_buckets">num buckets</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInt64).
        /// </returns>
        public Operation StringToHashBucket(Output string_tensor, long num_buckets, String opName = "StringToHashBucket") 
        {
            OperationDescription desc = NewOperation("StringToHashBucket", opName);
            desc.AddInput(string_tensor);
            desc.SetAttr("num_buckets", num_buckets);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StringToHashBucketFast
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="num_buckets">num buckets</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInt64).
        /// </returns>
        public Operation StringToHashBucketFast(Output input, long num_buckets, String opName = "StringToHashBucketFast") 
        {
            OperationDescription desc = NewOperation("StringToHashBucketFast", opName);
            desc.AddInput(input);
            desc.SetAttr("num_buckets", num_buckets);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StringToHashBucketStrong
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="num_buckets">num buckets</param>
        /// <param name="key">key</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInt64).
        /// </returns>
        public Operation StringToHashBucketStrong(Output input, long num_buckets, long[] key, String opName = "StringToHashBucketStrong") 
        {
            OperationDescription desc = NewOperation("StringToHashBucketStrong", opName);
            desc.AddInput(input);
            desc.SetAttr("num_buckets", num_buckets);
            desc.SetAttr("key", key);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StringToNumber
        /// </summary>
        /// <param name="string_tensor">Input to the operation. </param>
        /// <param name="out_type">out type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation StringToNumber(Output string_tensor, DataType? out_type = null, String opName = "StringToNumber") 
        {
            OperationDescription desc = NewOperation("StringToNumber", opName);
            desc.AddInput(string_tensor);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// StringUpper
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="encoding">encoding</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtString).
        /// </returns>
        public Operation StringUpper(Output input, string encoding = null, String opName = "StringUpper") 
        {
            OperationDescription desc = NewOperation("StringUpper", opName);
            desc.AddInput(input);
            if (encoding != null)
                 desc.SetAttr("encoding", encoding);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Sub
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation Sub(Output x, Output y, String opName = "Sub") 
        {
            OperationDescription desc = NewOperation("Sub", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Substr
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="pos">Input to the operation. </param>
        /// <param name="len">Input to the operation. </param>
        /// <param name="unit">unit</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtString).
        /// </returns>
        public Operation Substr(Output input, Output pos, Output len, string unit = null, String opName = "Substr") 
        {
            OperationDescription desc = NewOperation("Substr", opName);
            desc.AddInput(input);
            desc.AddInput(pos);
            desc.AddInput(len);
            if (unit != null)
                 desc.SetAttr("unit", unit);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Sum
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="reduction_indices">Input to the operation. </param>
        /// <param name="keep_dims">keep dims</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Sum(Output input, Output reduction_indices, bool keep_dims = false, String opName = "Sum") 
        {
            OperationDescription desc = NewOperation("Sum", opName);
            desc.AddInput(input);
            desc.AddInput(reduction_indices);
            if (keep_dims != false)
                desc.SetAttr("keep_dims", keep_dims);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SummaryWriter
        /// </summary>
        /// <param name="shared_name">shared name</param>
        /// <param name="container">container</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] writer(type: DtResource).
        /// </returns>
        public Operation SummaryWriter(string shared_name = null, string container = null, String opName = "SummaryWriter") 
        {
            OperationDescription desc = NewOperation("SummaryWriter", opName);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            if (container != null)
                 desc.SetAttr("container", container);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Svd
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="compute_uv">compute uv</param>
        /// <param name="full_matrices">full matrices</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] s(type: DtInvalid).
        /// [1] u(type: DtInvalid).
        /// [2] v(type: DtInvalid).
        /// </returns>
        public Operation Svd(Output input, bool compute_uv = true, bool full_matrices = false, String opName = "Svd") 
        {
            OperationDescription desc = NewOperation("Svd", opName);
            desc.AddInput(input);
            if (compute_uv != true)
                desc.SetAttr("compute_uv", compute_uv);
            if (full_matrices != false)
                desc.SetAttr("full_matrices", full_matrices);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Switch
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="pred">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_false(type: DtInvalid).
        /// [1] output_true(type: DtInvalid).
        /// </returns>
        public Operation Switch(Output data, Output pred, String opName = "Switch") 
        {
            OperationDescription desc = NewOperation("Switch", opName);
            desc.AddInput(data);
            desc.AddInput(pred);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SymbolicGradient
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="Tout">Tout</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        // The following attributes are not known: f: func
        public Operation SymbolicGradient(Output input, DataType[] Tout, String opName = "SymbolicGradient") 
        {
            OperationDescription desc = NewOperation("SymbolicGradient", opName);
            desc.AddInput(input);
            desc.SetAttr("Tout", Tout);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// SyncDevice
        /// </summary>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation SyncDevice(String opName = "SyncDevice") 
        {
            OperationDescription desc = NewOperation("SyncDevice", opName);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TakeDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="count">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation TakeDataset(Output input_dataset, Output count, DataType[] output_types, long[][] output_shapes, string metadata = null, String opName = "TakeDataset") 
        {
            OperationDescription desc = NewOperation("TakeDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(count);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TakeManySparseFromTensorsMap
        /// </summary>
        /// <param name="sparse_handles">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] sparse_indices(type: DtInt64).
        /// [1] sparse_values(type: DtInvalid).
        /// [2] sparse_shape(type: DtInt64).
        /// </returns>
        public Operation TakeManySparseFromTensorsMap(Output sparse_handles, DataType dtype, string container = null, string shared_name = null, String opName = "TakeManySparseFromTensorsMap") 
        {
            OperationDescription desc = NewOperation("TakeManySparseFromTensorsMap", opName);
            desc.AddInput(sparse_handles);
            desc.SetAttr("dtype", dtype);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TakeWhileDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="other_arguments">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        // The following attributes are not known: predicate: func
        public Operation TakeWhileDataset(Output input_dataset, Output other_arguments, DataType[] output_types, long[][] output_shapes, string metadata = null, String opName = "TakeWhileDataset") 
        {
            OperationDescription desc = NewOperation("TakeWhileDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(other_arguments);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Tan
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Tan(Output x, String opName = "Tan") 
        {
            OperationDescription desc = NewOperation("Tan", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Tanh
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Tanh(Output x, String opName = "Tanh") 
        {
            OperationDescription desc = NewOperation("Tanh", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TanhGrad
        /// </summary>
        /// <param name="y">Input to the operation. </param>
        /// <param name="dy">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation TanhGrad(Output y, Output dy, String opName = "TanhGrad") 
        {
            OperationDescription desc = NewOperation("TanhGrad", opName);
            desc.AddInput(y);
            desc.AddInput(dy);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TemporaryVariable
        /// </summary>
        /// <param name="shape">shape</param>
        /// <param name="dtype">dtype</param>
        /// <param name="var_name">var name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] ref(type: DtInvalid).
        /// </returns>
        public Operation TemporaryVariable(long[] shape, DataType dtype, string var_name = null, String opName = "TemporaryVariable") 
        {
            OperationDescription desc = NewOperation("TemporaryVariable", opName);
            desc.SetAttrShape("shape", shape);
            desc.SetAttr("dtype", dtype);
            if (var_name != null)
                 desc.SetAttr("var_name", var_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArray
        /// </summary>
        /// <param name="size">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="dynamic_size">dynamic size</param>
        /// <param name="clear_after_read">clear after read</param>
        /// <param name="tensor_array_name">tensor array name</param>
        /// <param name="element_shape">element shape</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtString).
        /// </returns>
        public Operation TensorArray(Output size, DataType dtype, bool dynamic_size = false, bool clear_after_read = true, string tensor_array_name = null, long[] element_shape = null, String opName = "TensorArray") 
        {
            OperationDescription desc = NewOperation("TensorArray", opName);
            desc.AddInput(size);
            desc.SetAttr("dtype", dtype);
            if (dynamic_size != false)
                desc.SetAttr("dynamic_size", dynamic_size);
            if (clear_after_read != true)
                desc.SetAttr("clear_after_read", clear_after_read);
            if (tensor_array_name != null)
                 desc.SetAttr("tensor_array_name", tensor_array_name);
            if (element_shape != null)
                 desc.SetAttrShape("element_shape", element_shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArrayClose
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation TensorArrayClose(Output handle, String opName = "TensorArrayClose") 
        {
            OperationDescription desc = NewOperation("TensorArrayClose", opName);
            desc.AddInput(handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArrayCloseV2
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation TensorArrayCloseV2(Output handle, String opName = "TensorArrayCloseV2") 
        {
            OperationDescription desc = NewOperation("TensorArrayCloseV2", opName);
            desc.AddInput(handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArrayCloseV3
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation TensorArrayCloseV3(Output handle, String opName = "TensorArrayCloseV3") 
        {
            OperationDescription desc = NewOperation("TensorArrayCloseV3", opName);
            desc.AddInput(handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArrayConcat
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="flow_in">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="element_shape_except0">element shape except0</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] value(type: DtInvalid).
        /// [1] lengths(type: DtInt64).
        /// </returns>
        public Operation TensorArrayConcat(Output handle, Output flow_in, DataType dtype, long[] element_shape_except0 = null, String opName = "TensorArrayConcat") 
        {
            OperationDescription desc = NewOperation("TensorArrayConcat", opName);
            desc.AddInput(handle);
            desc.AddInput(flow_in);
            desc.SetAttr("dtype", dtype);
            if (element_shape_except0 != null)
                 desc.SetAttrShape("element_shape_except0", element_shape_except0);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArrayConcatV2
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="flow_in">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="element_shape_except0">element shape except0</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] value(type: DtInvalid).
        /// [1] lengths(type: DtInt64).
        /// </returns>
        public Operation TensorArrayConcatV2(Output handle, Output flow_in, DataType dtype, long[] element_shape_except0 = null, String opName = "TensorArrayConcatV2") 
        {
            OperationDescription desc = NewOperation("TensorArrayConcatV2", opName);
            desc.AddInput(handle);
            desc.AddInput(flow_in);
            desc.SetAttr("dtype", dtype);
            if (element_shape_except0 != null)
                 desc.SetAttrShape("element_shape_except0", element_shape_except0);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArrayConcatV3
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="flow_in">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="element_shape_except0">element shape except0</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] value(type: DtInvalid).
        /// [1] lengths(type: DtInt64).
        /// </returns>
        public Operation TensorArrayConcatV3(Output handle, Output flow_in, DataType dtype, long[] element_shape_except0 = null, String opName = "TensorArrayConcatV3") 
        {
            OperationDescription desc = NewOperation("TensorArrayConcatV3", opName);
            desc.AddInput(handle);
            desc.AddInput(flow_in);
            desc.SetAttr("dtype", dtype);
            if (element_shape_except0 != null)
                 desc.SetAttrShape("element_shape_except0", element_shape_except0);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArrayGather
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="flow_in">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="element_shape">element shape</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] value(type: DtInvalid).
        /// </returns>
        public Operation TensorArrayGather(Output handle, Output indices, Output flow_in, DataType dtype, long[] element_shape = null, String opName = "TensorArrayGather") 
        {
            OperationDescription desc = NewOperation("TensorArrayGather", opName);
            desc.AddInput(handle);
            desc.AddInput(indices);
            desc.AddInput(flow_in);
            desc.SetAttr("dtype", dtype);
            if (element_shape != null)
                 desc.SetAttrShape("element_shape", element_shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArrayGatherV2
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="flow_in">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="element_shape">element shape</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] value(type: DtInvalid).
        /// </returns>
        public Operation TensorArrayGatherV2(Output handle, Output indices, Output flow_in, DataType dtype, long[] element_shape = null, String opName = "TensorArrayGatherV2") 
        {
            OperationDescription desc = NewOperation("TensorArrayGatherV2", opName);
            desc.AddInput(handle);
            desc.AddInput(indices);
            desc.AddInput(flow_in);
            desc.SetAttr("dtype", dtype);
            if (element_shape != null)
                 desc.SetAttrShape("element_shape", element_shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArrayGatherV3
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="flow_in">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="element_shape">element shape</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] value(type: DtInvalid).
        /// </returns>
        public Operation TensorArrayGatherV3(Output handle, Output indices, Output flow_in, DataType dtype, long[] element_shape = null, String opName = "TensorArrayGatherV3") 
        {
            OperationDescription desc = NewOperation("TensorArrayGatherV3", opName);
            desc.AddInput(handle);
            desc.AddInput(indices);
            desc.AddInput(flow_in);
            desc.SetAttr("dtype", dtype);
            if (element_shape != null)
                 desc.SetAttrShape("element_shape", element_shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArrayGrad
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="flow_in">Input to the operation. </param>
        /// <param name="source">source</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] grad_handle(type: DtString).
        /// </returns>
        public Operation TensorArrayGrad(Output handle, Output flow_in, string source, String opName = "TensorArrayGrad") 
        {
            OperationDescription desc = NewOperation("TensorArrayGrad", opName);
            desc.AddInput(handle);
            desc.AddInput(flow_in);
            desc.SetAttr("source", source);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArrayGradV2
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="flow_in">Input to the operation. </param>
        /// <param name="source">source</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] grad_handle(type: DtString).
        /// </returns>
        public Operation TensorArrayGradV2(Output handle, Output flow_in, string source, String opName = "TensorArrayGradV2") 
        {
            OperationDescription desc = NewOperation("TensorArrayGradV2", opName);
            desc.AddInput(handle);
            desc.AddInput(flow_in);
            desc.SetAttr("source", source);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArrayGradV3
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="flow_in">Input to the operation. </param>
        /// <param name="source">source</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] grad_handle(type: DtResource).
        /// [1] flow_out(type: DtFloat).
        /// </returns>
        public Operation TensorArrayGradV3(Output handle, Output flow_in, string source, String opName = "TensorArrayGradV3") 
        {
            OperationDescription desc = NewOperation("TensorArrayGradV3", opName);
            desc.AddInput(handle);
            desc.AddInput(flow_in);
            desc.SetAttr("source", source);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArrayGradWithShape
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="flow_in">Input to the operation. </param>
        /// <param name="shape_to_prepend">Input to the operation. </param>
        /// <param name="source">source</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] grad_handle(type: DtResource).
        /// [1] flow_out(type: DtFloat).
        /// </returns>
        public Operation TensorArrayGradWithShape(Output handle, Output flow_in, Output shape_to_prepend, string source, String opName = "TensorArrayGradWithShape") 
        {
            OperationDescription desc = NewOperation("TensorArrayGradWithShape", opName);
            desc.AddInput(handle);
            desc.AddInput(flow_in);
            desc.AddInput(shape_to_prepend);
            desc.SetAttr("source", source);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArrayPack
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="flow_in">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="element_shape">element shape</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] value(type: DtInvalid).
        /// </returns>
        public Operation TensorArrayPack(Output handle, Output flow_in, DataType dtype, long[] element_shape = null, String opName = "TensorArrayPack") 
        {
            OperationDescription desc = NewOperation("TensorArrayPack", opName);
            desc.AddInput(handle);
            desc.AddInput(flow_in);
            desc.SetAttr("dtype", dtype);
            if (element_shape != null)
                 desc.SetAttrShape("element_shape", element_shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArrayRead
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="index">Input to the operation. </param>
        /// <param name="flow_in">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] value(type: DtInvalid).
        /// </returns>
        public Operation TensorArrayRead(Output handle, Output index, Output flow_in, DataType dtype, String opName = "TensorArrayRead") 
        {
            OperationDescription desc = NewOperation("TensorArrayRead", opName);
            desc.AddInput(handle);
            desc.AddInput(index);
            desc.AddInput(flow_in);
            desc.SetAttr("dtype", dtype);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArrayReadV2
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="index">Input to the operation. </param>
        /// <param name="flow_in">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] value(type: DtInvalid).
        /// </returns>
        public Operation TensorArrayReadV2(Output handle, Output index, Output flow_in, DataType dtype, String opName = "TensorArrayReadV2") 
        {
            OperationDescription desc = NewOperation("TensorArrayReadV2", opName);
            desc.AddInput(handle);
            desc.AddInput(index);
            desc.AddInput(flow_in);
            desc.SetAttr("dtype", dtype);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArrayReadV3
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="index">Input to the operation. </param>
        /// <param name="flow_in">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] value(type: DtInvalid).
        /// </returns>
        public Operation TensorArrayReadV3(Output handle, Output index, Output flow_in, DataType dtype, String opName = "TensorArrayReadV3") 
        {
            OperationDescription desc = NewOperation("TensorArrayReadV3", opName);
            desc.AddInput(handle);
            desc.AddInput(index);
            desc.AddInput(flow_in);
            desc.SetAttr("dtype", dtype);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArrayScatter
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="value">Input to the operation. </param>
        /// <param name="flow_in">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] flow_out(type: DtFloat).
        /// </returns>
        public Operation TensorArrayScatter(Output handle, Output indices, Output value, Output flow_in, String opName = "TensorArrayScatter") 
        {
            OperationDescription desc = NewOperation("TensorArrayScatter", opName);
            desc.AddInput(handle);
            desc.AddInput(indices);
            desc.AddInput(value);
            desc.AddInput(flow_in);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArrayScatterV2
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="value">Input to the operation. </param>
        /// <param name="flow_in">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] flow_out(type: DtFloat).
        /// </returns>
        public Operation TensorArrayScatterV2(Output handle, Output indices, Output value, Output flow_in, String opName = "TensorArrayScatterV2") 
        {
            OperationDescription desc = NewOperation("TensorArrayScatterV2", opName);
            desc.AddInput(handle);
            desc.AddInput(indices);
            desc.AddInput(value);
            desc.AddInput(flow_in);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArrayScatterV3
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="value">Input to the operation. </param>
        /// <param name="flow_in">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] flow_out(type: DtFloat).
        /// </returns>
        public Operation TensorArrayScatterV3(Output handle, Output indices, Output value, Output flow_in, String opName = "TensorArrayScatterV3") 
        {
            OperationDescription desc = NewOperation("TensorArrayScatterV3", opName);
            desc.AddInput(handle);
            desc.AddInput(indices);
            desc.AddInput(value);
            desc.AddInput(flow_in);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArraySize
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="flow_in">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] size(type: DtInt32).
        /// </returns>
        public Operation TensorArraySize(Output handle, Output flow_in, String opName = "TensorArraySize") 
        {
            OperationDescription desc = NewOperation("TensorArraySize", opName);
            desc.AddInput(handle);
            desc.AddInput(flow_in);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArraySizeV2
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="flow_in">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] size(type: DtInt32).
        /// </returns>
        public Operation TensorArraySizeV2(Output handle, Output flow_in, String opName = "TensorArraySizeV2") 
        {
            OperationDescription desc = NewOperation("TensorArraySizeV2", opName);
            desc.AddInput(handle);
            desc.AddInput(flow_in);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArraySizeV3
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="flow_in">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] size(type: DtInt32).
        /// </returns>
        public Operation TensorArraySizeV3(Output handle, Output flow_in, String opName = "TensorArraySizeV3") 
        {
            OperationDescription desc = NewOperation("TensorArraySizeV3", opName);
            desc.AddInput(handle);
            desc.AddInput(flow_in);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArraySplit
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="value">Input to the operation. </param>
        /// <param name="lengths">Input to the operation. </param>
        /// <param name="flow_in">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] flow_out(type: DtFloat).
        /// </returns>
        public Operation TensorArraySplit(Output handle, Output value, Output lengths, Output flow_in, String opName = "TensorArraySplit") 
        {
            OperationDescription desc = NewOperation("TensorArraySplit", opName);
            desc.AddInput(handle);
            desc.AddInput(value);
            desc.AddInput(lengths);
            desc.AddInput(flow_in);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArraySplitV2
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="value">Input to the operation. </param>
        /// <param name="lengths">Input to the operation. </param>
        /// <param name="flow_in">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] flow_out(type: DtFloat).
        /// </returns>
        public Operation TensorArraySplitV2(Output handle, Output value, Output lengths, Output flow_in, String opName = "TensorArraySplitV2") 
        {
            OperationDescription desc = NewOperation("TensorArraySplitV2", opName);
            desc.AddInput(handle);
            desc.AddInput(value);
            desc.AddInput(lengths);
            desc.AddInput(flow_in);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArraySplitV3
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="value">Input to the operation. </param>
        /// <param name="lengths">Input to the operation. </param>
        /// <param name="flow_in">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] flow_out(type: DtFloat).
        /// </returns>
        public Operation TensorArraySplitV3(Output handle, Output value, Output lengths, Output flow_in, String opName = "TensorArraySplitV3") 
        {
            OperationDescription desc = NewOperation("TensorArraySplitV3", opName);
            desc.AddInput(handle);
            desc.AddInput(value);
            desc.AddInput(lengths);
            desc.AddInput(flow_in);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArrayUnpack
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="value">Input to the operation. </param>
        /// <param name="flow_in">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] flow_out(type: DtFloat).
        /// </returns>
        public Operation TensorArrayUnpack(Output handle, Output value, Output flow_in, String opName = "TensorArrayUnpack") 
        {
            OperationDescription desc = NewOperation("TensorArrayUnpack", opName);
            desc.AddInput(handle);
            desc.AddInput(value);
            desc.AddInput(flow_in);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArrayV2
        /// </summary>
        /// <param name="size">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="element_shape">element shape</param>
        /// <param name="dynamic_size">dynamic size</param>
        /// <param name="clear_after_read">clear after read</param>
        /// <param name="tensor_array_name">tensor array name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtString).
        /// </returns>
        public Operation TensorArrayV2(Output size, DataType dtype, long[] element_shape = null, bool dynamic_size = false, bool clear_after_read = true, string tensor_array_name = null, String opName = "TensorArrayV2") 
        {
            OperationDescription desc = NewOperation("TensorArrayV2", opName);
            desc.AddInput(size);
            desc.SetAttr("dtype", dtype);
            if (element_shape != null)
                 desc.SetAttrShape("element_shape", element_shape);
            if (dynamic_size != false)
                desc.SetAttr("dynamic_size", dynamic_size);
            if (clear_after_read != true)
                desc.SetAttr("clear_after_read", clear_after_read);
            if (tensor_array_name != null)
                 desc.SetAttr("tensor_array_name", tensor_array_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArrayV3
        /// </summary>
        /// <param name="size">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="element_shape">element shape</param>
        /// <param name="dynamic_size">dynamic size</param>
        /// <param name="clear_after_read">clear after read</param>
        /// <param name="identical_element_shapes">identical element shapes</param>
        /// <param name="tensor_array_name">tensor array name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// [1] flow(type: DtFloat).
        /// </returns>
        public Operation TensorArrayV3(Output size, DataType dtype, long[] element_shape = null, bool dynamic_size = false, bool clear_after_read = true, bool identical_element_shapes = false, string tensor_array_name = null, String opName = "TensorArrayV3") 
        {
            OperationDescription desc = NewOperation("TensorArrayV3", opName);
            desc.AddInput(size);
            desc.SetAttr("dtype", dtype);
            if (element_shape != null)
                 desc.SetAttrShape("element_shape", element_shape);
            if (dynamic_size != false)
                desc.SetAttr("dynamic_size", dynamic_size);
            if (clear_after_read != true)
                desc.SetAttr("clear_after_read", clear_after_read);
            if (identical_element_shapes != false)
                desc.SetAttr("identical_element_shapes", identical_element_shapes);
            if (tensor_array_name != null)
                 desc.SetAttr("tensor_array_name", tensor_array_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArrayWrite
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="index">Input to the operation. </param>
        /// <param name="value">Input to the operation. </param>
        /// <param name="flow_in">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] flow_out(type: DtFloat).
        /// </returns>
        public Operation TensorArrayWrite(Output handle, Output index, Output value, Output flow_in, String opName = "TensorArrayWrite") 
        {
            OperationDescription desc = NewOperation("TensorArrayWrite", opName);
            desc.AddInput(handle);
            desc.AddInput(index);
            desc.AddInput(value);
            desc.AddInput(flow_in);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArrayWriteV2
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="index">Input to the operation. </param>
        /// <param name="value">Input to the operation. </param>
        /// <param name="flow_in">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] flow_out(type: DtFloat).
        /// </returns>
        public Operation TensorArrayWriteV2(Output handle, Output index, Output value, Output flow_in, String opName = "TensorArrayWriteV2") 
        {
            OperationDescription desc = NewOperation("TensorArrayWriteV2", opName);
            desc.AddInput(handle);
            desc.AddInput(index);
            desc.AddInput(value);
            desc.AddInput(flow_in);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorArrayWriteV3
        /// </summary>
        /// <param name="handle">Input to the operation. </param>
        /// <param name="index">Input to the operation. </param>
        /// <param name="value">Input to the operation. </param>
        /// <param name="flow_in">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] flow_out(type: DtFloat).
        /// </returns>
        public Operation TensorArrayWriteV3(Output handle, Output index, Output value, Output flow_in, String opName = "TensorArrayWriteV3") 
        {
            OperationDescription desc = NewOperation("TensorArrayWriteV3", opName);
            desc.AddInput(handle);
            desc.AddInput(index);
            desc.AddInput(value);
            desc.AddInput(flow_in);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorDataset
        /// </summary>
        /// <param name="components">Input to the operation. </param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation TensorDataset(Output components, long[][] output_shapes, string metadata = null, String opName = "TensorDataset") 
        {
            OperationDescription desc = NewOperation("TensorDataset", opName);
            desc.AddInput(components);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorListConcat
        /// </summary>
        /// <param name="input_handle">Input to the operation. </param>
        /// <param name="element_dtype">element dtype</param>
        /// <param name="element_shape">element shape</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] tensor(type: DtInvalid).
        /// [1] lengths(type: DtInt64).
        /// </returns>
        public Operation TensorListConcat(Output input_handle, DataType element_dtype, long[] element_shape = null, String opName = "TensorListConcat") 
        {
            OperationDescription desc = NewOperation("TensorListConcat", opName);
            desc.AddInput(input_handle);
            desc.SetAttr("element_dtype", element_dtype);
            if (element_shape != null)
                 desc.SetAttrShape("element_shape", element_shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorListConcatLists
        /// </summary>
        /// <param name="input_a">Input to the operation. </param>
        /// <param name="input_b">Input to the operation. </param>
        /// <param name="element_dtype">element dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtVariant).
        /// </returns>
        public Operation TensorListConcatLists(Output input_a, Output input_b, DataType element_dtype, String opName = "TensorListConcatLists") 
        {
            OperationDescription desc = NewOperation("TensorListConcatLists", opName);
            desc.AddInput(input_a);
            desc.AddInput(input_b);
            desc.SetAttr("element_dtype", element_dtype);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorListConcatV2
        /// </summary>
        /// <param name="input_handle">Input to the operation. </param>
        /// <param name="element_shape">Input to the operation. </param>
        /// <param name="leading_dims">Input to the operation. </param>
        /// <param name="element_dtype">element dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] tensor(type: DtInvalid).
        /// [1] lengths(type: DtInt64).
        /// </returns>
        public Operation TensorListConcatV2(Output input_handle, Output element_shape, Output leading_dims, DataType element_dtype, String opName = "TensorListConcatV2") 
        {
            OperationDescription desc = NewOperation("TensorListConcatV2", opName);
            desc.AddInput(input_handle);
            desc.AddInput(element_shape);
            desc.AddInput(leading_dims);
            desc.SetAttr("element_dtype", element_dtype);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorListElementShape
        /// </summary>
        /// <param name="input_handle">Input to the operation. </param>
        /// <param name="shape_type">shape type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] element_shape(type: DtInvalid).
        /// </returns>
        public Operation TensorListElementShape(Output input_handle, DataType shape_type, String opName = "TensorListElementShape") 
        {
            OperationDescription desc = NewOperation("TensorListElementShape", opName);
            desc.AddInput(input_handle);
            desc.SetAttr("shape_type", shape_type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorListFromTensor
        /// </summary>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="element_shape">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_handle(type: DtVariant).
        /// </returns>
        public Operation TensorListFromTensor(Output tensor, Output element_shape, String opName = "TensorListFromTensor") 
        {
            OperationDescription desc = NewOperation("TensorListFromTensor", opName);
            desc.AddInput(tensor);
            desc.AddInput(element_shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorListGather
        /// </summary>
        /// <param name="input_handle">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="element_shape">Input to the operation. </param>
        /// <param name="element_dtype">element dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] values(type: DtInvalid).
        /// </returns>
        public Operation TensorListGather(Output input_handle, Output indices, Output element_shape, DataType element_dtype, String opName = "TensorListGather") 
        {
            OperationDescription desc = NewOperation("TensorListGather", opName);
            desc.AddInput(input_handle);
            desc.AddInput(indices);
            desc.AddInput(element_shape);
            desc.SetAttr("element_dtype", element_dtype);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorListGetItem
        /// </summary>
        /// <param name="input_handle">Input to the operation. </param>
        /// <param name="index">Input to the operation. </param>
        /// <param name="element_shape">Input to the operation. </param>
        /// <param name="element_dtype">element dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] item(type: DtInvalid).
        /// </returns>
        public Operation TensorListGetItem(Output input_handle, Output index, Output element_shape, DataType element_dtype, String opName = "TensorListGetItem") 
        {
            OperationDescription desc = NewOperation("TensorListGetItem", opName);
            desc.AddInput(input_handle);
            desc.AddInput(index);
            desc.AddInput(element_shape);
            desc.SetAttr("element_dtype", element_dtype);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorListLength
        /// </summary>
        /// <param name="input_handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] length(type: DtInt32).
        /// </returns>
        public Operation TensorListLength(Output input_handle, String opName = "TensorListLength") 
        {
            OperationDescription desc = NewOperation("TensorListLength", opName);
            desc.AddInput(input_handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorListPopBack
        /// </summary>
        /// <param name="input_handle">Input to the operation. </param>
        /// <param name="element_shape">Input to the operation. </param>
        /// <param name="element_dtype">element dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_handle(type: DtVariant).
        /// [1] tensor(type: DtInvalid).
        /// </returns>
        public Operation TensorListPopBack(Output input_handle, Output element_shape, DataType element_dtype, String opName = "TensorListPopBack") 
        {
            OperationDescription desc = NewOperation("TensorListPopBack", opName);
            desc.AddInput(input_handle);
            desc.AddInput(element_shape);
            desc.SetAttr("element_dtype", element_dtype);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorListPushBack
        /// </summary>
        /// <param name="input_handle">Input to the operation. </param>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_handle(type: DtVariant).
        /// </returns>
        public Operation TensorListPushBack(Output input_handle, Output tensor, String opName = "TensorListPushBack") 
        {
            OperationDescription desc = NewOperation("TensorListPushBack", opName);
            desc.AddInput(input_handle);
            desc.AddInput(tensor);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorListPushBackBatch
        /// </summary>
        /// <param name="input_handles">Input to the operation. </param>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_handles(type: DtVariant).
        /// </returns>
        public Operation TensorListPushBackBatch(Output input_handles, Output tensor, String opName = "TensorListPushBackBatch") 
        {
            OperationDescription desc = NewOperation("TensorListPushBackBatch", opName);
            desc.AddInput(input_handles);
            desc.AddInput(tensor);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorListReserve
        /// </summary>
        /// <param name="element_shape">Input to the operation. </param>
        /// <param name="num_elements">Input to the operation. </param>
        /// <param name="element_dtype">element dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation TensorListReserve(Output element_shape, Output num_elements, DataType element_dtype, String opName = "TensorListReserve") 
        {
            OperationDescription desc = NewOperation("TensorListReserve", opName);
            desc.AddInput(element_shape);
            desc.AddInput(num_elements);
            desc.SetAttr("element_dtype", element_dtype);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorListResize
        /// </summary>
        /// <param name="input_handle">Input to the operation. </param>
        /// <param name="size">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_handle(type: DtVariant).
        /// </returns>
        public Operation TensorListResize(Output input_handle, Output size, String opName = "TensorListResize") 
        {
            OperationDescription desc = NewOperation("TensorListResize", opName);
            desc.AddInput(input_handle);
            desc.AddInput(size);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorListScatter
        /// </summary>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="element_shape">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_handle(type: DtVariant).
        /// </returns>
        public Operation TensorListScatter(Output tensor, Output indices, Output element_shape, String opName = "TensorListScatter") 
        {
            OperationDescription desc = NewOperation("TensorListScatter", opName);
            desc.AddInput(tensor);
            desc.AddInput(indices);
            desc.AddInput(element_shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorListScatterIntoExistingList
        /// </summary>
        /// <param name="input_handle">Input to the operation. </param>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_handle(type: DtVariant).
        /// </returns>
        public Operation TensorListScatterIntoExistingList(Output input_handle, Output tensor, Output indices, String opName = "TensorListScatterIntoExistingList") 
        {
            OperationDescription desc = NewOperation("TensorListScatterIntoExistingList", opName);
            desc.AddInput(input_handle);
            desc.AddInput(tensor);
            desc.AddInput(indices);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorListScatterV2
        /// </summary>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="element_shape">Input to the operation. </param>
        /// <param name="num_elements">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_handle(type: DtVariant).
        /// </returns>
        public Operation TensorListScatterV2(Output tensor, Output indices, Output element_shape, Output num_elements, String opName = "TensorListScatterV2") 
        {
            OperationDescription desc = NewOperation("TensorListScatterV2", opName);
            desc.AddInput(tensor);
            desc.AddInput(indices);
            desc.AddInput(element_shape);
            desc.AddInput(num_elements);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorListSetItem
        /// </summary>
        /// <param name="input_handle">Input to the operation. </param>
        /// <param name="index">Input to the operation. </param>
        /// <param name="item">Input to the operation. </param>
        /// <param name="resize_if_index_out_of_bounds">resize if index out of bounds</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_handle(type: DtVariant).
        /// </returns>
        public Operation TensorListSetItem(Output input_handle, Output index, Output item, bool resize_if_index_out_of_bounds = false, String opName = "TensorListSetItem") 
        {
            OperationDescription desc = NewOperation("TensorListSetItem", opName);
            desc.AddInput(input_handle);
            desc.AddInput(index);
            desc.AddInput(item);
            if (resize_if_index_out_of_bounds != false)
                desc.SetAttr("resize_if_index_out_of_bounds", resize_if_index_out_of_bounds);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorListSplit
        /// </summary>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="element_shape">Input to the operation. </param>
        /// <param name="lengths">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_handle(type: DtVariant).
        /// </returns>
        public Operation TensorListSplit(Output tensor, Output element_shape, Output lengths, String opName = "TensorListSplit") 
        {
            OperationDescription desc = NewOperation("TensorListSplit", opName);
            desc.AddInput(tensor);
            desc.AddInput(element_shape);
            desc.AddInput(lengths);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorListStack
        /// </summary>
        /// <param name="input_handle">Input to the operation. </param>
        /// <param name="element_shape">Input to the operation. </param>
        /// <param name="element_dtype">element dtype</param>
        /// <param name="num_elements">num elements</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] tensor(type: DtInvalid).
        /// </returns>
        public Operation TensorListStack(Output input_handle, Output element_shape, DataType element_dtype, long num_elements = -1, String opName = "TensorListStack") 
        {
            OperationDescription desc = NewOperation("TensorListStack", opName);
            desc.AddInput(input_handle);
            desc.AddInput(element_shape);
            desc.SetAttr("element_dtype", element_dtype);
            if (num_elements != -1)
                desc.SetAttr("num_elements", num_elements);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorMapErase
        /// </summary>
        /// <param name="input_handle">Input to the operation. </param>
        /// <param name="key">Input to the operation. </param>
        /// <param name="value_dtype">value dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_handle(type: DtVariant).
        /// </returns>
        public Operation TensorMapErase(Output input_handle, Output key, DataType value_dtype, String opName = "TensorMapErase") 
        {
            OperationDescription desc = NewOperation("TensorMapErase", opName);
            desc.AddInput(input_handle);
            desc.AddInput(key);
            desc.SetAttr("value_dtype", value_dtype);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorMapHasKey
        /// </summary>
        /// <param name="input_handle">Input to the operation. </param>
        /// <param name="key">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] has_key(type: DtBool).
        /// </returns>
        public Operation TensorMapHasKey(Output input_handle, Output key, String opName = "TensorMapHasKey") 
        {
            OperationDescription desc = NewOperation("TensorMapHasKey", opName);
            desc.AddInput(input_handle);
            desc.AddInput(key);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorMapInsert
        /// </summary>
        /// <param name="input_handle">Input to the operation. </param>
        /// <param name="key">Input to the operation. </param>
        /// <param name="value">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_handle(type: DtVariant).
        /// </returns>
        public Operation TensorMapInsert(Output input_handle, Output key, Output value, String opName = "TensorMapInsert") 
        {
            OperationDescription desc = NewOperation("TensorMapInsert", opName);
            desc.AddInput(input_handle);
            desc.AddInput(key);
            desc.AddInput(value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorMapLookup
        /// </summary>
        /// <param name="input_handle">Input to the operation. </param>
        /// <param name="key">Input to the operation. </param>
        /// <param name="value_dtype">value dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] value(type: DtInvalid).
        /// </returns>
        public Operation TensorMapLookup(Output input_handle, Output key, DataType value_dtype, String opName = "TensorMapLookup") 
        {
            OperationDescription desc = NewOperation("TensorMapLookup", opName);
            desc.AddInput(input_handle);
            desc.AddInput(key);
            desc.SetAttr("value_dtype", value_dtype);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorMapSize
        /// </summary>
        /// <param name="input_handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] size(type: DtInt32).
        /// </returns>
        public Operation TensorMapSize(Output input_handle, String opName = "TensorMapSize") 
        {
            OperationDescription desc = NewOperation("TensorMapSize", opName);
            desc.AddInput(input_handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorMapStackKeys
        /// </summary>
        /// <param name="input_handle">Input to the operation. </param>
        /// <param name="key_dtype">key dtype</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] keys(type: DtInvalid).
        /// </returns>
        public Operation TensorMapStackKeys(Output input_handle, DataType key_dtype, String opName = "TensorMapStackKeys") 
        {
            OperationDescription desc = NewOperation("TensorMapStackKeys", opName);
            desc.AddInput(input_handle);
            desc.SetAttr("key_dtype", key_dtype);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorScatterAdd
        /// </summary>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation TensorScatterAdd(Output tensor, Output indices, Output updates, String opName = "TensorScatterAdd") 
        {
            OperationDescription desc = NewOperation("TensorScatterAdd", opName);
            desc.AddInput(tensor);
            desc.AddInput(indices);
            desc.AddInput(updates);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorScatterMax
        /// </summary>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation TensorScatterMax(Output tensor, Output indices, Output updates, String opName = "TensorScatterMax") 
        {
            OperationDescription desc = NewOperation("TensorScatterMax", opName);
            desc.AddInput(tensor);
            desc.AddInput(indices);
            desc.AddInput(updates);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorScatterMin
        /// </summary>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation TensorScatterMin(Output tensor, Output indices, Output updates, String opName = "TensorScatterMin") 
        {
            OperationDescription desc = NewOperation("TensorScatterMin", opName);
            desc.AddInput(tensor);
            desc.AddInput(indices);
            desc.AddInput(updates);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorScatterSub
        /// </summary>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation TensorScatterSub(Output tensor, Output indices, Output updates, String opName = "TensorScatterSub") 
        {
            OperationDescription desc = NewOperation("TensorScatterSub", opName);
            desc.AddInput(tensor);
            desc.AddInput(indices);
            desc.AddInput(updates);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorScatterUpdate
        /// </summary>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="updates">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation TensorScatterUpdate(Output tensor, Output indices, Output updates, String opName = "TensorScatterUpdate") 
        {
            OperationDescription desc = NewOperation("TensorScatterUpdate", opName);
            desc.AddInput(tensor);
            desc.AddInput(indices);
            desc.AddInput(updates);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorSliceDataset
        /// </summary>
        /// <param name="components">Input to the operation. </param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="is_files">is files</param>
        /// <param name="metadata">metadata</param>
        /// <param name="replicate_on_split">replicate on split</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation TensorSliceDataset(Output components, long[][] output_shapes, bool is_files = false, string metadata = null, bool replicate_on_split = false, String opName = "TensorSliceDataset") 
        {
            OperationDescription desc = NewOperation("TensorSliceDataset", opName);
            desc.AddInput(components);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (is_files != false)
                desc.SetAttr("is_files", is_files);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            if (replicate_on_split != false)
                desc.SetAttr("replicate_on_split", replicate_on_split);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorStridedSliceUpdate
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="begin">Input to the operation. </param>
        /// <param name="end">Input to the operation. </param>
        /// <param name="strides">Input to the operation. </param>
        /// <param name="value">Input to the operation. </param>
        /// <param name="begin_mask">begin mask</param>
        /// <param name="end_mask">end mask</param>
        /// <param name="ellipsis_mask">ellipsis mask</param>
        /// <param name="new_axis_mask">new axis mask</param>
        /// <param name="shrink_axis_mask">shrink axis mask</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation TensorStridedSliceUpdate(Output input, Output begin, Output end, Output strides, Output value, long begin_mask = 0, long end_mask = 0, long ellipsis_mask = 0, long new_axis_mask = 0, long shrink_axis_mask = 0, String opName = "TensorStridedSliceUpdate") 
        {
            OperationDescription desc = NewOperation("TensorStridedSliceUpdate", opName);
            desc.AddInput(input);
            desc.AddInput(begin);
            desc.AddInput(end);
            desc.AddInput(strides);
            desc.AddInput(value);
            if (begin_mask != 0)
                desc.SetAttr("begin_mask", begin_mask);
            if (end_mask != 0)
                desc.SetAttr("end_mask", end_mask);
            if (ellipsis_mask != 0)
                desc.SetAttr("ellipsis_mask", ellipsis_mask);
            if (new_axis_mask != 0)
                desc.SetAttr("new_axis_mask", new_axis_mask);
            if (shrink_axis_mask != 0)
                desc.SetAttr("shrink_axis_mask", shrink_axis_mask);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorSummary
        /// </summary>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="description">description</param>
        /// <param name="labels">labels</param>
        /// <param name="display_name">display name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] summary(type: DtString).
        /// </returns>
        public Operation TensorSummary(Output tensor, string description = null, string[] labels = null, string display_name = null, String opName = "TensorSummary") 
        {
            OperationDescription desc = NewOperation("TensorSummary", opName);
            desc.AddInput(tensor);
            if (description != null)
                 desc.SetAttr("description", description);
            if (labels != null) desc.SetAttr("labels", labels);
            if (display_name != null)
                 desc.SetAttr("display_name", display_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TensorSummaryV2
        /// </summary>
        /// <param name="tag">Input to the operation. </param>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="serialized_summary_metadata">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] summary(type: DtString).
        /// </returns>
        public Operation TensorSummaryV2(Output tag, Output tensor, Output serialized_summary_metadata, String opName = "TensorSummaryV2") 
        {
            OperationDescription desc = NewOperation("TensorSummaryV2", opName);
            desc.AddInput(tag);
            desc.AddInput(tensor);
            desc.AddInput(serialized_summary_metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TextLineDataset
        /// </summary>
        /// <param name="filenames">Input to the operation. </param>
        /// <param name="compression_type">Input to the operation. </param>
        /// <param name="buffer_size">Input to the operation. </param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation TextLineDataset(Output filenames, Output compression_type, Output buffer_size, string metadata = null, String opName = "TextLineDataset") 
        {
            OperationDescription desc = NewOperation("TextLineDataset", opName);
            desc.AddInput(filenames);
            desc.AddInput(compression_type);
            desc.AddInput(buffer_size);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TextLineReader
        /// </summary>
        /// <param name="skip_header_lines">skip header lines</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] reader_handle(type: DtString).
        /// </returns>
        public Operation TextLineReader(long skip_header_lines = 0, string container = null, string shared_name = null, String opName = "TextLineReader") 
        {
            OperationDescription desc = NewOperation("TextLineReader", opName);
            if (skip_header_lines != 0)
                desc.SetAttr("skip_header_lines", skip_header_lines);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TextLineReaderV2
        /// </summary>
        /// <param name="skip_header_lines">skip header lines</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] reader_handle(type: DtResource).
        /// </returns>
        public Operation TextLineReaderV2(long skip_header_lines = 0, string container = null, string shared_name = null, String opName = "TextLineReaderV2") 
        {
            OperationDescription desc = NewOperation("TextLineReaderV2", opName);
            if (skip_header_lines != 0)
                desc.SetAttr("skip_header_lines", skip_header_lines);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TFRecordDataset
        /// </summary>
        /// <param name="filenames">Input to the operation. </param>
        /// <param name="compression_type">Input to the operation. </param>
        /// <param name="buffer_size">Input to the operation. </param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation TFRecordDataset(Output filenames, Output compression_type, Output buffer_size, string metadata = null, String opName = "TFRecordDataset") 
        {
            OperationDescription desc = NewOperation("TFRecordDataset", opName);
            desc.AddInput(filenames);
            desc.AddInput(compression_type);
            desc.AddInput(buffer_size);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TFRecordDatasetV2
        /// </summary>
        /// <param name="filenames">Input to the operation. </param>
        /// <param name="compression_type">Input to the operation. </param>
        /// <param name="buffer_size">Input to the operation. </param>
        /// <param name="byte_offsets">Input to the operation. </param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation TFRecordDatasetV2(Output filenames, Output compression_type, Output buffer_size, Output byte_offsets, string metadata = null, String opName = "TFRecordDatasetV2") 
        {
            OperationDescription desc = NewOperation("TFRecordDatasetV2", opName);
            desc.AddInput(filenames);
            desc.AddInput(compression_type);
            desc.AddInput(buffer_size);
            desc.AddInput(byte_offsets);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TFRecordReader
        /// </summary>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="compression_type">compression type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] reader_handle(type: DtString).
        /// </returns>
        public Operation TFRecordReader(string container = null, string shared_name = null, string compression_type = null, String opName = "TFRecordReader") 
        {
            OperationDescription desc = NewOperation("TFRecordReader", opName);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            if (compression_type != null)
                 desc.SetAttr("compression_type", compression_type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TFRecordReaderV2
        /// </summary>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="compression_type">compression type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] reader_handle(type: DtResource).
        /// </returns>
        public Operation TFRecordReaderV2(string container = null, string shared_name = null, string compression_type = null, String opName = "TFRecordReaderV2") 
        {
            OperationDescription desc = NewOperation("TFRecordReaderV2", opName);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            if (compression_type != null)
                 desc.SetAttr("compression_type", compression_type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ThreadPoolDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="thread_pool">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ThreadPoolDataset(Output input_dataset, Output thread_pool, DataType[] output_types, long[][] output_shapes, String opName = "ThreadPoolDataset") 
        {
            OperationDescription desc = NewOperation("ThreadPoolDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(thread_pool);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ThreadPoolHandle
        /// </summary>
        /// <param name="num_threads">num threads</param>
        /// <param name="display_name">display name</param>
        /// <param name="max_intra_op_parallelism">max intra op parallelism</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtResource).
        /// </returns>
        public Operation ThreadPoolHandle(long num_threads, string display_name, long max_intra_op_parallelism = 1, string container = null, string shared_name = null, String opName = "ThreadPoolHandle") 
        {
            OperationDescription desc = NewOperation("ThreadPoolHandle", opName);
            desc.SetAttr("num_threads", num_threads);
            desc.SetAttr("display_name", display_name);
            if (max_intra_op_parallelism != 1)
                desc.SetAttr("max_intra_op_parallelism", max_intra_op_parallelism);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ThreadUnsafeUnigramCandidateSampler
        /// </summary>
        /// <param name="true_classes">Input to the operation. </param>
        /// <param name="num_true">num true</param>
        /// <param name="num_sampled">num sampled</param>
        /// <param name="unique">unique</param>
        /// <param name="range_max">range max</param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] sampled_candidates(type: DtInt64).
        /// [1] true_expected_count(type: DtFloat).
        /// [2] sampled_expected_count(type: DtFloat).
        /// </returns>
        public Operation ThreadUnsafeUnigramCandidateSampler(Output true_classes, long num_true, long num_sampled, bool unique, long range_max, long seed = 0, long seed2 = 0, String opName = "ThreadUnsafeUnigramCandidateSampler") 
        {
            OperationDescription desc = NewOperation("ThreadUnsafeUnigramCandidateSampler", opName);
            desc.AddInput(true_classes);
            desc.SetAttr("num_true", num_true);
            desc.SetAttr("num_sampled", num_sampled);
            desc.SetAttr("unique", unique);
            desc.SetAttr("range_max", range_max);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Tile
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="multiples">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Tile(Output input, Output multiples, String opName = "Tile") 
        {
            OperationDescription desc = NewOperation("Tile", opName);
            desc.AddInput(input);
            desc.AddInput(multiples);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TileGrad
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="multiples">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation TileGrad(Output input, Output multiples, String opName = "TileGrad") 
        {
            OperationDescription desc = NewOperation("TileGrad", opName);
            desc.AddInput(input);
            desc.AddInput(multiples);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Timestamp
        /// </summary>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] ts(type: DtDouble).
        /// </returns>
        public Operation Timestamp(String opName = "Timestamp") 
        {
            OperationDescription desc = NewOperation("Timestamp", opName);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ToBool
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtBool).
        /// </returns>
        public Operation ToBool(Output input, String opName = "ToBool") 
        {
            OperationDescription desc = NewOperation("ToBool", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TopK
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="k">k</param>
        /// <param name="sorted">sorted</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] values(type: DtInvalid).
        /// [1] indices(type: DtInt32).
        /// </returns>
        public Operation TopK(Output input, long k, bool sorted = true, String opName = "TopK") 
        {
            OperationDescription desc = NewOperation("TopK", opName);
            desc.AddInput(input);
            desc.SetAttr("k", k);
            if (sorted != true)
                desc.SetAttr("sorted", sorted);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TopKUnique
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="k">k</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] topk(type: DtFloat).
        /// [1] topk_indices(type: DtInt32).
        /// </returns>
        public Operation TopKUnique(Output input, long k, String opName = "TopKUnique") 
        {
            OperationDescription desc = NewOperation("TopKUnique", opName);
            desc.AddInput(input);
            desc.SetAttr("k", k);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TopKV2
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="k">Input to the operation. </param>
        /// <param name="sorted">sorted</param>
        /// <param name="index_type">index type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] values(type: DtInvalid).
        /// [1] indices(type: DtInvalid).
        /// </returns>
        public Operation TopKV2(Output input, Output k, bool sorted = true, DataType? index_type = null, String opName = "TopKV2") 
        {
            OperationDescription desc = NewOperation("TopKV2", opName);
            desc.AddInput(input);
            desc.AddInput(k);
            if (sorted != true)
                desc.SetAttr("sorted", sorted);
            if (index_type.HasValue)
                desc.SetAttr("index_type", index_type.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TopKWithUnique
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="k">k</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] topk(type: DtFloat).
        /// [1] topk_indices(type: DtInt32).
        /// </returns>
        public Operation TopKWithUnique(Output input, long k, String opName = "TopKWithUnique") 
        {
            OperationDescription desc = NewOperation("TopKWithUnique", opName);
            desc.AddInput(input);
            desc.SetAttr("k", k);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TPUAnnotateTensorsWithDynamicShape
        /// </summary>
        /// <param name="tensors">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] tpu_tensors(type: DtInvalid).
        /// </returns>
        public Operation TPUAnnotateTensorsWithDynamicShape(Output tensors, String opName = "TPUAnnotateTensorsWithDynamicShape") 
        {
            OperationDescription desc = NewOperation("TPUAnnotateTensorsWithDynamicShape", opName);
            desc.AddInput(tensors);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TPUCompilationResult
        /// </summary>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtString).
        /// </returns>
        public Operation TPUCompilationResult(String opName = "TPUCompilationResult") 
        {
            OperationDescription desc = NewOperation("TPUCompilationResult", opName);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TPUCompile
        /// </summary>
        /// <param name="dynamic_shapes">Input to the operation. </param>
        /// <param name="guaranteed_constants">Input to the operation. </param>
        /// <param name="num_computations">num computations</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] compilation_status(type: DtString).
        /// [1] program(type: DtString).
        /// [2] may_modify_variables(type: DtBool).
        /// </returns>
        // The following attributes are not known: function: func
        public Operation TPUCompile(Output dynamic_shapes, Output guaranteed_constants, long num_computations, string metadata, String opName = "TPUCompile") 
        {
            OperationDescription desc = NewOperation("TPUCompile", opName);
            desc.AddInput(dynamic_shapes);
            desc.AddInput(guaranteed_constants);
            desc.SetAttr("num_computations", num_computations);
            desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TPUCompileSucceededAssert
        /// </summary>
        /// <param name="compilation_status">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation TPUCompileSucceededAssert(Output compilation_status, String opName = "TPUCompileSucceededAssert") 
        {
            OperationDescription desc = NewOperation("TPUCompileSucceededAssert", opName);
            desc.AddInput(compilation_status);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TPUCopyWithDynamicShape
        /// </summary>
        /// <param name="tensors">Input to the operation. </param>
        /// <param name="unpadded_sizes">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] tpu_tensors(type: DtInvalid).
        /// </returns>
        public Operation TPUCopyWithDynamicShape(Output tensors, Output unpadded_sizes, String opName = "TPUCopyWithDynamicShape") 
        {
            OperationDescription desc = NewOperation("TPUCopyWithDynamicShape", opName);
            desc.AddInput(tensors);
            desc.AddInput(unpadded_sizes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TPUEmbeddingActivations
        /// </summary>
        /// <param name="embedding_variable">Input to the operation. </param>
        /// <param name="sliced_activations">Input to the operation. </param>
        /// <param name="table_id">table id</param>
        /// <param name="lookup_id">lookup id</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtFloat).
        /// </returns>
        public Operation TPUEmbeddingActivations(Output embedding_variable, Output sliced_activations, long table_id, long lookup_id, String opName = "TPUEmbeddingActivations") 
        {
            OperationDescription desc = NewOperation("TPUEmbeddingActivations", opName);
            desc.AddInput(embedding_variable);
            desc.AddInput(sliced_activations);
            desc.SetAttr("table_id", table_id);
            desc.SetAttr("lookup_id", lookup_id);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TPUExecute
        /// </summary>
        /// <param name="args">Input to the operation. </param>
        /// <param name="key">Input to the operation. </param>
        /// <param name="Tresults">Tresults</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] results(type: DtInvalid).
        /// </returns>
        public Operation TPUExecute(Output args, Output key, DataType[] Tresults, String opName = "TPUExecute") 
        {
            OperationDescription desc = NewOperation("TPUExecute", opName);
            desc.AddInput(args);
            desc.AddInput(key);
            desc.SetAttr("Tresults", Tresults);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TPUExecuteAndUpdateVariables
        /// </summary>
        /// <param name="args">Input to the operation. </param>
        /// <param name="key">Input to the operation. </param>
        /// <param name="Tresults">Tresults</param>
        /// <param name="device_var_reads_indices">device var reads indices</param>
        /// <param name="device_var_updates_indices">device var updates indices</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] results(type: DtInvalid).
        /// </returns>
        public Operation TPUExecuteAndUpdateVariables(Output args, Output key, DataType[] Tresults, long[] device_var_reads_indices, long[] device_var_updates_indices, String opName = "TPUExecuteAndUpdateVariables") 
        {
            OperationDescription desc = NewOperation("TPUExecuteAndUpdateVariables", opName);
            desc.AddInput(args);
            desc.AddInput(key);
            desc.SetAttr("Tresults", Tresults);
            desc.SetAttr("device_var_reads_indices", device_var_reads_indices);
            desc.SetAttr("device_var_updates_indices", device_var_updates_indices);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TpuHandleToProtoKey
        /// </summary>
        /// <param name="uid">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] proto_keys(type: DtString).
        /// </returns>
        public Operation TpuHandleToProtoKey(Output uid, String opName = "TpuHandleToProtoKey") 
        {
            OperationDescription desc = NewOperation("TpuHandleToProtoKey", opName);
            desc.AddInput(uid);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TPUOrdinalSelector
        /// </summary>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] device_ordinals(type: DtInt32).
        /// </returns>
        public Operation TPUOrdinalSelector(String opName = "TPUOrdinalSelector") 
        {
            OperationDescription desc = NewOperation("TPUOrdinalSelector", opName);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TPUPartitionedCall
        /// </summary>
        /// <param name="args">Input to the operation. </param>
        /// <param name="device_ordinal">Input to the operation. </param>
        /// <param name="Tout">Tout</param>
        /// <param name="autotuner_thresh">autotuner thresh</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        // The following attributes are not known: f: func
        public Operation TPUPartitionedCall(Output args, Output device_ordinal, DataType[] Tout, long autotuner_thresh = 0, String opName = "TPUPartitionedCall") 
        {
            OperationDescription desc = NewOperation("TPUPartitionedCall", opName);
            desc.AddInput(args);
            desc.AddInput(device_ordinal);
            desc.SetAttr("Tout", Tout);
            if (autotuner_thresh != 0)
                desc.SetAttr("autotuner_thresh", autotuner_thresh);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TPUPartitionedInput
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="partition_dim">partition dim</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation TPUPartitionedInput(Output inputs, long partition_dim = 0, String opName = "TPUPartitionedInput") 
        {
            OperationDescription desc = NewOperation("TPUPartitionedInput", opName);
            desc.AddInput(inputs);
            if (partition_dim != 0)
                desc.SetAttr("partition_dim", partition_dim);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TPUPartitionedInputV2
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="partition_dims">partition dims</param>
        /// <param name="is_packed">is packed</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation TPUPartitionedInputV2(Output inputs, long[] partition_dims, bool is_packed = false, String opName = "TPUPartitionedInputV2") 
        {
            OperationDescription desc = NewOperation("TPUPartitionedInputV2", opName);
            desc.AddInput(inputs);
            desc.SetAttr("partition_dims", partition_dims);
            if (is_packed != false)
                desc.SetAttr("is_packed", is_packed);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TPUPartitionedOutput
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="num_splits">num splits</param>
        /// <param name="partition_dim">partition dim</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation TPUPartitionedOutput(Output inputs, long num_splits, long partition_dim = 0, String opName = "TPUPartitionedOutput") 
        {
            OperationDescription desc = NewOperation("TPUPartitionedOutput", opName);
            desc.AddInput(inputs);
            desc.SetAttr("num_splits", num_splits);
            if (partition_dim != 0)
                desc.SetAttr("partition_dim", partition_dim);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TPUPartitionedOutputV2
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="num_splits">num splits</param>
        /// <param name="partition_dims">partition dims</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation TPUPartitionedOutputV2(Output inputs, long num_splits, long[] partition_dims, String opName = "TPUPartitionedOutputV2") 
        {
            OperationDescription desc = NewOperation("TPUPartitionedOutputV2", opName);
            desc.AddInput(inputs);
            desc.SetAttr("num_splits", num_splits);
            desc.SetAttr("partition_dims", partition_dims);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TPUReplicatedInput
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="is_mirrored_variable">is mirrored variable</param>
        /// <param name="index">index</param>
        /// <param name="is_packed">is packed</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation TPUReplicatedInput(Output inputs, bool is_mirrored_variable = false, long index = -1, bool is_packed = false, String opName = "TPUReplicatedInput") 
        {
            OperationDescription desc = NewOperation("TPUReplicatedInput", opName);
            desc.AddInput(inputs);
            if (is_mirrored_variable != false)
                desc.SetAttr("is_mirrored_variable", is_mirrored_variable);
            if (index != -1)
                desc.SetAttr("index", index);
            if (is_packed != false)
                desc.SetAttr("is_packed", is_packed);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TPUReplicatedOutput
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="num_replicas">num replicas</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] outputs(type: DtInvalid).
        /// </returns>
        public Operation TPUReplicatedOutput(Output input, long num_replicas, String opName = "TPUReplicatedOutput") 
        {
            OperationDescription desc = NewOperation("TPUReplicatedOutput", opName);
            desc.AddInput(input);
            desc.SetAttr("num_replicas", num_replicas);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TPUReplicateMetadata
        /// </summary>
        /// <param name="num_replicas">num replicas</param>
        /// <param name="num_cores_per_replica">num cores per replica</param>
        /// <param name="topology">topology</param>
        /// <param name="use_tpu">use tpu</param>
        /// <param name="device_assignment">device assignment</param>
        /// <param name="computation_shape">computation shape</param>
        /// <param name="host_compute_core">host compute core</param>
        /// <param name="padding_map">padding map</param>
        /// <param name="step_marker_location">step marker location</param>
        /// <param name="allow_soft_placement">allow soft placement</param>
        /// <param name="use_spmd_for_xla_partitioning">use spmd for xla partitioning</param>
        /// <param name="tpu_compile_options_proto">tpu compile options proto</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation TPUReplicateMetadata(long num_replicas, long num_cores_per_replica = 1, string topology = null, bool use_tpu = true, long[] device_assignment = null, long[] computation_shape = null, string[] host_compute_core = null, string[] padding_map = null, string step_marker_location = null, bool allow_soft_placement = false, bool use_spmd_for_xla_partitioning = false, string tpu_compile_options_proto = null, String opName = "TPUReplicateMetadata") 
        {
            OperationDescription desc = NewOperation("TPUReplicateMetadata", opName);
            desc.SetAttr("num_replicas", num_replicas);
            if (num_cores_per_replica != 1)
                desc.SetAttr("num_cores_per_replica", num_cores_per_replica);
            if (topology != null)
                 desc.SetAttr("topology", topology);
            if (use_tpu != true)
                desc.SetAttr("use_tpu", use_tpu);
            if (device_assignment != null) desc.SetAttr("device_assignment", device_assignment);
            if (computation_shape != null) desc.SetAttr("computation_shape", computation_shape);
            if (host_compute_core != null) desc.SetAttr("host_compute_core", host_compute_core);
            if (padding_map != null) desc.SetAttr("padding_map", padding_map);
            if (step_marker_location != null)
                 desc.SetAttr("step_marker_location", step_marker_location);
            if (allow_soft_placement != false)
                desc.SetAttr("allow_soft_placement", allow_soft_placement);
            if (use_spmd_for_xla_partitioning != false)
                desc.SetAttr("use_spmd_for_xla_partitioning", use_spmd_for_xla_partitioning);
            if (tpu_compile_options_proto != null)
                 desc.SetAttr("tpu_compile_options_proto", tpu_compile_options_proto);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TPUReshardVariables
        /// </summary>
        /// <param name="vars">Input to the operation. </param>
        /// <param name="new_format_key">Input to the operation. </param>
        /// <param name="format_state_var">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation TPUReshardVariables(Output vars, Output new_format_key, Output format_state_var, String opName = "TPUReshardVariables") 
        {
            OperationDescription desc = NewOperation("TPUReshardVariables", opName);
            desc.AddInput(vars);
            desc.AddInput(new_format_key);
            desc.AddInput(format_state_var);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TPURoundRobin
        /// </summary>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] device_ordinal(type: DtInt32).
        /// </returns>
        public Operation TPURoundRobin(String opName = "TPURoundRobin") 
        {
            OperationDescription desc = NewOperation("TPURoundRobin", opName);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Transpose
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="perm">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation Transpose(Output x, Output perm, String opName = "Transpose") 
        {
            OperationDescription desc = NewOperation("Transpose", opName);
            desc.AddInput(x);
            desc.AddInput(perm);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TridiagonalMatMul
        /// </summary>
        /// <param name="superdiag">Input to the operation. </param>
        /// <param name="maindiag">Input to the operation. </param>
        /// <param name="subdiag">Input to the operation. </param>
        /// <param name="rhs">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation TridiagonalMatMul(Output superdiag, Output maindiag, Output subdiag, Output rhs, String opName = "TridiagonalMatMul") 
        {
            OperationDescription desc = NewOperation("TridiagonalMatMul", opName);
            desc.AddInput(superdiag);
            desc.AddInput(maindiag);
            desc.AddInput(subdiag);
            desc.AddInput(rhs);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TridiagonalSolve
        /// </summary>
        /// <param name="diagonals">Input to the operation. </param>
        /// <param name="rhs">Input to the operation. </param>
        /// <param name="partial_pivoting">partial pivoting</param>
        /// <param name="perturb_singular">perturb singular</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation TridiagonalSolve(Output diagonals, Output rhs, bool partial_pivoting = true, bool perturb_singular = false, String opName = "TridiagonalSolve") 
        {
            OperationDescription desc = NewOperation("TridiagonalSolve", opName);
            desc.AddInput(diagonals);
            desc.AddInput(rhs);
            if (partial_pivoting != true)
                desc.SetAttr("partial_pivoting", partial_pivoting);
            if (perturb_singular != false)
                desc.SetAttr("perturb_singular", perturb_singular);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TruncateDiv
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation TruncateDiv(Output x, Output y, String opName = "TruncateDiv") 
        {
            OperationDescription desc = NewOperation("TruncateDiv", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TruncatedNormal
        /// </summary>
        /// <param name="shape">Input to the operation. </param>
        /// <param name="dtype">dtype</param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation TruncatedNormal(Output shape, DataType dtype, long seed = 0, long seed2 = 0, String opName = "TruncatedNormal") 
        {
            OperationDescription desc = NewOperation("TruncatedNormal", opName);
            desc.AddInput(shape);
            desc.SetAttr("dtype", dtype);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// TruncateMod
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation TruncateMod(Output x, Output y, String opName = "TruncateMod") 
        {
            OperationDescription desc = NewOperation("TruncateMod", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Unbatch
        /// </summary>
        /// <param name="batched_tensor">Input to the operation. </param>
        /// <param name="batch_index">Input to the operation. </param>
        /// <param name="id">Input to the operation. </param>
        /// <param name="timeout_micros">timeout micros</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] unbatched_tensor(type: DtInvalid).
        /// </returns>
        public Operation Unbatch(Output batched_tensor, Output batch_index, Output id, long timeout_micros, string container = null, string shared_name = null, String opName = "Unbatch") 
        {
            OperationDescription desc = NewOperation("Unbatch", opName);
            desc.AddInput(batched_tensor);
            desc.AddInput(batch_index);
            desc.AddInput(id);
            desc.SetAttr("timeout_micros", timeout_micros);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UnbatchDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation UnbatchDataset(Output input_dataset, DataType[] output_types, long[][] output_shapes, string metadata = null, String opName = "UnbatchDataset") 
        {
            OperationDescription desc = NewOperation("UnbatchDataset", opName);
            desc.AddInput(input_dataset);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UnbatchGrad
        /// </summary>
        /// <param name="original_input">Input to the operation. </param>
        /// <param name="batch_index">Input to the operation. </param>
        /// <param name="grad">Input to the operation. </param>
        /// <param name="id">Input to the operation. </param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] batched_grad(type: DtInvalid).
        /// </returns>
        public Operation UnbatchGrad(Output original_input, Output batch_index, Output grad, Output id, string container = null, string shared_name = null, String opName = "UnbatchGrad") 
        {
            OperationDescription desc = NewOperation("UnbatchGrad", opName);
            desc.AddInput(original_input);
            desc.AddInput(batch_index);
            desc.AddInput(grad);
            desc.AddInput(id);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UncompressElement
        /// </summary>
        /// <param name="compressed">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] components(type: DtInvalid).
        /// </returns>
        public Operation UncompressElement(Output compressed, DataType[] output_types, long[][] output_shapes, String opName = "UncompressElement") 
        {
            OperationDescription desc = NewOperation("UncompressElement", opName);
            desc.AddInput(compressed);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UnicodeDecode
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="input_encoding">input encoding</param>
        /// <param name="errors">errors</param>
        /// <param name="replacement_char">replacement char</param>
        /// <param name="replace_control_characters">replace control characters</param>
        /// <param name="Tsplits">Tsplits</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] row_splits(type: DtInvalid).
        /// [1] char_values(type: DtInt32).
        /// </returns>
        public Operation UnicodeDecode(Output input, string input_encoding, string errors = null, long replacement_char = 65533, bool replace_control_characters = false, DataType? Tsplits = null, String opName = "UnicodeDecode") 
        {
            OperationDescription desc = NewOperation("UnicodeDecode", opName);
            desc.AddInput(input);
            desc.SetAttr("input_encoding", input_encoding);
            if (errors != null)
                 desc.SetAttr("errors", errors);
            if (replacement_char != 65533)
                desc.SetAttr("replacement_char", replacement_char);
            if (replace_control_characters != false)
                desc.SetAttr("replace_control_characters", replace_control_characters);
            if (Tsplits.HasValue)
                desc.SetAttr("Tsplits", Tsplits.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UnicodeDecodeWithOffsets
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="input_encoding">input encoding</param>
        /// <param name="errors">errors</param>
        /// <param name="replacement_char">replacement char</param>
        /// <param name="replace_control_characters">replace control characters</param>
        /// <param name="Tsplits">Tsplits</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] row_splits(type: DtInvalid).
        /// [1] char_values(type: DtInt32).
        /// [2] char_to_byte_starts(type: DtInt64).
        /// </returns>
        public Operation UnicodeDecodeWithOffsets(Output input, string input_encoding, string errors = null, long replacement_char = 65533, bool replace_control_characters = false, DataType? Tsplits = null, String opName = "UnicodeDecodeWithOffsets") 
        {
            OperationDescription desc = NewOperation("UnicodeDecodeWithOffsets", opName);
            desc.AddInput(input);
            desc.SetAttr("input_encoding", input_encoding);
            if (errors != null)
                 desc.SetAttr("errors", errors);
            if (replacement_char != 65533)
                desc.SetAttr("replacement_char", replacement_char);
            if (replace_control_characters != false)
                desc.SetAttr("replace_control_characters", replace_control_characters);
            if (Tsplits.HasValue)
                desc.SetAttr("Tsplits", Tsplits.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UnicodeEncode
        /// </summary>
        /// <param name="input_values">Input to the operation. </param>
        /// <param name="input_splits">Input to the operation. </param>
        /// <param name="output_encoding">output encoding</param>
        /// <param name="errors">errors</param>
        /// <param name="replacement_char">replacement char</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtString).
        /// </returns>
        public Operation UnicodeEncode(Output input_values, Output input_splits, string output_encoding, string errors = null, long replacement_char = 65533, String opName = "UnicodeEncode") 
        {
            OperationDescription desc = NewOperation("UnicodeEncode", opName);
            desc.AddInput(input_values);
            desc.AddInput(input_splits);
            desc.SetAttr("output_encoding", output_encoding);
            if (errors != null)
                 desc.SetAttr("errors", errors);
            if (replacement_char != 65533)
                desc.SetAttr("replacement_char", replacement_char);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UnicodeScript
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInt32).
        /// </returns>
        public Operation UnicodeScript(Output input, String opName = "UnicodeScript") 
        {
            OperationDescription desc = NewOperation("UnicodeScript", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UnicodeTranscode
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="input_encoding">input encoding</param>
        /// <param name="output_encoding">output encoding</param>
        /// <param name="errors">errors</param>
        /// <param name="replacement_char">replacement char</param>
        /// <param name="replace_control_characters">replace control characters</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtString).
        /// </returns>
        public Operation UnicodeTranscode(Output input, string input_encoding, string output_encoding, string errors = null, long replacement_char = 65533, bool replace_control_characters = false, String opName = "UnicodeTranscode") 
        {
            OperationDescription desc = NewOperation("UnicodeTranscode", opName);
            desc.AddInput(input);
            desc.SetAttr("input_encoding", input_encoding);
            desc.SetAttr("output_encoding", output_encoding);
            if (errors != null)
                 desc.SetAttr("errors", errors);
            if (replacement_char != 65533)
                desc.SetAttr("replacement_char", replacement_char);
            if (replace_control_characters != false)
                desc.SetAttr("replace_control_characters", replace_control_characters);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UniformCandidateSampler
        /// </summary>
        /// <param name="true_classes">Input to the operation. </param>
        /// <param name="num_true">num true</param>
        /// <param name="num_sampled">num sampled</param>
        /// <param name="unique">unique</param>
        /// <param name="range_max">range max</param>
        /// <param name="seed">seed</param>
        /// <param name="seed2">seed2</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] sampled_candidates(type: DtInt64).
        /// [1] true_expected_count(type: DtFloat).
        /// [2] sampled_expected_count(type: DtFloat).
        /// </returns>
        public Operation UniformCandidateSampler(Output true_classes, long num_true, long num_sampled, bool unique, long range_max, long seed = 0, long seed2 = 0, String opName = "UniformCandidateSampler") 
        {
            OperationDescription desc = NewOperation("UniformCandidateSampler", opName);
            desc.AddInput(true_classes);
            desc.SetAttr("num_true", num_true);
            desc.SetAttr("num_sampled", num_sampled);
            desc.SetAttr("unique", unique);
            desc.SetAttr("range_max", range_max);
            if (seed != 0)
                desc.SetAttr("seed", seed);
            if (seed2 != 0)
                desc.SetAttr("seed2", seed2);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UniformDequantize
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="scales">Input to the operation. </param>
        /// <param name="zero_points">Input to the operation. </param>
        /// <param name="Tout">Tout</param>
        /// <param name="quantization_min_val">quantization min val</param>
        /// <param name="quantization_max_val">quantization max val</param>
        /// <param name="quantization_axis">quantization axis</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation UniformDequantize(Output input, Output scales, Output zero_points, DataType Tout, long quantization_min_val, long quantization_max_val, long quantization_axis = -1, String opName = "UniformDequantize") 
        {
            OperationDescription desc = NewOperation("UniformDequantize", opName);
            desc.AddInput(input);
            desc.AddInput(scales);
            desc.AddInput(zero_points);
            desc.SetAttr("Tout", Tout);
            desc.SetAttr("quantization_min_val", quantization_min_val);
            desc.SetAttr("quantization_max_val", quantization_max_val);
            if (quantization_axis != -1)
                desc.SetAttr("quantization_axis", quantization_axis);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UniformQuantize
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="scales">Input to the operation. </param>
        /// <param name="zero_points">Input to the operation. </param>
        /// <param name="Tout">Tout</param>
        /// <param name="quantization_min_val">quantization min val</param>
        /// <param name="quantization_max_val">quantization max val</param>
        /// <param name="quantization_axis">quantization axis</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation UniformQuantize(Output input, Output scales, Output zero_points, DataType Tout, long quantization_min_val, long quantization_max_val, long quantization_axis = -1, String opName = "UniformQuantize") 
        {
            OperationDescription desc = NewOperation("UniformQuantize", opName);
            desc.AddInput(input);
            desc.AddInput(scales);
            desc.AddInput(zero_points);
            desc.SetAttr("Tout", Tout);
            desc.SetAttr("quantization_min_val", quantization_min_val);
            desc.SetAttr("quantization_max_val", quantization_max_val);
            if (quantization_axis != -1)
                desc.SetAttr("quantization_axis", quantization_axis);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UniformQuantizedAdd
        /// </summary>
        /// <param name="lhs">Input to the operation. </param>
        /// <param name="rhs">Input to the operation. </param>
        /// <param name="lhs_scales">Input to the operation. </param>
        /// <param name="lhs_zero_points">Input to the operation. </param>
        /// <param name="rhs_scales">Input to the operation. </param>
        /// <param name="rhs_zero_points">Input to the operation. </param>
        /// <param name="output_scales">Input to the operation. </param>
        /// <param name="output_zero_points">Input to the operation. </param>
        /// <param name="lhs_quantization_min_val">lhs quantization min val</param>
        /// <param name="lhs_quantization_max_val">lhs quantization max val</param>
        /// <param name="rhs_quantization_min_val">rhs quantization min val</param>
        /// <param name="rhs_quantization_max_val">rhs quantization max val</param>
        /// <param name="output_quantization_min_val">output quantization min val</param>
        /// <param name="output_quantization_max_val">output quantization max val</param>
        /// <param name="lhs_quantization_axis">lhs quantization axis</param>
        /// <param name="rhs_quantization_axis">rhs quantization axis</param>
        /// <param name="output_quantization_axis">output quantization axis</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation UniformQuantizedAdd(Output lhs, Output rhs, Output lhs_scales, Output lhs_zero_points, Output rhs_scales, Output rhs_zero_points, Output output_scales, Output output_zero_points, long lhs_quantization_min_val, long lhs_quantization_max_val, long rhs_quantization_min_val, long rhs_quantization_max_val, long output_quantization_min_val, long output_quantization_max_val, long lhs_quantization_axis = -1, long rhs_quantization_axis = -1, long output_quantization_axis = -1, String opName = "UniformQuantizedAdd") 
        {
            OperationDescription desc = NewOperation("UniformQuantizedAdd", opName);
            desc.AddInput(lhs);
            desc.AddInput(rhs);
            desc.AddInput(lhs_scales);
            desc.AddInput(lhs_zero_points);
            desc.AddInput(rhs_scales);
            desc.AddInput(rhs_zero_points);
            desc.AddInput(output_scales);
            desc.AddInput(output_zero_points);
            desc.SetAttr("lhs_quantization_min_val", lhs_quantization_min_val);
            desc.SetAttr("lhs_quantization_max_val", lhs_quantization_max_val);
            desc.SetAttr("rhs_quantization_min_val", rhs_quantization_min_val);
            desc.SetAttr("rhs_quantization_max_val", rhs_quantization_max_val);
            desc.SetAttr("output_quantization_min_val", output_quantization_min_val);
            desc.SetAttr("output_quantization_max_val", output_quantization_max_val);
            if (lhs_quantization_axis != -1)
                desc.SetAttr("lhs_quantization_axis", lhs_quantization_axis);
            if (rhs_quantization_axis != -1)
                desc.SetAttr("rhs_quantization_axis", rhs_quantization_axis);
            if (output_quantization_axis != -1)
                desc.SetAttr("output_quantization_axis", output_quantization_axis);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UniformQuantizedClipByValue
        /// </summary>
        /// <param name="operand">Input to the operation. </param>
        /// <param name="min">Input to the operation. </param>
        /// <param name="max">Input to the operation. </param>
        /// <param name="scales">Input to the operation. </param>
        /// <param name="zero_points">Input to the operation. </param>
        /// <param name="quantization_min_val">quantization min val</param>
        /// <param name="quantization_max_val">quantization max val</param>
        /// <param name="quantization_axis">quantization axis</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation UniformQuantizedClipByValue(Output operand, Output min, Output max, Output scales, Output zero_points, long quantization_min_val, long quantization_max_val, long quantization_axis = -1, String opName = "UniformQuantizedClipByValue") 
        {
            OperationDescription desc = NewOperation("UniformQuantizedClipByValue", opName);
            desc.AddInput(operand);
            desc.AddInput(min);
            desc.AddInput(max);
            desc.AddInput(scales);
            desc.AddInput(zero_points);
            desc.SetAttr("quantization_min_val", quantization_min_val);
            desc.SetAttr("quantization_max_val", quantization_max_val);
            if (quantization_axis != -1)
                desc.SetAttr("quantization_axis", quantization_axis);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UniformQuantizedConvolution
        /// </summary>
        /// <param name="lhs">Input to the operation. </param>
        /// <param name="rhs">Input to the operation. </param>
        /// <param name="lhs_scales">Input to the operation. </param>
        /// <param name="lhs_zero_points">Input to the operation. </param>
        /// <param name="rhs_scales">Input to the operation. </param>
        /// <param name="rhs_zero_points">Input to the operation. </param>
        /// <param name="output_scales">Input to the operation. </param>
        /// <param name="output_zero_points">Input to the operation. </param>
        /// <param name="Tout">Tout</param>
        /// <param name="padding">padding</param>
        /// <param name="lhs_quantization_min_val">lhs quantization min val</param>
        /// <param name="lhs_quantization_max_val">lhs quantization max val</param>
        /// <param name="rhs_quantization_min_val">rhs quantization min val</param>
        /// <param name="rhs_quantization_max_val">rhs quantization max val</param>
        /// <param name="output_quantization_min_val">output quantization min val</param>
        /// <param name="output_quantization_max_val">output quantization max val</param>
        /// <param name="window_strides">window strides</param>
        /// <param name="explicit_padding">explicit padding</param>
        /// <param name="lhs_dilation">lhs dilation</param>
        /// <param name="rhs_dilation">rhs dilation</param>
        /// <param name="batch_group_count">batch group count</param>
        /// <param name="feature_group_count">feature group count</param>
        /// <param name="dimension_numbers">dimension numbers</param>
        /// <param name="lhs_quantization_axis">lhs quantization axis</param>
        /// <param name="rhs_quantization_axis">rhs quantization axis</param>
        /// <param name="output_quantization_axis">output quantization axis</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation UniformQuantizedConvolution(Output lhs, Output rhs, Output lhs_scales, Output lhs_zero_points, Output rhs_scales, Output rhs_zero_points, Output output_scales, Output output_zero_points, DataType Tout, string padding, long lhs_quantization_min_val, long lhs_quantization_max_val, long rhs_quantization_min_val, long rhs_quantization_max_val, long output_quantization_min_val, long output_quantization_max_val, long[] window_strides = null, long[] explicit_padding = null, long[] lhs_dilation = null, long[] rhs_dilation = null, long batch_group_count = 1, long feature_group_count = 1, string dimension_numbers = null, long lhs_quantization_axis = -1, long rhs_quantization_axis = -1, long output_quantization_axis = -1, String opName = "UniformQuantizedConvolution") 
        {
            OperationDescription desc = NewOperation("UniformQuantizedConvolution", opName);
            desc.AddInput(lhs);
            desc.AddInput(rhs);
            desc.AddInput(lhs_scales);
            desc.AddInput(lhs_zero_points);
            desc.AddInput(rhs_scales);
            desc.AddInput(rhs_zero_points);
            desc.AddInput(output_scales);
            desc.AddInput(output_zero_points);
            desc.SetAttr("Tout", Tout);
            desc.SetAttr("padding", padding);
            desc.SetAttr("lhs_quantization_min_val", lhs_quantization_min_val);
            desc.SetAttr("lhs_quantization_max_val", lhs_quantization_max_val);
            desc.SetAttr("rhs_quantization_min_val", rhs_quantization_min_val);
            desc.SetAttr("rhs_quantization_max_val", rhs_quantization_max_val);
            desc.SetAttr("output_quantization_min_val", output_quantization_min_val);
            desc.SetAttr("output_quantization_max_val", output_quantization_max_val);
            if (window_strides != null) desc.SetAttr("window_strides", window_strides);
            if (explicit_padding != null) desc.SetAttr("explicit_padding", explicit_padding);
            if (lhs_dilation != null) desc.SetAttr("lhs_dilation", lhs_dilation);
            if (rhs_dilation != null) desc.SetAttr("rhs_dilation", rhs_dilation);
            if (batch_group_count != 1)
                desc.SetAttr("batch_group_count", batch_group_count);
            if (feature_group_count != 1)
                desc.SetAttr("feature_group_count", feature_group_count);
            if (dimension_numbers != null)
                 desc.SetAttr("dimension_numbers", dimension_numbers);
            if (lhs_quantization_axis != -1)
                desc.SetAttr("lhs_quantization_axis", lhs_quantization_axis);
            if (rhs_quantization_axis != -1)
                desc.SetAttr("rhs_quantization_axis", rhs_quantization_axis);
            if (output_quantization_axis != -1)
                desc.SetAttr("output_quantization_axis", output_quantization_axis);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UniformQuantizedConvolutionHybrid
        /// </summary>
        /// <param name="lhs">Input to the operation. </param>
        /// <param name="rhs">Input to the operation. </param>
        /// <param name="rhs_scales">Input to the operation. </param>
        /// <param name="rhs_zero_points">Input to the operation. </param>
        /// <param name="Tout">Tout</param>
        /// <param name="padding">padding</param>
        /// <param name="rhs_quantization_min_val">rhs quantization min val</param>
        /// <param name="rhs_quantization_max_val">rhs quantization max val</param>
        /// <param name="window_strides">window strides</param>
        /// <param name="explicit_padding">explicit padding</param>
        /// <param name="lhs_dilation">lhs dilation</param>
        /// <param name="rhs_dilation">rhs dilation</param>
        /// <param name="batch_group_count">batch group count</param>
        /// <param name="feature_group_count">feature group count</param>
        /// <param name="dimension_numbers">dimension numbers</param>
        /// <param name="rhs_quantization_axis">rhs quantization axis</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation UniformQuantizedConvolutionHybrid(Output lhs, Output rhs, Output rhs_scales, Output rhs_zero_points, DataType Tout, string padding, long rhs_quantization_min_val, long rhs_quantization_max_val, long[] window_strides = null, long[] explicit_padding = null, long[] lhs_dilation = null, long[] rhs_dilation = null, long batch_group_count = 1, long feature_group_count = 1, string dimension_numbers = null, long rhs_quantization_axis = -1, String opName = "UniformQuantizedConvolutionHybrid") 
        {
            OperationDescription desc = NewOperation("UniformQuantizedConvolutionHybrid", opName);
            desc.AddInput(lhs);
            desc.AddInput(rhs);
            desc.AddInput(rhs_scales);
            desc.AddInput(rhs_zero_points);
            desc.SetAttr("Tout", Tout);
            desc.SetAttr("padding", padding);
            desc.SetAttr("rhs_quantization_min_val", rhs_quantization_min_val);
            desc.SetAttr("rhs_quantization_max_val", rhs_quantization_max_val);
            if (window_strides != null) desc.SetAttr("window_strides", window_strides);
            if (explicit_padding != null) desc.SetAttr("explicit_padding", explicit_padding);
            if (lhs_dilation != null) desc.SetAttr("lhs_dilation", lhs_dilation);
            if (rhs_dilation != null) desc.SetAttr("rhs_dilation", rhs_dilation);
            if (batch_group_count != 1)
                desc.SetAttr("batch_group_count", batch_group_count);
            if (feature_group_count != 1)
                desc.SetAttr("feature_group_count", feature_group_count);
            if (dimension_numbers != null)
                 desc.SetAttr("dimension_numbers", dimension_numbers);
            if (rhs_quantization_axis != -1)
                desc.SetAttr("rhs_quantization_axis", rhs_quantization_axis);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UniformQuantizedDot
        /// </summary>
        /// <param name="lhs">Input to the operation. </param>
        /// <param name="rhs">Input to the operation. </param>
        /// <param name="lhs_scales">Input to the operation. </param>
        /// <param name="lhs_zero_points">Input to the operation. </param>
        /// <param name="rhs_scales">Input to the operation. </param>
        /// <param name="rhs_zero_points">Input to the operation. </param>
        /// <param name="output_scales">Input to the operation. </param>
        /// <param name="output_zero_points">Input to the operation. </param>
        /// <param name="Tout">Tout</param>
        /// <param name="lhs_quantization_min_val">lhs quantization min val</param>
        /// <param name="lhs_quantization_max_val">lhs quantization max val</param>
        /// <param name="rhs_quantization_min_val">rhs quantization min val</param>
        /// <param name="rhs_quantization_max_val">rhs quantization max val</param>
        /// <param name="output_quantization_min_val">output quantization min val</param>
        /// <param name="output_quantization_max_val">output quantization max val</param>
        /// <param name="lhs_quantization_axis">lhs quantization axis</param>
        /// <param name="rhs_quantization_axis">rhs quantization axis</param>
        /// <param name="output_quantization_axis">output quantization axis</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation UniformQuantizedDot(Output lhs, Output rhs, Output lhs_scales, Output lhs_zero_points, Output rhs_scales, Output rhs_zero_points, Output output_scales, Output output_zero_points, DataType Tout, long lhs_quantization_min_val, long lhs_quantization_max_val, long rhs_quantization_min_val, long rhs_quantization_max_val, long output_quantization_min_val, long output_quantization_max_val, long lhs_quantization_axis = -1, long rhs_quantization_axis = -1, long output_quantization_axis = -1, String opName = "UniformQuantizedDot") 
        {
            OperationDescription desc = NewOperation("UniformQuantizedDot", opName);
            desc.AddInput(lhs);
            desc.AddInput(rhs);
            desc.AddInput(lhs_scales);
            desc.AddInput(lhs_zero_points);
            desc.AddInput(rhs_scales);
            desc.AddInput(rhs_zero_points);
            desc.AddInput(output_scales);
            desc.AddInput(output_zero_points);
            desc.SetAttr("Tout", Tout);
            desc.SetAttr("lhs_quantization_min_val", lhs_quantization_min_val);
            desc.SetAttr("lhs_quantization_max_val", lhs_quantization_max_val);
            desc.SetAttr("rhs_quantization_min_val", rhs_quantization_min_val);
            desc.SetAttr("rhs_quantization_max_val", rhs_quantization_max_val);
            desc.SetAttr("output_quantization_min_val", output_quantization_min_val);
            desc.SetAttr("output_quantization_max_val", output_quantization_max_val);
            if (lhs_quantization_axis != -1)
                desc.SetAttr("lhs_quantization_axis", lhs_quantization_axis);
            if (rhs_quantization_axis != -1)
                desc.SetAttr("rhs_quantization_axis", rhs_quantization_axis);
            if (output_quantization_axis != -1)
                desc.SetAttr("output_quantization_axis", output_quantization_axis);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UniformQuantizedDotHybrid
        /// </summary>
        /// <param name="lhs">Input to the operation. </param>
        /// <param name="rhs">Input to the operation. </param>
        /// <param name="rhs_scales">Input to the operation. </param>
        /// <param name="rhs_zero_points">Input to the operation. </param>
        /// <param name="Tout">Tout</param>
        /// <param name="rhs_quantization_min_val">rhs quantization min val</param>
        /// <param name="rhs_quantization_max_val">rhs quantization max val</param>
        /// <param name="rhs_quantization_axis">rhs quantization axis</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation UniformQuantizedDotHybrid(Output lhs, Output rhs, Output rhs_scales, Output rhs_zero_points, DataType Tout, long rhs_quantization_min_val, long rhs_quantization_max_val, long rhs_quantization_axis = -1, String opName = "UniformQuantizedDotHybrid") 
        {
            OperationDescription desc = NewOperation("UniformQuantizedDotHybrid", opName);
            desc.AddInput(lhs);
            desc.AddInput(rhs);
            desc.AddInput(rhs_scales);
            desc.AddInput(rhs_zero_points);
            desc.SetAttr("Tout", Tout);
            desc.SetAttr("rhs_quantization_min_val", rhs_quantization_min_val);
            desc.SetAttr("rhs_quantization_max_val", rhs_quantization_max_val);
            if (rhs_quantization_axis != -1)
                desc.SetAttr("rhs_quantization_axis", rhs_quantization_axis);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UniformRequantize
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="input_scales">Input to the operation. </param>
        /// <param name="input_zero_points">Input to the operation. </param>
        /// <param name="output_scales">Input to the operation. </param>
        /// <param name="output_zero_points">Input to the operation. </param>
        /// <param name="Tout">Tout</param>
        /// <param name="input_quantization_min_val">input quantization min val</param>
        /// <param name="input_quantization_max_val">input quantization max val</param>
        /// <param name="output_quantization_min_val">output quantization min val</param>
        /// <param name="output_quantization_max_val">output quantization max val</param>
        /// <param name="input_quantization_axis">input quantization axis</param>
        /// <param name="output_quantization_axis">output quantization axis</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation UniformRequantize(Output input, Output input_scales, Output input_zero_points, Output output_scales, Output output_zero_points, DataType Tout, long input_quantization_min_val, long input_quantization_max_val, long output_quantization_min_val, long output_quantization_max_val, long input_quantization_axis = -1, long output_quantization_axis = -1, String opName = "UniformRequantize") 
        {
            OperationDescription desc = NewOperation("UniformRequantize", opName);
            desc.AddInput(input);
            desc.AddInput(input_scales);
            desc.AddInput(input_zero_points);
            desc.AddInput(output_scales);
            desc.AddInput(output_zero_points);
            desc.SetAttr("Tout", Tout);
            desc.SetAttr("input_quantization_min_val", input_quantization_min_val);
            desc.SetAttr("input_quantization_max_val", input_quantization_max_val);
            desc.SetAttr("output_quantization_min_val", output_quantization_min_val);
            desc.SetAttr("output_quantization_max_val", output_quantization_max_val);
            if (input_quantization_axis != -1)
                desc.SetAttr("input_quantization_axis", input_quantization_axis);
            if (output_quantization_axis != -1)
                desc.SetAttr("output_quantization_axis", output_quantization_axis);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Unique
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="out_idx">out idx</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// [1] idx(type: DtInvalid).
        /// </returns>
        public Operation Unique(Output x, DataType? out_idx = null, String opName = "Unique") 
        {
            OperationDescription desc = NewOperation("Unique", opName);
            desc.AddInput(x);
            if (out_idx.HasValue)
                desc.SetAttr("out_idx", out_idx.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UniqueDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation UniqueDataset(Output input_dataset, DataType[] output_types, long[][] output_shapes, string metadata = null, String opName = "UniqueDataset") 
        {
            OperationDescription desc = NewOperation("UniqueDataset", opName);
            desc.AddInput(input_dataset);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UniqueV2
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="axis">Input to the operation. </param>
        /// <param name="out_idx">out idx</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// [1] idx(type: DtInvalid).
        /// </returns>
        public Operation UniqueV2(Output x, Output axis, DataType? out_idx = null, String opName = "UniqueV2") 
        {
            OperationDescription desc = NewOperation("UniqueV2", opName);
            desc.AddInput(x);
            desc.AddInput(axis);
            if (out_idx.HasValue)
                desc.SetAttr("out_idx", out_idx.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UniqueWithCounts
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="out_idx">out idx</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// [1] idx(type: DtInvalid).
        /// [2] count(type: DtInvalid).
        /// </returns>
        public Operation UniqueWithCounts(Output x, DataType? out_idx = null, String opName = "UniqueWithCounts") 
        {
            OperationDescription desc = NewOperation("UniqueWithCounts", opName);
            desc.AddInput(x);
            if (out_idx.HasValue)
                desc.SetAttr("out_idx", out_idx.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UniqueWithCountsV2
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="axis">Input to the operation. </param>
        /// <param name="out_idx">out idx</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// [1] idx(type: DtInvalid).
        /// [2] count(type: DtInvalid).
        /// </returns>
        public Operation UniqueWithCountsV2(Output x, Output axis, DataType? out_idx = null, String opName = "UniqueWithCountsV2") 
        {
            OperationDescription desc = NewOperation("UniqueWithCountsV2", opName);
            desc.AddInput(x);
            desc.AddInput(axis);
            if (out_idx.HasValue)
                desc.SetAttr("out_idx", out_idx.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Unpack
        /// </summary>
        /// <param name="value">Input to the operation. </param>
        /// <param name="num">num</param>
        /// <param name="axis">axis</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation Unpack(Output value, long num, long axis = 0, String opName = "Unpack") 
        {
            OperationDescription desc = NewOperation("Unpack", opName);
            desc.AddInput(value);
            desc.SetAttr("num", num);
            if (axis != 0)
                desc.SetAttr("axis", axis);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UnravelIndex
        /// </summary>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="dims">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation UnravelIndex(Output indices, Output dims, String opName = "UnravelIndex") 
        {
            OperationDescription desc = NewOperation("UnravelIndex", opName);
            desc.AddInput(indices);
            desc.AddInput(dims);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UnsortedSegmentJoin
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="segment_ids">Input to the operation. </param>
        /// <param name="num_segments">Input to the operation. </param>
        /// <param name="separator">separator</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtString).
        /// </returns>
        public Operation UnsortedSegmentJoin(Output inputs, Output segment_ids, Output num_segments, string separator = null, String opName = "UnsortedSegmentJoin") 
        {
            OperationDescription desc = NewOperation("UnsortedSegmentJoin", opName);
            desc.AddInput(inputs);
            desc.AddInput(segment_ids);
            desc.AddInput(num_segments);
            if (separator != null)
                 desc.SetAttr("separator", separator);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UnsortedSegmentMax
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="segment_ids">Input to the operation. </param>
        /// <param name="num_segments">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation UnsortedSegmentMax(Output data, Output segment_ids, Output num_segments, String opName = "UnsortedSegmentMax") 
        {
            OperationDescription desc = NewOperation("UnsortedSegmentMax", opName);
            desc.AddInput(data);
            desc.AddInput(segment_ids);
            desc.AddInput(num_segments);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UnsortedSegmentMin
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="segment_ids">Input to the operation. </param>
        /// <param name="num_segments">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation UnsortedSegmentMin(Output data, Output segment_ids, Output num_segments, String opName = "UnsortedSegmentMin") 
        {
            OperationDescription desc = NewOperation("UnsortedSegmentMin", opName);
            desc.AddInput(data);
            desc.AddInput(segment_ids);
            desc.AddInput(num_segments);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UnsortedSegmentProd
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="segment_ids">Input to the operation. </param>
        /// <param name="num_segments">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation UnsortedSegmentProd(Output data, Output segment_ids, Output num_segments, String opName = "UnsortedSegmentProd") 
        {
            OperationDescription desc = NewOperation("UnsortedSegmentProd", opName);
            desc.AddInput(data);
            desc.AddInput(segment_ids);
            desc.AddInput(num_segments);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UnsortedSegmentSum
        /// </summary>
        /// <param name="data">Input to the operation. </param>
        /// <param name="segment_ids">Input to the operation. </param>
        /// <param name="num_segments">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation UnsortedSegmentSum(Output data, Output segment_ids, Output num_segments, String opName = "UnsortedSegmentSum") 
        {
            OperationDescription desc = NewOperation("UnsortedSegmentSum", opName);
            desc.AddInput(data);
            desc.AddInput(segment_ids);
            desc.AddInput(num_segments);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Unstage
        /// </summary>
        /// <param name="dtypes">dtypes</param>
        /// <param name="capacity">capacity</param>
        /// <param name="memory_limit">memory limit</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] values(type: DtInvalid).
        /// </returns>
        public Operation Unstage(DataType[] dtypes, long capacity = 0, long memory_limit = 0, string container = null, string shared_name = null, String opName = "Unstage") 
        {
            OperationDescription desc = NewOperation("Unstage", opName);
            desc.SetAttr("dtypes", dtypes);
            if (capacity != 0)
                desc.SetAttr("capacity", capacity);
            if (memory_limit != 0)
                desc.SetAttr("memory_limit", memory_limit);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UnwrapDatasetVariant
        /// </summary>
        /// <param name="input_handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_handle(type: DtVariant).
        /// </returns>
        public Operation UnwrapDatasetVariant(Output input_handle, String opName = "UnwrapDatasetVariant") 
        {
            OperationDescription desc = NewOperation("UnwrapDatasetVariant", opName);
            desc.AddInput(input_handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UpdateTaskIdAndGlobalCoreArray
        /// </summary>
        /// <param name="tpu_task_id_to_shard_id">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation UpdateTaskIdAndGlobalCoreArray(Output tpu_task_id_to_shard_id, String opName = "UpdateTaskIdAndGlobalCoreArray") 
        {
            OperationDescription desc = NewOperation("UpdateTaskIdAndGlobalCoreArray", opName);
            desc.AddInput(tpu_task_id_to_shard_id);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// UpperBound
        /// </summary>
        /// <param name="sorted_inputs">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="out_type">out type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation UpperBound(Output sorted_inputs, Output values, DataType? out_type = null, String opName = "UpperBound") 
        {
            OperationDescription desc = NewOperation("UpperBound", opName);
            desc.AddInput(sorted_inputs);
            desc.AddInput(values);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// VarHandleOp
        /// </summary>
        /// <param name="dtype">dtype</param>
        /// <param name="shape">shape</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="debug_name">debug name</param>
        /// <param name="allowed_devices">allowed devices</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] resource(type: DtResource).
        /// </returns>
        public Operation VarHandleOp(DataType dtype, long[] shape, string container = null, string shared_name = null, string debug_name = null, string[] allowed_devices = null, String opName = "VarHandleOp") 
        {
            OperationDescription desc = NewOperation("VarHandleOp", opName);
            desc.SetAttr("dtype", dtype);
            desc.SetAttrShape("shape", shape);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            if (debug_name != null)
                 desc.SetAttr("debug_name", debug_name);
            if (allowed_devices != null) desc.SetAttr("allowed_devices", allowed_devices);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Variable
        /// </summary>
        /// <param name="shape">shape</param>
        /// <param name="dtype">dtype</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] ref(type: DtInvalid).
        /// </returns>
        public Operation Variable(long[] shape, DataType dtype, string container = null, string shared_name = null, String opName = "Variable") 
        {
            OperationDescription desc = NewOperation("Variable", opName);
            desc.SetAttrShape("shape", shape);
            desc.SetAttr("dtype", dtype);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// VariableShape
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="out_type">out type</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation VariableShape(Output input, DataType? out_type = null, String opName = "VariableShape") 
        {
            OperationDescription desc = NewOperation("VariableShape", opName);
            desc.AddInput(input);
            if (out_type.HasValue)
                desc.SetAttr("out_type", out_type.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// VariableV2
        /// </summary>
        /// <param name="shape">shape</param>
        /// <param name="dtype">dtype</param>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] ref(type: DtInvalid).
        /// </returns>
        public Operation VariableV2(long[] shape, DataType dtype, string container = null, string shared_name = null, String opName = "VariableV2") 
        {
            OperationDescription desc = NewOperation("VariableV2", opName);
            desc.SetAttrShape("shape", shape);
            desc.SetAttr("dtype", dtype);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// VarIsInitializedOp
        /// </summary>
        /// <param name="resource">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] is_initialized(type: DtBool).
        /// </returns>
        public Operation VarIsInitializedOp(Output resource, String opName = "VarIsInitializedOp") 
        {
            OperationDescription desc = NewOperation("VarIsInitializedOp", opName);
            desc.AddInput(resource);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// WeightedFlatMapDataset
        /// </summary>
        /// <param name="input_datasets">Input to the operation. </param>
        /// <param name="weights">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation WeightedFlatMapDataset(Output input_datasets, Output weights, DataType[] output_types, long[][] output_shapes, string metadata = null, String opName = "WeightedFlatMapDataset") 
        {
            OperationDescription desc = NewOperation("WeightedFlatMapDataset", opName);
            desc.AddInput(input_datasets);
            desc.AddInput(weights);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Where
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] index(type: DtInt64).
        /// </returns>
        public Operation Where(Output input, String opName = "Where") 
        {
            OperationDescription desc = NewOperation("Where", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// While
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="parallel_iterations">parallel iterations</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        // The following attributes are not known: cond: func; body: func
        public Operation While(Output input, long[][] output_shapes = null, long parallel_iterations = 10, String opName = "While") 
        {
            OperationDescription desc = NewOperation("While", opName);
            desc.AddInput(input);
            if (output_shapes != null) desc.SetAttrShapeList("output_shapes", output_shapes);
            if (parallel_iterations != 10)
                desc.SetAttr("parallel_iterations", parallel_iterations);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// WholeFileReader
        /// </summary>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] reader_handle(type: DtString).
        /// </returns>
        public Operation WholeFileReader(string container = null, string shared_name = null, String opName = "WholeFileReader") 
        {
            OperationDescription desc = NewOperation("WholeFileReader", opName);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// WholeFileReaderV2
        /// </summary>
        /// <param name="container">container</param>
        /// <param name="shared_name">shared name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] reader_handle(type: DtResource).
        /// </returns>
        public Operation WholeFileReaderV2(string container = null, string shared_name = null, String opName = "WholeFileReaderV2") 
        {
            OperationDescription desc = NewOperation("WholeFileReaderV2", opName);
            if (container != null)
                 desc.SetAttr("container", container);
            if (shared_name != null)
                 desc.SetAttr("shared_name", shared_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// WindowDataset
        /// </summary>
        /// <param name="input_dataset">Input to the operation. </param>
        /// <param name="size">Input to the operation. </param>
        /// <param name="shift">Input to the operation. </param>
        /// <param name="stride">Input to the operation. </param>
        /// <param name="drop_remainder">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation WindowDataset(Output input_dataset, Output size, Output shift, Output stride, Output drop_remainder, DataType[] output_types, long[][] output_shapes, string metadata = null, String opName = "WindowDataset") 
        {
            OperationDescription desc = NewOperation("WindowDataset", opName);
            desc.AddInput(input_dataset);
            desc.AddInput(size);
            desc.AddInput(shift);
            desc.AddInput(stride);
            desc.AddInput(drop_remainder);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// WindowOp
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation WindowOp(Output inputs, DataType[] output_types, long[][] output_shapes, String opName = "WindowOp") 
        {
            OperationDescription desc = NewOperation("WindowOp", opName);
            desc.AddInput(inputs);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// WorkerHeartbeat
        /// </summary>
        /// <param name="request">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] response(type: DtString).
        /// </returns>
        public Operation WorkerHeartbeat(Output request, String opName = "WorkerHeartbeat") 
        {
            OperationDescription desc = NewOperation("WorkerHeartbeat", opName);
            desc.AddInput(request);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// WrapDatasetVariant
        /// </summary>
        /// <param name="input_handle">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_handle(type: DtVariant).
        /// </returns>
        public Operation WrapDatasetVariant(Output input_handle, String opName = "WrapDatasetVariant") 
        {
            OperationDescription desc = NewOperation("WrapDatasetVariant", opName);
            desc.AddInput(input_handle);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// WriteAudioSummary
        /// </summary>
        /// <param name="writer">Input to the operation. </param>
        /// <param name="step">Input to the operation. </param>
        /// <param name="tag">Input to the operation. </param>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="sample_rate">Input to the operation. </param>
        /// <param name="max_outputs">max outputs</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation WriteAudioSummary(Output writer, Output step, Output tag, Output tensor, Output sample_rate, long max_outputs = 3, String opName = "WriteAudioSummary") 
        {
            OperationDescription desc = NewOperation("WriteAudioSummary", opName);
            desc.AddInput(writer);
            desc.AddInput(step);
            desc.AddInput(tag);
            desc.AddInput(tensor);
            desc.AddInput(sample_rate);
            if (max_outputs != 3)
                desc.SetAttr("max_outputs", max_outputs);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// WriteFile
        /// </summary>
        /// <param name="filename">Input to the operation. </param>
        /// <param name="contents">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation WriteFile(Output filename, Output contents, String opName = "WriteFile") 
        {
            OperationDescription desc = NewOperation("WriteFile", opName);
            desc.AddInput(filename);
            desc.AddInput(contents);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// WriteGraphSummary
        /// </summary>
        /// <param name="writer">Input to the operation. </param>
        /// <param name="step">Input to the operation. </param>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation WriteGraphSummary(Output writer, Output step, Output tensor, String opName = "WriteGraphSummary") 
        {
            OperationDescription desc = NewOperation("WriteGraphSummary", opName);
            desc.AddInput(writer);
            desc.AddInput(step);
            desc.AddInput(tensor);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// WriteHistogramSummary
        /// </summary>
        /// <param name="writer">Input to the operation. </param>
        /// <param name="step">Input to the operation. </param>
        /// <param name="tag">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation WriteHistogramSummary(Output writer, Output step, Output tag, Output values, String opName = "WriteHistogramSummary") 
        {
            OperationDescription desc = NewOperation("WriteHistogramSummary", opName);
            desc.AddInput(writer);
            desc.AddInput(step);
            desc.AddInput(tag);
            desc.AddInput(values);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// WriteImageSummary
        /// </summary>
        /// <param name="writer">Input to the operation. </param>
        /// <param name="step">Input to the operation. </param>
        /// <param name="tag">Input to the operation. </param>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="bad_color">Input to the operation. </param>
        /// <param name="max_images">max images</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation WriteImageSummary(Output writer, Output step, Output tag, Output tensor, Output bad_color, long max_images = 3, String opName = "WriteImageSummary") 
        {
            OperationDescription desc = NewOperation("WriteImageSummary", opName);
            desc.AddInput(writer);
            desc.AddInput(step);
            desc.AddInput(tag);
            desc.AddInput(tensor);
            desc.AddInput(bad_color);
            if (max_images != 3)
                desc.SetAttr("max_images", max_images);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// WriteRawProtoSummary
        /// </summary>
        /// <param name="writer">Input to the operation. </param>
        /// <param name="step">Input to the operation. </param>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation WriteRawProtoSummary(Output writer, Output step, Output tensor, String opName = "WriteRawProtoSummary") 
        {
            OperationDescription desc = NewOperation("WriteRawProtoSummary", opName);
            desc.AddInput(writer);
            desc.AddInput(step);
            desc.AddInput(tensor);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// WriteScalarSummary
        /// </summary>
        /// <param name="writer">Input to the operation. </param>
        /// <param name="step">Input to the operation. </param>
        /// <param name="tag">Input to the operation. </param>
        /// <param name="value">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation WriteScalarSummary(Output writer, Output step, Output tag, Output value, String opName = "WriteScalarSummary") 
        {
            OperationDescription desc = NewOperation("WriteScalarSummary", opName);
            desc.AddInput(writer);
            desc.AddInput(step);
            desc.AddInput(tag);
            desc.AddInput(value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// WriteSummary
        /// </summary>
        /// <param name="writer">Input to the operation. </param>
        /// <param name="step">Input to the operation. </param>
        /// <param name="tensor">Input to the operation. </param>
        /// <param name="tag">Input to the operation. </param>
        /// <param name="summary_metadata">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation WriteSummary(Output writer, Output step, Output tensor, Output tag, Output summary_metadata, String opName = "WriteSummary") 
        {
            OperationDescription desc = NewOperation("WriteSummary", opName);
            desc.AddInput(writer);
            desc.AddInput(step);
            desc.AddInput(tensor);
            desc.AddInput(tag);
            desc.AddInput(summary_metadata);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Xdivy
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation Xdivy(Output x, Output y, String opName = "Xdivy") 
        {
            OperationDescription desc = NewOperation("Xdivy", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Wraps the XLA AllReduce operator
        /// </summary>
        /// <param name="input">Input to the operation: Array or a non-empty tuple of arrays to reduce across replicas.</param>
        /// <param name="group_assignment">Input to the operation: Groups between which the reductions are performed.</param>
        /// <param name="reduce_op">Reduction computation.</param>
        /// <param name="mode">group mode. CrossReplica: group_assignment contains replica_id. Each group contains the   replicas for the current partition. CrossReplicaAndPartition: group_assignment contains replica_id. Each group   contains the replicas for all partitions.</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation XlaAllReduce(Output input, Output group_assignment, string reduce_op, string mode, String opName = "XlaAllReduce") 
        {
            OperationDescription desc = NewOperation("XlaAllReduce", opName);
            desc.AddInput(input);
            desc.AddInput(group_assignment);
            desc.SetAttr("reduce_op", reduce_op);
            desc.SetAttr("mode", mode);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Helper operator for performing XLA-style broadcasts
        /// </summary>
        /// <param name="lhs">Input to the operation: the LHS input tensor</param>
        /// <param name="rhs">Input to the operation: the RHS input tensor</param>
        /// <param name="broadcast_dims">Input to the operation: an XLA-style broadcast dimension specification</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] lhs_output(type: DtInvalid): the broadcasted LHS tensor
        /// [1] rhs_output(type: DtInvalid): the broadcasted RHS tensor
        /// </returns>
        public Operation XlaBroadcastHelper(Output lhs, Output rhs, Output broadcast_dims, String opName = "XlaBroadcastHelper") 
        {
            OperationDescription desc = NewOperation("XlaBroadcastHelper", opName);
            desc.AddInput(lhs);
            desc.AddInput(rhs);
            desc.AddInput(broadcast_dims);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Invokes a StableHLO module.
        /// </summary>
        /// <param name="args">Input to the operation: A list of `Tensor` with possibly different types to be passed as arguments to the `module`. These are the actual arguments and do not include the platform argument (see `platforms`) nor the dimension arguments (see `dim_args_spec`).</param>
        /// <param name="version">Tracks changes the semantics of the op, to support backwards compatibility. Minimum supported version is 2. From version 2, the op carries a StableHLO text or bytecode `module`. From version 3, the op also supports the `platforms` attribute. From version 4, the op carries a StableHLO module with compatibility guarantees. From version 5, XLACallModule can include `stablehlo.custom_call` op to execute tf functions. From version 6 the op supports the `disabled_checks` attribute. See more versioning details at https://github.com/search?q=repo%3Atensorflow%2Ftensorflow+path%3Axla_call_module+%22int+kVersionMaximumSupported%22&amp;type=code.</param>
        /// <param name="module">A serialized computation, a text or bytecode representation of an mlir.Module. The return type must be a tuple if and only if the `Sout` is a list with 0 or more than 1 elements. The length of `Tout` and `Sout` must match. This op always returns a tuple of results, even if the module returns a single result.</param>
        /// <param name="Sout">List of output tensor shapes.</param>
        /// <param name="Tout">List of output tensor data types.</param>
        /// <param name="dim_args_spec">this attribute is not supported anymore.</param>
        /// <param name="platforms">the list of platforms supported by `module`. The list can contain the strings "CPU", "CUDA", "ROCM", or "TPU". It is an error to compile this op for a platform that does not appear in the list. This check can be disabled using `disabled_checks`. If the list contains more than one platform, then the `module` takes one additional 0-dimensional integer-tensor parameter in the first position, encoding the index in `platforms` of the current compilation platform. This parameter has value 0 if the plaform is not among `platforms` and the check has been disabled. The list can be empty in old versions (earlier than 6) to denote that no platform checking must be performed at loading time.</param>
        /// <param name="has_token_input_output">If true, the embedded StableHLO module's main function must take a `!stablehlo.token` as its first argument and returns a token as its first result. This can be used in conjunction with the TF2XLA's side effect mechanism in order to model side effects. This is used only in versions prior to version 9. After that, the number and position of tokens among the arguments and results are obtained from the main function type. This allows us to support more than one token and not necessarily at the start.</param>
        /// <param name="disabled_checks">A list of strings describing the safety checks that were disabled at serialization time. This attribute was added in version 6. For more details see https://github.com/search?q=repo%3Agoogle%2Fjax+path%3Ajax_export+%22class+DisabledSafetyCheck%22&amp;type=code. This list, supplemented with a comma-separate list of directives specified using the flag --tf_xla_call_module_disabled_checks, is used at module loading time to skip the corresponding checks.</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        // The following attributes are not known: function_list: list(func)
        public Operation XlaCallModule(Output args, long version, string module, long[][] Sout, DataType[] Tout, string[] dim_args_spec = null, string[] platforms = null, bool has_token_input_output = false, string[] disabled_checks = null, String opName = "XlaCallModule") 
        {
            OperationDescription desc = NewOperation("XlaCallModule", opName);
            desc.AddInput(args);
            desc.SetAttr("version", version);
            desc.SetAttr("module", module);
            desc.SetAttrShapeList("Sout", Sout);
            desc.SetAttr("Tout", Tout);
            if (dim_args_spec != null) desc.SetAttr("dim_args_spec", dim_args_spec);
            if (platforms != null) desc.SetAttr("platforms", platforms);
            if (has_token_input_output != false)
                desc.SetAttr("has_token_input_output", has_token_input_output);
            if (disabled_checks != null) desc.SetAttr("disabled_checks", disabled_checks);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Operator that connects the output of an XLA computation to other consumer graph nodes.
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] outputs(type: DtInvalid).
        /// </returns>
        public Operation XlaClusterOutput(Output input, String opName = "XlaClusterOutput") 
        {
            OperationDescription desc = NewOperation("XlaClusterOutput", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaConcatND
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="num_concats">num concats</param>
        /// <param name="paddings">paddings</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation XlaConcatND(Output inputs, long[] num_concats, long[] paddings = null, String opName = "XlaConcatND") 
        {
            OperationDescription desc = NewOperation("XlaConcatND", opName);
            desc.AddInput(inputs);
            desc.SetAttr("num_concats", num_concats);
            if (paddings != null) desc.SetAttr("paddings", paddings);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Wraps the XLA ConvGeneralDilated operator, documented at
        /// </summary>
        /// <param name="lhs">Input to the operation: the input tensor</param>
        /// <param name="rhs">Input to the operation: the kernel tensor</param>
        /// <param name="window_strides">Input to the operation: the inter-window strides</param>
        /// <param name="padding">Input to the operation: the padding to apply at the start and end of each input dimensions</param>
        /// <param name="lhs_dilation">Input to the operation: dilation to apply between input elements</param>
        /// <param name="rhs_dilation">Input to the operation: dilation to apply between kernel elements</param>
        /// <param name="feature_group_count">Input to the operation: number of feature groups for grouped convolution.</param>
        /// <param name="dimension_numbers">a serialized xla::ConvolutionDimensionNumbers proto.</param>
        /// <param name="precision_config">a serialized xla::PrecisionConfig proto.</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation XlaConv(Output lhs, Output rhs, Output window_strides, Output padding, Output lhs_dilation, Output rhs_dilation, Output feature_group_count, string dimension_numbers, string precision_config, String opName = "XlaConv") 
        {
            OperationDescription desc = NewOperation("XlaConv", opName);
            desc.AddInput(lhs);
            desc.AddInput(rhs);
            desc.AddInput(window_strides);
            desc.AddInput(padding);
            desc.AddInput(lhs_dilation);
            desc.AddInput(rhs_dilation);
            desc.AddInput(feature_group_count);
            desc.SetAttr("dimension_numbers", dimension_numbers);
            desc.SetAttr("precision_config", precision_config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Wraps the XLA ConvGeneralDilated operator, documented at
        /// </summary>
        /// <param name="lhs">Input to the operation: input tensor</param>
        /// <param name="rhs">Input to the operation: kernel tensor</param>
        /// <param name="window_strides">Input to the operation: inter-window strides</param>
        /// <param name="padding">Input to the operation: padding to apply at the start and end of each input dimensions</param>
        /// <param name="lhs_dilation">Input to the operation: dilation to apply between input elements</param>
        /// <param name="rhs_dilation">Input to the operation: dilation to apply between kernel elements</param>
        /// <param name="feature_group_count">Input to the operation: number of feature groups for grouped convolution.</param>
        /// <param name="dimension_numbers">serialized xla::ConvolutionDimensionNumbers proto.</param>
        /// <param name="precision_config">serialized xla::PrecisionConfig proto.</param>
        /// <param name="preferred_element_type">type of the tensor.</param>
        /// <param name="batch_group_count">number of batch groups or grouped filters.</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation XlaConvV2(Output lhs, Output rhs, Output window_strides, Output padding, Output lhs_dilation, Output rhs_dilation, Output feature_group_count, string dimension_numbers, string precision_config, DataType preferred_element_type, long batch_group_count = 1, String opName = "XlaConvV2") 
        {
            OperationDescription desc = NewOperation("XlaConvV2", opName);
            desc.AddInput(lhs);
            desc.AddInput(rhs);
            desc.AddInput(window_strides);
            desc.AddInput(padding);
            desc.AddInput(lhs_dilation);
            desc.AddInput(rhs_dilation);
            desc.AddInput(feature_group_count);
            desc.SetAttr("dimension_numbers", dimension_numbers);
            desc.SetAttr("precision_config", precision_config);
            desc.SetAttr("preferred_element_type", preferred_element_type);
            if (batch_group_count != 1)
                desc.SetAttr("batch_group_count", batch_group_count);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Wraps the XLA CustomCall operator
        /// </summary>
        /// <param name="args">Input to the operation: A list of `Tensor` with possibly different types.</param>
        /// <param name="target_name">Name of the function. A call instruction will be emitted which targets this symbol name.</param>
        /// <param name="backend_config">String, used to encode serialized metadata to the backend.</param>
        /// <param name="dtype">Output tensor data type.</param>
        /// <param name="shape">Output tensor shape.</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation XlaCustomCall(Output args, string target_name, string backend_config, DataType dtype, long[] shape, String opName = "XlaCustomCall") 
        {
            OperationDescription desc = NewOperation("XlaCustomCall", opName);
            desc.AddInput(args);
            desc.SetAttr("target_name", target_name);
            desc.SetAttr("backend_config", backend_config);
            desc.SetAttr("dtype", dtype);
            desc.SetAttrShape("shape", shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Emits an HLO `CustomCall` operation with multiple outputs.
        /// </summary>
        /// <param name="operands">Input to the operation: A sequence of tensors with possibly different types.</param>
        /// <param name="call_target_name">Name of the user function. The function signature must conform to version 3 of the API, see `API_VERSION_STATUS_RETURNING_UNIFIED`. All operands and results assumed to be in the default layout.</param>
        /// <param name="backend_config">A string that encodes a metadata for the backend.</param>
        /// <param name="has_side_effect">Indicates whether the custom call has side effects.</param>
        /// <param name="result_dtypes">Types of all results.</param>
        /// <param name="result_shapes">Shapes of all results.</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] results(type: DtInvalid).
        /// </returns>
        public Operation XlaCustomCallV2(Output operands, string call_target_name, string backend_config, bool has_side_effect, DataType[] result_dtypes, long[][] result_shapes, String opName = "XlaCustomCallV2") 
        {
            OperationDescription desc = NewOperation("XlaCustomCallV2", opName);
            desc.AddInput(operands);
            desc.SetAttr("call_target_name", call_target_name);
            desc.SetAttr("backend_config", backend_config);
            desc.SetAttr("has_side_effect", has_side_effect);
            desc.SetAttr("result_dtypes", result_dtypes);
            desc.SetAttrShapeList("result_shapes", result_shapes);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Takes the packed uint32 input and unpacks the input to uint8 to do
        /// </summary>
        /// <param name="input">Input to the operation: Input tensors whose types is uint32, shape is [d0, ..., dn].</param>
        /// <param name="min_range">The minimum scalar value possibly produced for the input.</param>
        /// <param name="max_range">The maximum scalar value possibly produced for the input.</param>
        /// <param name="mode">String to determine the dequantize mode in {"MIN_COMBINED", "MIN_FIRST", "SCALED"}.</param>
        /// <param name="transpose_output">Boolean to determine if output is transposed. transpose_output is faster when input is large and rank of input is higher than 1.</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtBfloat16): Output tensors whose types is bfloat16. If transpose_output is true, output shape is [dn * 4, dn-1, ..., d1, d0]. If transpose_output is false, output shape is [d0,..., dn * 4].
        /// </returns>
        public Operation XlaDequantize(Output input, float min_range, float max_range, string mode, bool transpose_output, String opName = "XlaDequantize") 
        {
            OperationDescription desc = NewOperation("XlaDequantize", opName);
            desc.AddInput(input);
            desc.SetAttr("min_range", min_range);
            desc.SetAttr("max_range", max_range);
            desc.SetAttr("mode", mode);
            desc.SetAttr("transpose_output", transpose_output);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Wraps the XLA DotGeneral operator, documented at
        /// </summary>
        /// <param name="lhs">Input to the operation: the LHS tensor</param>
        /// <param name="rhs">Input to the operation: the RHS tensor</param>
        /// <param name="dimension_numbers">a serialized xla::DotDimensionNumbers proto.</param>
        /// <param name="precision_config">a serialized xla::PrecisionConfig proto.</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation XlaDot(Output lhs, Output rhs, string dimension_numbers, string precision_config, String opName = "XlaDot") 
        {
            OperationDescription desc = NewOperation("XlaDot", opName);
            desc.AddInput(lhs);
            desc.AddInput(rhs);
            desc.SetAttr("dimension_numbers", dimension_numbers);
            desc.SetAttr("precision_config", precision_config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Wraps the XLA DotGeneral operator, documented at
        /// </summary>
        /// <param name="lhs">Input to the operation: the LHS tensor</param>
        /// <param name="rhs">Input to the operation: the RHS tensor</param>
        /// <param name="dimension_numbers">a serialized xla::DotDimensionNumbers proto.</param>
        /// <param name="precision_config">a serialized xla::PrecisionConfig proto.</param>
        /// <param name="preferred_element_type">The type of the tensor.</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation XlaDotV2(Output lhs, Output rhs, string dimension_numbers, string precision_config, DataType preferred_element_type, String opName = "XlaDotV2") 
        {
            OperationDescription desc = NewOperation("XlaDotV2", opName);
            desc.AddInput(lhs);
            desc.AddInput(rhs);
            desc.SetAttr("dimension_numbers", dimension_numbers);
            desc.SetAttr("precision_config", precision_config);
            desc.SetAttr("preferred_element_type", preferred_element_type);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Wraps the XLA DynamicSlice operator, documented at
        /// </summary>
        /// <param name="input">Input to the operation: A `Tensor` of type T.</param>
        /// <param name="start_indices">Input to the operation: List of N integers containing the slice size for each dimension. Each value must be strictly greater than zero, and start + size must be less than or equal to the size of the dimension to avoid implementation defined behavior.</param>
        /// <param name="size_indices">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation XlaDynamicSlice(Output input, Output start_indices, Output size_indices, String opName = "XlaDynamicSlice") 
        {
            OperationDescription desc = NewOperation("XlaDynamicSlice", opName);
            desc.AddInput(input);
            desc.AddInput(start_indices);
            desc.AddInput(size_indices);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Wraps the XLA DynamicUpdateSlice operator, documented at
        /// </summary>
        /// <param name="input">Input to the operation: A `Tensor` of type T.</param>
        /// <param name="update">Input to the operation: A `Tensor` of type T. Same rank as `input`.</param>
        /// <param name="indices">Input to the operation: A vector of indices into `input`. Must have length equal to the rank of `input`.</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid): A `Tensor` of type T.
        /// </returns>
        public Operation XlaDynamicUpdateSlice(Output input, Output update, Output indices, String opName = "XlaDynamicUpdateSlice") 
        {
            OperationDescription desc = NewOperation("XlaDynamicUpdateSlice", opName);
            desc.AddInput(input);
            desc.AddInput(update);
            desc.AddInput(indices);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// An op which supports basic einsum op with 2 inputs and 1 output.
        /// </summary>
        /// <param name="a">Input to the operation. </param>
        /// <param name="b">Input to the operation. </param>
        /// <param name="equation">equation</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] product(type: DtInvalid).
        /// </returns>
        public Operation XlaEinsum(Output a, Output b, string equation, String opName = "XlaEinsum") 
        {
            OperationDescription desc = NewOperation("XlaEinsum", opName);
            desc.AddInput(a);
            desc.AddInput(b);
            desc.SetAttr("equation", equation);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Wraps the XLA Gather operator documented at
        /// </summary>
        /// <param name="operand">Input to the operation: The array we're gathering from.</param>
        /// <param name="start_indices">Input to the operation: Array containing the starting indices of the slices we gather.</param>
        /// <param name="slice_sizes">Input to the operation: slice_sizes[i] is the bounds for the slice on dimension i.</param>
        /// <param name="dimension_numbers">A serialized xla::GatherDimensionNumbers proto.</param>
        /// <param name="indices_are_sorted">Boolean indicating if the indices are sorted.</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation XlaGather(Output operand, Output start_indices, Output slice_sizes, string dimension_numbers, bool indices_are_sorted, String opName = "XlaGather") 
        {
            OperationDescription desc = NewOperation("XlaGather", opName);
            desc.AddInput(operand);
            desc.AddInput(start_indices);
            desc.AddInput(slice_sizes);
            desc.SetAttr("dimension_numbers", dimension_numbers);
            desc.SetAttr("indices_are_sorted", indices_are_sorted);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaHostCompute
        /// </summary>
        /// <param name="inputs">Input to the operation. </param>
        /// <param name="Toutputs">Toutputs</param>
        /// <param name="ancestors">ancestors</param>
        /// <param name="shapes">shapes</param>
        /// <param name="key">key</param>
        /// <param name="send_key">send key</param>
        /// <param name="recv_key">recv key</param>
        /// <param name="cost_estimate_ns">cost estimate ns</param>
        /// <param name="tpu_core">tpu core</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] outputs(type: DtInvalid).
        /// </returns>
        // The following attributes are not known: shape_inference_graph: func
        public Operation XlaHostCompute(Output inputs, DataType[] Toutputs, string[] ancestors, long[][] shapes, string key, string send_key = null, string recv_key = null, long cost_estimate_ns = 1000000, long tpu_core = 0, String opName = "XlaHostCompute") 
        {
            OperationDescription desc = NewOperation("XlaHostCompute", opName);
            desc.AddInput(inputs);
            desc.SetAttr("Toutputs", Toutputs);
            desc.SetAttr("ancestors", ancestors);
            desc.SetAttrShapeList("shapes", shapes);
            desc.SetAttr("key", key);
            if (send_key != null)
                 desc.SetAttr("send_key", send_key);
            if (recv_key != null)
                 desc.SetAttr("recv_key", recv_key);
            if (cost_estimate_ns != 1000000)
                desc.SetAttr("cost_estimate_ns", cost_estimate_ns);
            if (tpu_core != 0)
                desc.SetAttr("tpu_core", tpu_core);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// output = cond ? then_branch(inputs) : else_branch(inputs).
        /// </summary>
        /// <param name="cond">Input to the operation: A boolean scalar.</param>
        /// <param name="inputs">Input to the operation: A list of input tensors.</param>
        /// <param name="Tout">Tout</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid): A list of tensors returned by either then_branch(inputs) or else_branch(inputs). The input shapes of the then_branch and else_branch must match.
        /// </returns>
        // The following attributes are not known: then_branch: func; else_branch: func
        public Operation XlaIf(Output cond, Output inputs, DataType[] Tout, String opName = "XlaIf") 
        {
            OperationDescription desc = NewOperation("XlaIf", opName);
            desc.AddInput(cond);
            desc.AddInput(inputs);
            desc.SetAttr("Tout", Tout);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Wraps the XLA Sort operator, documented at
        /// </summary>
        /// <param name="keys">Input to the operation: A `Tensor` of type K.</param>
        /// <param name="values">Input to the operation: A `Tensor` of type V.</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] sorted_keys(type: DtInvalid): A `Tensor` of type K.
        /// [1] sorted_values(type: DtInvalid): A `Tensor` of type V.
        /// </returns>
        public Operation XlaKeyValueSort(Output keys, Output values, String opName = "XlaKeyValueSort") 
        {
            OperationDescription desc = NewOperation("XlaKeyValueSort", opName);
            desc.AddInput(keys);
            desc.AddInput(values);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XLA Launch Op. For use by the XLA JIT only.
        /// </summary>
        /// <param name="constants">Input to the operation. </param>
        /// <param name="args">Input to the operation. </param>
        /// <param name="resources">Input to the operation. </param>
        /// <param name="Tresults">Tresults</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] results(type: DtInvalid).
        /// </returns>
        // The following attributes are not known: function: func
        public Operation XlaLaunch(Output constants, Output args, Output resources, DataType[] Tresults, String opName = "XlaLaunch") 
        {
            OperationDescription desc = NewOperation("XlaLaunch", opName);
            desc.AddInput(constants);
            desc.AddInput(args);
            desc.AddInput(resources);
            desc.SetAttr("Tresults", Tresults);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XLA Launch Op. For use by the XLA JIT only.
        /// </summary>
        /// <param name="args">Input to the operation. </param>
        /// <param name="Tresults">Tresults</param>
        /// <param name="constants">constants</param>
        /// <param name="resources">resources</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] results(type: DtInvalid).
        /// </returns>
        // The following attributes are not known: function: func
        public Operation XlaLaunchV2(Output args, DataType[] Tresults, long[] constants, long[] resources, String opName = "XlaLaunchV2") 
        {
            OperationDescription desc = NewOperation("XlaLaunchV2", opName);
            desc.AddInput(args);
            desc.SetAttr("Tresults", Tresults);
            desc.SetAttr("constants", constants);
            desc.SetAttr("resources", resources);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Wraps the XLA OptimizationBarrier operator.
        /// </summary>
        /// <param name="input">Input to the operation: A Tuple of Arrays of any type.</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation XlaOptimizationBarrier(Output input, String opName = "XlaOptimizationBarrier") 
        {
            OperationDescription desc = NewOperation("XlaOptimizationBarrier", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Wraps the XLA Pad operator, documented at
        /// </summary>
        /// <param name="input">Input to the operation: A `Tensor` of type T.</param>
        /// <param name="padding_value">Input to the operation: A scalar `Tensor` of type T.</param>
        /// <param name="padding_low">Input to the operation: the padding to apply at the start of each input dimensions. Must be a compile-time constant 1D tensor of length equal to rank of input.</param>
        /// <param name="padding_high">Input to the operation: the padding to apply at the end of each input dimension. Must be a compile-time constant 1D tensor of length equal to rank of input.</param>
        /// <param name="padding_interior">Input to the operation: the padding to apply between each input element. Must be a compile-time constant 1D tensor of length equal to rank of input, containing only non-negative values.</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid): A `Tensor` of type T.
        /// </returns>
        public Operation XlaPad(Output input, Output padding_value, Output padding_low, Output padding_high, Output padding_interior, String opName = "XlaPad") 
        {
            OperationDescription desc = NewOperation("XlaPad", opName);
            desc.AddInput(input);
            desc.AddInput(padding_value);
            desc.AddInput(padding_low);
            desc.AddInput(padding_high);
            desc.AddInput(padding_interior);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Receives the named tensor from another XLA computation. Wraps the XLA Recv
        /// </summary>
        /// <param name="dtype">The type of the tensor.</param>
        /// <param name="tensor_name">A string key that identifies the channel.</param>
        /// <param name="shape">The shape of the tensor.</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] tensor(type: DtInvalid): The tensor to receive.
        /// </returns>
        public Operation XlaRecv(DataType dtype, string tensor_name, long[] shape, String opName = "XlaRecv") 
        {
            OperationDescription desc = NewOperation("XlaRecv", opName);
            desc.SetAttr("dtype", dtype);
            desc.SetAttr("tensor_name", tensor_name);
            desc.SetAttrShape("shape", shape);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaRecvFromHost
        /// </summary>
        /// <param name="Toutput">Toutput</param>
        /// <param name="shape">shape</param>
        /// <param name="key">key</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation XlaRecvFromHost(DataType Toutput, long[] shape, string key, String opName = "XlaRecvFromHost") 
        {
            OperationDescription desc = NewOperation("XlaRecvFromHost", opName);
            desc.SetAttr("Toutput", Toutput);
            desc.SetAttrShape("shape", shape);
            desc.SetAttr("key", key);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaRecvTPUEmbeddingActivations
        /// </summary>
        /// <param name="deduplication_data">Input to the operation. </param>
        /// <param name="num_tables">num tables</param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] outputs(type: DtFloat).
        /// </returns>
        public Operation XlaRecvTPUEmbeddingActivations(Output deduplication_data, long num_tables, string config, String opName = "XlaRecvTPUEmbeddingActivations") 
        {
            OperationDescription desc = NewOperation("XlaRecvTPUEmbeddingActivations", opName);
            desc.AddInput(deduplication_data);
            desc.SetAttr("num_tables", num_tables);
            desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaRecvTPUEmbeddingActivationsV2
        /// </summary>
        /// <param name="deduplication_data">Input to the operation. </param>
        /// <param name="num_tables">num tables</param>
        /// <param name="config">config</param>
        /// <param name="embedding_partitions">embedding partitions</param>
        /// <param name="hbm_buffers_config">hbm buffers config</param>
        /// <param name="tpu_topology">tpu topology</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] outputs(type: DtFloat).
        /// </returns>
        public Operation XlaRecvTPUEmbeddingActivationsV2(Output deduplication_data, long num_tables, string config, string embedding_partitions, string hbm_buffers_config, string tpu_topology, String opName = "XlaRecvTPUEmbeddingActivationsV2") 
        {
            OperationDescription desc = NewOperation("XlaRecvTPUEmbeddingActivationsV2", opName);
            desc.AddInput(deduplication_data);
            desc.SetAttr("num_tables", num_tables);
            desc.SetAttr("config", config);
            desc.SetAttr("embedding_partitions", embedding_partitions);
            desc.SetAttr("hbm_buffers_config", hbm_buffers_config);
            desc.SetAttr("tpu_topology", tpu_topology);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaRecvTPUEmbeddingDeduplicationData
        /// </summary>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtVariant).
        /// </returns>
        public Operation XlaRecvTPUEmbeddingDeduplicationData(string config, String opName = "XlaRecvTPUEmbeddingDeduplicationData") 
        {
            OperationDescription desc = NewOperation("XlaRecvTPUEmbeddingDeduplicationData", opName);
            desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaRecvTPUEmbeddingDeduplicationDataV2
        /// </summary>
        /// <param name="config">config</param>
        /// <param name="embedding_partitions">embedding partitions</param>
        /// <param name="hbm_buffers_config">hbm buffers config</param>
        /// <param name="tpu_topology">tpu topology</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtVariant).
        /// </returns>
        public Operation XlaRecvTPUEmbeddingDeduplicationDataV2(string config, string embedding_partitions, string hbm_buffers_config, string tpu_topology, String opName = "XlaRecvTPUEmbeddingDeduplicationDataV2") 
        {
            OperationDescription desc = NewOperation("XlaRecvTPUEmbeddingDeduplicationDataV2", opName);
            desc.SetAttr("config", config);
            desc.SetAttr("embedding_partitions", embedding_partitions);
            desc.SetAttr("hbm_buffers_config", hbm_buffers_config);
            desc.SetAttr("tpu_topology", tpu_topology);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Wraps the XLA Reduce operator, documented at
        /// </summary>
        /// <param name="input">Input to the operation: the input tensor</param>
        /// <param name="init_value">Input to the operation: a scalar representing the initial value for the reduction</param>
        /// <param name="dimensions_to_reduce">dimension numbers over which to reduce</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        // The following attributes are not known: reducer: func
        public Operation XlaReduce(Output input, Output init_value, long[] dimensions_to_reduce, String opName = "XlaReduce") 
        {
            OperationDescription desc = NewOperation("XlaReduce", opName);
            desc.AddInput(input);
            desc.AddInput(init_value);
            desc.SetAttr("dimensions_to_reduce", dimensions_to_reduce);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Wraps the XLA ReducePrecision operator
        /// </summary>
        /// <param name="operand">Input to the operation: array of floating-point type.</param>
        /// <param name="exponent_bits">number of exponent bits in lower-precision format</param>
        /// <param name="mantissa_bits">number of mantissa bits in lower-precision format</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation XlaReducePrecision(Output operand, long exponent_bits, long mantissa_bits, String opName = "XlaReducePrecision") 
        {
            OperationDescription desc = NewOperation("XlaReducePrecision", opName);
            desc.AddInput(operand);
            desc.SetAttr("exponent_bits", exponent_bits);
            desc.SetAttr("mantissa_bits", mantissa_bits);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Wraps the XLA ReduceScatter operator
        /// </summary>
        /// <param name="input">Input to the operation: Array or a non-empty tuple of arrays to reduce across replicas.</param>
        /// <param name="group_assignment">Input to the operation: Groups between which the reductions are performed.</param>
        /// <param name="scatter_dimension">Input to the operation: Dimension to scatter.</param>
        /// <param name="reduce_op">Reduction computation.</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation XlaReduceScatter(Output input, Output group_assignment, Output scatter_dimension, string reduce_op, String opName = "XlaReduceScatter") 
        {
            OperationDescription desc = NewOperation("XlaReduceScatter", opName);
            desc.AddInput(input);
            desc.AddInput(group_assignment);
            desc.AddInput(scatter_dimension);
            desc.SetAttr("reduce_op", reduce_op);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Wraps the XLA ReduceWindow operator, documented at
        /// </summary>
        /// <param name="input">Input to the operation: the input tensor</param>
        /// <param name="init_value">Input to the operation: a scalar representing the initial value for the reduction</param>
        /// <param name="window_dimensions">Input to the operation: the shape of the window</param>
        /// <param name="window_strides">Input to the operation: the inter-window strides</param>
        /// <param name="base_dilations">Input to the operation. </param>
        /// <param name="window_dilations">Input to the operation. </param>
        /// <param name="padding">Input to the operation: the padding to apply at the start and end of each input dimensions</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        // The following attributes are not known: computation: func
        public Operation XlaReduceWindow(Output input, Output init_value, Output window_dimensions, Output window_strides, Output base_dilations, Output window_dilations, Output padding, String opName = "XlaReduceWindow") 
        {
            OperationDescription desc = NewOperation("XlaReduceWindow", opName);
            desc.AddInput(input);
            desc.AddInput(init_value);
            desc.AddInput(window_dimensions);
            desc.AddInput(window_strides);
            desc.AddInput(base_dilations);
            desc.AddInput(window_dilations);
            desc.AddInput(padding);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Inverse of XlaSetDynamicDimensionSize.
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="dim_index">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation XlaRemoveDynamicDimensionSize(Output input, Output dim_index, String opName = "XlaRemoveDynamicDimensionSize") 
        {
            OperationDescription desc = NewOperation("XlaRemoveDynamicDimensionSize", opName);
            desc.AddInput(input);
            desc.AddInput(dim_index);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Replica ID.
        /// </summary>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] id(type: DtInt32).
        /// </returns>
        public Operation XlaReplicaId(String opName = "XlaReplicaId") 
        {
            OperationDescription desc = NewOperation("XlaReplicaId", opName);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Stateless PRNG bit generator.
        /// </summary>
        /// <param name="algorithm">Input to the operation: The PRNG algorithm to use, one of tf.random.Algorithm.{PHILOX, THREEFRY, AUTO_SELECT}.</param>
        /// <param name="initial_state">Input to the operation: Initial state for the PRNG algorithm. For THREEFRY, it should be a u64[2] and for PHILOX a u64[3].</param>
        /// <param name="shape">Input to the operation: The output shape of the generated data.</param>
        /// <param name="dtype">The type of the tensor.</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output_key(type: DtUint64).
        /// [1] output(type: DtInvalid).
        /// </returns>
        public Operation XlaRngBitGenerator(Output algorithm, Output initial_state, Output shape, DataType? dtype = null, String opName = "XlaRngBitGenerator") 
        {
            OperationDescription desc = NewOperation("XlaRngBitGenerator", opName);
            desc.AddInput(algorithm);
            desc.AddInput(initial_state);
            desc.AddInput(shape);
            if (dtype.HasValue)
                desc.SetAttr("dtype", dtype.Value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Wraps the XLA Scatter operator documented at
        /// </summary>
        /// <param name="operand">Input to the operation: Array to be scattered into.</param>
        /// <param name="scatter_indices">Input to the operation: Array containing the starting indices of the slices that must be scattered to.</param>
        /// <param name="updates">Input to the operation: Array containing the values that must be used for scattering.</param>
        /// <param name="dimension_numbers">A serialized xla::ScatterDimensionNumbers proto.</param>
        /// <param name="indices_are_sorted">Boolean indicating if the indices are sorted.</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        // The following attributes are not known: update_computation: func
        public Operation XlaScatter(Output operand, Output scatter_indices, Output updates, string dimension_numbers, bool indices_are_sorted, String opName = "XlaScatter") 
        {
            OperationDescription desc = NewOperation("XlaScatter", opName);
            desc.AddInput(operand);
            desc.AddInput(scatter_indices);
            desc.AddInput(updates);
            desc.SetAttr("dimension_numbers", dimension_numbers);
            desc.SetAttr("indices_are_sorted", indices_are_sorted);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Wraps the XLA SelectAndScatter operator, documented at
        /// </summary>
        /// <param name="operand">Input to the operation: the input tensor</param>
        /// <param name="window_dimensions">Input to the operation: the shape of the window</param>
        /// <param name="window_strides">Input to the operation: the inter-window strides</param>
        /// <param name="padding">Input to the operation: the padding to apply at the start and end of each input dimensions</param>
        /// <param name="source">Input to the operation: a tensor of values to scatter</param>
        /// <param name="init_value">Input to the operation: a scalar representing the initial value for the output tensor</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        // The following attributes are not known: select: func; scatter: func
        public Operation XlaSelectAndScatter(Output operand, Output window_dimensions, Output window_strides, Output padding, Output source, Output init_value, String opName = "XlaSelectAndScatter") 
        {
            OperationDescription desc = NewOperation("XlaSelectAndScatter", opName);
            desc.AddInput(operand);
            desc.AddInput(window_dimensions);
            desc.AddInput(window_strides);
            desc.AddInput(padding);
            desc.AddInput(source);
            desc.AddInput(init_value);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Computes the eigen decomposition of a batch of self-adjoint matrices
        /// </summary>
        /// <param name="a">Input to the operation: the input tensor.</param>
        /// <param name="lower">a boolean specifies whether the calculation is done with the lower triangular part or the upper triangular part.</param>
        /// <param name="max_iter">maximum number of sweep update, i.e., the whole lower triangular part or upper triangular part based on parameter lower. Heuristically, it has been argued that approximately logN sweeps are needed in practice (Ref: Golub &amp; van Loan "Matrix Computation").</param>
        /// <param name="epsilon">the tolerance ratio.</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] w(type: DtInvalid): The eigenvalues in ascending order, each repeated according to its multiplicity.
        /// [1] v(type: DtInvalid): The column v[..., :, i] is the normalized eigenvector corresponding to the eigenvalue w[..., i].
        /// </returns>
        public Operation XlaSelfAdjointEig(Output a, bool lower, long max_iter, float epsilon, String opName = "XlaSelfAdjointEig") 
        {
            OperationDescription desc = NewOperation("XlaSelfAdjointEig", opName);
            desc.AddInput(a);
            desc.SetAttr("lower", lower);
            desc.SetAttr("max_iter", max_iter);
            desc.SetAttr("epsilon", epsilon);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Sends the named tensor to another XLA computation. Wraps the XLA Send operator
        /// </summary>
        /// <param name="tensor">Input to the operation: The tensor to send.</param>
        /// <param name="tensor_name">A string key that identifies the channel.</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation XlaSend(Output tensor, string tensor_name, String opName = "XlaSend") 
        {
            OperationDescription desc = NewOperation("XlaSend", opName);
            desc.AddInput(tensor);
            desc.SetAttr("tensor_name", tensor_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaSendToHost
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="key">key</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation XlaSendToHost(Output input, string key, String opName = "XlaSendToHost") 
        {
            OperationDescription desc = NewOperation("XlaSendToHost", opName);
            desc.AddInput(input);
            desc.SetAttr("key", key);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaSendTPUEmbeddingGradients
        /// </summary>
        /// <param name="gradients">Input to the operation. </param>
        /// <param name="learning_rates">Input to the operation. </param>
        /// <param name="deduplication_data">Input to the operation. </param>
        /// <param name="config">config</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation XlaSendTPUEmbeddingGradients(Output gradients, Output learning_rates, Output deduplication_data, string config, String opName = "XlaSendTPUEmbeddingGradients") 
        {
            OperationDescription desc = NewOperation("XlaSendTPUEmbeddingGradients", opName);
            desc.AddInput(gradients);
            desc.AddInput(learning_rates);
            desc.AddInput(deduplication_data);
            desc.SetAttr("config", config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaSendTPUEmbeddingGradientsV2
        /// </summary>
        /// <param name="gradients">Input to the operation. </param>
        /// <param name="learning_rates">Input to the operation. </param>
        /// <param name="deduplication_data">Input to the operation. </param>
        /// <param name="config">config</param>
        /// <param name="embedding_partitions">embedding partitions</param>
        /// <param name="hbm_buffers_config">hbm buffers config</param>
        /// <param name="tpu_topology">tpu topology</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>The operation.</returns>
        public Operation XlaSendTPUEmbeddingGradientsV2(Output gradients, Output learning_rates, Output deduplication_data, string config, string embedding_partitions, string hbm_buffers_config, string tpu_topology, String opName = "XlaSendTPUEmbeddingGradientsV2") 
        {
            OperationDescription desc = NewOperation("XlaSendTPUEmbeddingGradientsV2", opName);
            desc.AddInput(gradients);
            desc.AddInput(learning_rates);
            desc.AddInput(deduplication_data);
            desc.SetAttr("config", config);
            desc.SetAttr("embedding_partitions", embedding_partitions);
            desc.SetAttr("hbm_buffers_config", hbm_buffers_config);
            desc.SetAttr("tpu_topology", tpu_topology);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Set a bound for the given input value as a hint to Xla compiler,
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="bound">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInt32).
        /// </returns>
        public Operation XlaSetBound(Output input, Output bound, String opName = "XlaSetBound") 
        {
            OperationDescription desc = NewOperation("XlaSetBound", opName);
            desc.AddInput(input);
            desc.AddInput(bound);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Make a static dimension into a xla bounded dynamic dimension.
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="dim_index">Input to the operation. </param>
        /// <param name="size">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation XlaSetDynamicDimensionSize(Output input, Output dim_index, Output size, String opName = "XlaSetDynamicDimensionSize") 
        {
            OperationDescription desc = NewOperation("XlaSetDynamicDimensionSize", opName);
            desc.AddInput(input);
            desc.AddInput(dim_index);
            desc.AddInput(size);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// An op which shards the input based on the given sharding attribute. It can
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="sharding">sharding</param>
        /// <param name="unspecified_dims">unspecified dims</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation XlaSharding(Output input, string sharding = null, long[] unspecified_dims = null, String opName = "XlaSharding") 
        {
            OperationDescription desc = NewOperation("XlaSharding", opName);
            desc.AddInput(input);
            if (sharding != null)
                 desc.SetAttr("sharding", sharding);
            if (unspecified_dims != null) desc.SetAttr("unspecified_dims", unspecified_dims);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Wraps the XLA Sort operator, documented at
        /// </summary>
        /// <param name="input">Input to the operation: A `Tensor` of type T.</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid): A `Tensor` of type T.
        /// </returns>
        public Operation XlaSort(Output input, String opName = "XlaSort") 
        {
            OperationDescription desc = NewOperation("XlaSort", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaSparseCoreAdagrad
        /// </summary>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="gradient">Input to the operation. </param>
        /// <param name="learning_rate">Input to the operation. </param>
        /// <param name="accumulator">Input to the operation. </param>
        /// <param name="embedding_table">Input to the operation. </param>
        /// <param name="feature_width">feature width</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] updated_embedding_table(type: DtFloat).
        /// [1] updated_accumulator(type: DtFloat).
        /// </returns>
        public Operation XlaSparseCoreAdagrad(Output indices, Output gradient, Output learning_rate, Output accumulator, Output embedding_table, long feature_width, String opName = "XlaSparseCoreAdagrad") 
        {
            OperationDescription desc = NewOperation("XlaSparseCoreAdagrad", opName);
            desc.AddInput(indices);
            desc.AddInput(gradient);
            desc.AddInput(learning_rate);
            desc.AddInput(accumulator);
            desc.AddInput(embedding_table);
            desc.SetAttr("feature_width", feature_width);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaSparseCoreAdagradMomentum
        /// </summary>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="gradient">Input to the operation. </param>
        /// <param name="learning_rate">Input to the operation. </param>
        /// <param name="beta_1">Input to the operation. </param>
        /// <param name="epsilon">Input to the operation. </param>
        /// <param name="accumulator">Input to the operation. </param>
        /// <param name="momentum">Input to the operation. </param>
        /// <param name="embedding_table">Input to the operation. </param>
        /// <param name="feature_width">feature width</param>
        /// <param name="use_nesterov">use nesterov</param>
        /// <param name="beta_2">beta 2</param>
        /// <param name="exponent">exponent</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] updated_embedding_table(type: DtFloat).
        /// [1] updated_accumulator(type: DtFloat).
        /// [2] updated_momentum(type: DtFloat).
        /// </returns>
        public Operation XlaSparseCoreAdagradMomentum(Output indices, Output gradient, Output learning_rate, Output beta_1, Output epsilon, Output accumulator, Output momentum, Output embedding_table, long feature_width, bool use_nesterov, float beta_2, float exponent, String opName = "XlaSparseCoreAdagradMomentum") 
        {
            OperationDescription desc = NewOperation("XlaSparseCoreAdagradMomentum", opName);
            desc.AddInput(indices);
            desc.AddInput(gradient);
            desc.AddInput(learning_rate);
            desc.AddInput(beta_1);
            desc.AddInput(epsilon);
            desc.AddInput(accumulator);
            desc.AddInput(momentum);
            desc.AddInput(embedding_table);
            desc.SetAttr("feature_width", feature_width);
            desc.SetAttr("use_nesterov", use_nesterov);
            desc.SetAttr("beta_2", beta_2);
            desc.SetAttr("exponent", exponent);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaSparseCoreAdam
        /// </summary>
        /// <param name="embedding_table">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="gradient">Input to the operation. </param>
        /// <param name="learning_rate">Input to the operation. </param>
        /// <param name="momentum">Input to the operation. </param>
        /// <param name="velocity">Input to the operation. </param>
        /// <param name="beta_1">Input to the operation. </param>
        /// <param name="beta_2">Input to the operation. </param>
        /// <param name="epsilon">Input to the operation. </param>
        /// <param name="feature_width">feature width</param>
        /// <param name="use_sum_inside_sqrt">use sum inside sqrt</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] updated_embedding_table(type: DtFloat).
        /// [1] updated_velocity(type: DtFloat).
        /// [2] updated_momentum(type: DtFloat).
        /// </returns>
        public Operation XlaSparseCoreAdam(Output embedding_table, Output indices, Output gradient, Output learning_rate, Output momentum, Output velocity, Output beta_1, Output beta_2, Output epsilon, long feature_width, bool use_sum_inside_sqrt, String opName = "XlaSparseCoreAdam") 
        {
            OperationDescription desc = NewOperation("XlaSparseCoreAdam", opName);
            desc.AddInput(embedding_table);
            desc.AddInput(indices);
            desc.AddInput(gradient);
            desc.AddInput(learning_rate);
            desc.AddInput(momentum);
            desc.AddInput(velocity);
            desc.AddInput(beta_1);
            desc.AddInput(beta_2);
            desc.AddInput(epsilon);
            desc.SetAttr("feature_width", feature_width);
            desc.SetAttr("use_sum_inside_sqrt", use_sum_inside_sqrt);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaSparseCoreFtrl
        /// </summary>
        /// <param name="embedding_table">Input to the operation. </param>
        /// <param name="accumulator">Input to the operation. </param>
        /// <param name="linear">Input to the operation. </param>
        /// <param name="learning_rate">Input to the operation. </param>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="gradient">Input to the operation. </param>
        /// <param name="beta">Input to the operation. </param>
        /// <param name="learning_rate_power">Input to the operation. </param>
        /// <param name="l2_regularization_strength">Input to the operation. </param>
        /// <param name="feature_width">feature width</param>
        /// <param name="multiply_linear_by_learning_rate">multiply linear by learning rate</param>
        /// <param name="l1_regularization_strength">l1 regularization strength</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] updated_embedding_table(type: DtFloat).
        /// [1] updated_accumulator(type: DtFloat).
        /// [2] updated_linear(type: DtFloat).
        /// </returns>
        public Operation XlaSparseCoreFtrl(Output embedding_table, Output accumulator, Output linear, Output learning_rate, Output indices, Output gradient, Output beta, Output learning_rate_power, Output l2_regularization_strength, long feature_width, bool multiply_linear_by_learning_rate, float l1_regularization_strength, String opName = "XlaSparseCoreFtrl") 
        {
            OperationDescription desc = NewOperation("XlaSparseCoreFtrl", opName);
            desc.AddInput(embedding_table);
            desc.AddInput(accumulator);
            desc.AddInput(linear);
            desc.AddInput(learning_rate);
            desc.AddInput(indices);
            desc.AddInput(gradient);
            desc.AddInput(beta);
            desc.AddInput(learning_rate_power);
            desc.AddInput(l2_regularization_strength);
            desc.SetAttr("feature_width", feature_width);
            desc.SetAttr("multiply_linear_by_learning_rate", multiply_linear_by_learning_rate);
            desc.SetAttr("l1_regularization_strength", l1_regularization_strength);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaSparseCoreSgd
        /// </summary>
        /// <param name="indices">Input to the operation. </param>
        /// <param name="gradient">Input to the operation. </param>
        /// <param name="learning_rate">Input to the operation. </param>
        /// <param name="embedding_table">Input to the operation. </param>
        /// <param name="feature_width">feature width</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] updated_embedding_table(type: DtFloat).
        /// </returns>
        public Operation XlaSparseCoreSgd(Output indices, Output gradient, Output learning_rate, Output embedding_table, long feature_width, String opName = "XlaSparseCoreSgd") 
        {
            OperationDescription desc = NewOperation("XlaSparseCoreSgd", opName);
            desc.AddInput(indices);
            desc.AddInput(gradient);
            desc.AddInput(learning_rate);
            desc.AddInput(embedding_table);
            desc.SetAttr("feature_width", feature_width);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaSparseDenseMatmul
        /// </summary>
        /// <param name="row_ids">Input to the operation. </param>
        /// <param name="col_ids">Input to the operation. </param>
        /// <param name="values">Input to the operation. </param>
        /// <param name="offsets">Input to the operation. </param>
        /// <param name="embedding_table">Input to the operation. </param>
        /// <param name="max_ids_per_partition">max ids per partition</param>
        /// <param name="max_unique_ids_per_partition">max unique ids per partition</param>
        /// <param name="input_size">input size</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] activations(type: DtFloat).
        /// [1] row_pointers(type: DtInt32).
        /// [2] sorted_embedding_ids(type: DtInt32).
        /// [3] sorted_sample_ids(type: DtInt32).
        /// [4] sorted_gains(type: DtFloat).
        /// </returns>
        public Operation XlaSparseDenseMatmul(Output row_ids, Output col_ids, Output values, Output offsets, Output embedding_table, long max_ids_per_partition, long max_unique_ids_per_partition, long input_size, String opName = "XlaSparseDenseMatmul") 
        {
            OperationDescription desc = NewOperation("XlaSparseDenseMatmul", opName);
            desc.AddInput(row_ids);
            desc.AddInput(col_ids);
            desc.AddInput(values);
            desc.AddInput(offsets);
            desc.AddInput(embedding_table);
            desc.SetAttr("max_ids_per_partition", max_ids_per_partition);
            desc.SetAttr("max_unique_ids_per_partition", max_unique_ids_per_partition);
            desc.SetAttr("input_size", input_size);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaSparseDenseMatmulGradWithAdagradAndCsrInput
        /// </summary>
        /// <param name="row_pointers">Input to the operation. </param>
        /// <param name="sorted_sample_ids">Input to the operation. </param>
        /// <param name="sorted_token_ids">Input to the operation. </param>
        /// <param name="sorted_gains">Input to the operation. </param>
        /// <param name="activation_gradients">Input to the operation. </param>
        /// <param name="learning_rate">Input to the operation. </param>
        /// <param name="embedding_table">Input to the operation. </param>
        /// <param name="accumulator">Input to the operation. </param>
        /// <param name="num_minibatches_per_physical_sparse_core">Input to the operation. </param>
        /// <param name="table_name">table name</param>
        /// <param name="clip_weight_min">clip weight min</param>
        /// <param name="clip_weight_max">clip weight max</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] updated_embedding_table(type: DtFloat).
        /// [1] updated_accumulator(type: DtFloat).
        /// </returns>
        public Operation XlaSparseDenseMatmulGradWithAdagradAndCsrInput(Output row_pointers, Output sorted_sample_ids, Output sorted_token_ids, Output sorted_gains, Output activation_gradients, Output learning_rate, Output embedding_table, Output accumulator, Output num_minibatches_per_physical_sparse_core, string table_name, float clip_weight_min = Single.NegativeInfinity, float clip_weight_max = Single.PositiveInfinity, String opName = "XlaSparseDenseMatmulGradWithAdagradAndCsrInput") 
        {
            OperationDescription desc = NewOperation("XlaSparseDenseMatmulGradWithAdagradAndCsrInput", opName);
            desc.AddInput(row_pointers);
            desc.AddInput(sorted_sample_ids);
            desc.AddInput(sorted_token_ids);
            desc.AddInput(sorted_gains);
            desc.AddInput(activation_gradients);
            desc.AddInput(learning_rate);
            desc.AddInput(embedding_table);
            desc.AddInput(accumulator);
            desc.AddInput(num_minibatches_per_physical_sparse_core);
            desc.SetAttr("table_name", table_name);
            if (clip_weight_min != Single.NegativeInfinity)
                desc.SetAttr("clip_weight_min", clip_weight_min);
            if (clip_weight_max != Single.PositiveInfinity)
                desc.SetAttr("clip_weight_max", clip_weight_max);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaSparseDenseMatmulGradWithAdagradAndStaticBufferSize
        /// </summary>
        /// <param name="row_pointers">Input to the operation. </param>
        /// <param name="sorted_sample_ids">Input to the operation. </param>
        /// <param name="sorted_token_ids">Input to the operation. </param>
        /// <param name="sorted_gains">Input to the operation. </param>
        /// <param name="activation_gradients">Input to the operation. </param>
        /// <param name="learning_rate">Input to the operation. </param>
        /// <param name="embedding_table">Input to the operation. </param>
        /// <param name="accumulator">Input to the operation. </param>
        /// <param name="num_minibatches_per_physical_sparse_core">Input to the operation. </param>
        /// <param name="max_ids_per_sparse_core">max ids per sparse core</param>
        /// <param name="max_unique_ids_per_sparse_core">max unique ids per sparse core</param>
        /// <param name="table_name">table name</param>
        /// <param name="clip_weight_min">clip weight min</param>
        /// <param name="clip_weight_max">clip weight max</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] updated_embedding_table(type: DtFloat).
        /// [1] updated_accumulator(type: DtFloat).
        /// </returns>
        public Operation XlaSparseDenseMatmulGradWithAdagradAndStaticBufferSize(Output row_pointers, Output sorted_sample_ids, Output sorted_token_ids, Output sorted_gains, Output activation_gradients, Output learning_rate, Output embedding_table, Output accumulator, Output num_minibatches_per_physical_sparse_core, long max_ids_per_sparse_core, long max_unique_ids_per_sparse_core, string table_name, float clip_weight_min = Single.NegativeInfinity, float clip_weight_max = Single.PositiveInfinity, String opName = "XlaSparseDenseMatmulGradWithAdagradAndStaticBufferSize") 
        {
            OperationDescription desc = NewOperation("XlaSparseDenseMatmulGradWithAdagradAndStaticBufferSize", opName);
            desc.AddInput(row_pointers);
            desc.AddInput(sorted_sample_ids);
            desc.AddInput(sorted_token_ids);
            desc.AddInput(sorted_gains);
            desc.AddInput(activation_gradients);
            desc.AddInput(learning_rate);
            desc.AddInput(embedding_table);
            desc.AddInput(accumulator);
            desc.AddInput(num_minibatches_per_physical_sparse_core);
            desc.SetAttr("max_ids_per_sparse_core", max_ids_per_sparse_core);
            desc.SetAttr("max_unique_ids_per_sparse_core", max_unique_ids_per_sparse_core);
            desc.SetAttr("table_name", table_name);
            if (clip_weight_min != Single.NegativeInfinity)
                desc.SetAttr("clip_weight_min", clip_weight_min);
            if (clip_weight_max != Single.PositiveInfinity)
                desc.SetAttr("clip_weight_max", clip_weight_max);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaSparseDenseMatmulGradWithAdagradMomentumAndCsrInput
        /// </summary>
        /// <param name="row_pointers">Input to the operation. </param>
        /// <param name="sorted_sample_ids">Input to the operation. </param>
        /// <param name="sorted_token_ids">Input to the operation. </param>
        /// <param name="sorted_gains">Input to the operation. </param>
        /// <param name="activation_gradients">Input to the operation. </param>
        /// <param name="learning_rate">Input to the operation. </param>
        /// <param name="embedding_table">Input to the operation. </param>
        /// <param name="accumulator">Input to the operation. </param>
        /// <param name="momenta">Input to the operation. </param>
        /// <param name="num_minibatches_per_physical_sparse_core">Input to the operation. </param>
        /// <param name="use_nesterov">use nesterov</param>
        /// <param name="exponent">exponent</param>
        /// <param name="beta1">beta1</param>
        /// <param name="beta2">beta2</param>
        /// <param name="epsilon">epsilon</param>
        /// <param name="table_name">table name</param>
        /// <param name="clip_weight_min">clip weight min</param>
        /// <param name="clip_weight_max">clip weight max</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] updated_embedding_table(type: DtFloat).
        /// [1] updated_accumulator(type: DtFloat).
        /// [2] updated_momenta(type: DtFloat).
        /// </returns>
        public Operation XlaSparseDenseMatmulGradWithAdagradMomentumAndCsrInput(Output row_pointers, Output sorted_sample_ids, Output sorted_token_ids, Output sorted_gains, Output activation_gradients, Output learning_rate, Output embedding_table, Output accumulator, Output momenta, Output num_minibatches_per_physical_sparse_core, bool use_nesterov, float exponent, float beta1, float beta2, float epsilon, string table_name, float clip_weight_min = Single.NegativeInfinity, float clip_weight_max = Single.PositiveInfinity, String opName = "XlaSparseDenseMatmulGradWithAdagradMomentumAndCsrInput") 
        {
            OperationDescription desc = NewOperation("XlaSparseDenseMatmulGradWithAdagradMomentumAndCsrInput", opName);
            desc.AddInput(row_pointers);
            desc.AddInput(sorted_sample_ids);
            desc.AddInput(sorted_token_ids);
            desc.AddInput(sorted_gains);
            desc.AddInput(activation_gradients);
            desc.AddInput(learning_rate);
            desc.AddInput(embedding_table);
            desc.AddInput(accumulator);
            desc.AddInput(momenta);
            desc.AddInput(num_minibatches_per_physical_sparse_core);
            desc.SetAttr("use_nesterov", use_nesterov);
            desc.SetAttr("exponent", exponent);
            desc.SetAttr("beta1", beta1);
            desc.SetAttr("beta2", beta2);
            desc.SetAttr("epsilon", epsilon);
            desc.SetAttr("table_name", table_name);
            if (clip_weight_min != Single.NegativeInfinity)
                desc.SetAttr("clip_weight_min", clip_weight_min);
            if (clip_weight_max != Single.PositiveInfinity)
                desc.SetAttr("clip_weight_max", clip_weight_max);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaSparseDenseMatmulGradWithAdagradMomentumAndStaticBufferSize
        /// </summary>
        /// <param name="row_pointers">Input to the operation. </param>
        /// <param name="sorted_sample_ids">Input to the operation. </param>
        /// <param name="sorted_token_ids">Input to the operation. </param>
        /// <param name="sorted_gains">Input to the operation. </param>
        /// <param name="activation_gradients">Input to the operation. </param>
        /// <param name="learning_rate">Input to the operation. </param>
        /// <param name="embedding_table">Input to the operation. </param>
        /// <param name="accumulator">Input to the operation. </param>
        /// <param name="momenta">Input to the operation. </param>
        /// <param name="num_minibatches_per_physical_sparse_core">Input to the operation. </param>
        /// <param name="use_nesterov">use nesterov</param>
        /// <param name="exponent">exponent</param>
        /// <param name="beta1">beta1</param>
        /// <param name="beta2">beta2</param>
        /// <param name="epsilon">epsilon</param>
        /// <param name="max_ids_per_sparse_core">max ids per sparse core</param>
        /// <param name="max_unique_ids_per_sparse_core">max unique ids per sparse core</param>
        /// <param name="table_name">table name</param>
        /// <param name="clip_weight_min">clip weight min</param>
        /// <param name="clip_weight_max">clip weight max</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] updated_embedding_table(type: DtFloat).
        /// [1] updated_accumulator(type: DtFloat).
        /// [2] updated_momenta(type: DtFloat).
        /// </returns>
        public Operation XlaSparseDenseMatmulGradWithAdagradMomentumAndStaticBufferSize(Output row_pointers, Output sorted_sample_ids, Output sorted_token_ids, Output sorted_gains, Output activation_gradients, Output learning_rate, Output embedding_table, Output accumulator, Output momenta, Output num_minibatches_per_physical_sparse_core, bool use_nesterov, float exponent, float beta1, float beta2, float epsilon, long max_ids_per_sparse_core, long max_unique_ids_per_sparse_core, string table_name, float clip_weight_min = Single.NegativeInfinity, float clip_weight_max = Single.PositiveInfinity, String opName = "XlaSparseDenseMatmulGradWithAdagradMomentumAndStaticBufferSize") 
        {
            OperationDescription desc = NewOperation("XlaSparseDenseMatmulGradWithAdagradMomentumAndStaticBufferSize", opName);
            desc.AddInput(row_pointers);
            desc.AddInput(sorted_sample_ids);
            desc.AddInput(sorted_token_ids);
            desc.AddInput(sorted_gains);
            desc.AddInput(activation_gradients);
            desc.AddInput(learning_rate);
            desc.AddInput(embedding_table);
            desc.AddInput(accumulator);
            desc.AddInput(momenta);
            desc.AddInput(num_minibatches_per_physical_sparse_core);
            desc.SetAttr("use_nesterov", use_nesterov);
            desc.SetAttr("exponent", exponent);
            desc.SetAttr("beta1", beta1);
            desc.SetAttr("beta2", beta2);
            desc.SetAttr("epsilon", epsilon);
            desc.SetAttr("max_ids_per_sparse_core", max_ids_per_sparse_core);
            desc.SetAttr("max_unique_ids_per_sparse_core", max_unique_ids_per_sparse_core);
            desc.SetAttr("table_name", table_name);
            if (clip_weight_min != Single.NegativeInfinity)
                desc.SetAttr("clip_weight_min", clip_weight_min);
            if (clip_weight_max != Single.PositiveInfinity)
                desc.SetAttr("clip_weight_max", clip_weight_max);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaSparseDenseMatmulGradWithAdamAndCsrInput
        /// </summary>
        /// <param name="row_pointers">Input to the operation. </param>
        /// <param name="sorted_sample_ids">Input to the operation. </param>
        /// <param name="sorted_token_ids">Input to the operation. </param>
        /// <param name="sorted_gains">Input to the operation. </param>
        /// <param name="activation_gradients">Input to the operation. </param>
        /// <param name="learning_rate">Input to the operation. </param>
        /// <param name="embedding_table">Input to the operation. </param>
        /// <param name="momenta">Input to the operation. </param>
        /// <param name="velocity">Input to the operation. </param>
        /// <param name="num_minibatches_per_physical_sparse_core">Input to the operation. </param>
        /// <param name="use_sum_inside_sqrt">use sum inside sqrt</param>
        /// <param name="beta1">beta1</param>
        /// <param name="beta2">beta2</param>
        /// <param name="epsilon">epsilon</param>
        /// <param name="table_name">table name</param>
        /// <param name="clip_weight_min">clip weight min</param>
        /// <param name="clip_weight_max">clip weight max</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] updated_embedding_table(type: DtFloat).
        /// [1] updated_momenta(type: DtFloat).
        /// [2] updated_velocity(type: DtFloat).
        /// </returns>
        public Operation XlaSparseDenseMatmulGradWithAdamAndCsrInput(Output row_pointers, Output sorted_sample_ids, Output sorted_token_ids, Output sorted_gains, Output activation_gradients, Output learning_rate, Output embedding_table, Output momenta, Output velocity, Output num_minibatches_per_physical_sparse_core, bool use_sum_inside_sqrt, float beta1, float beta2, float epsilon, string table_name, float clip_weight_min = Single.NegativeInfinity, float clip_weight_max = Single.PositiveInfinity, String opName = "XlaSparseDenseMatmulGradWithAdamAndCsrInput") 
        {
            OperationDescription desc = NewOperation("XlaSparseDenseMatmulGradWithAdamAndCsrInput", opName);
            desc.AddInput(row_pointers);
            desc.AddInput(sorted_sample_ids);
            desc.AddInput(sorted_token_ids);
            desc.AddInput(sorted_gains);
            desc.AddInput(activation_gradients);
            desc.AddInput(learning_rate);
            desc.AddInput(embedding_table);
            desc.AddInput(momenta);
            desc.AddInput(velocity);
            desc.AddInput(num_minibatches_per_physical_sparse_core);
            desc.SetAttr("use_sum_inside_sqrt", use_sum_inside_sqrt);
            desc.SetAttr("beta1", beta1);
            desc.SetAttr("beta2", beta2);
            desc.SetAttr("epsilon", epsilon);
            desc.SetAttr("table_name", table_name);
            if (clip_weight_min != Single.NegativeInfinity)
                desc.SetAttr("clip_weight_min", clip_weight_min);
            if (clip_weight_max != Single.PositiveInfinity)
                desc.SetAttr("clip_weight_max", clip_weight_max);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaSparseDenseMatmulGradWithAdamAndStaticBufferSize
        /// </summary>
        /// <param name="row_pointers">Input to the operation. </param>
        /// <param name="sorted_sample_ids">Input to the operation. </param>
        /// <param name="sorted_token_ids">Input to the operation. </param>
        /// <param name="sorted_gains">Input to the operation. </param>
        /// <param name="activation_gradients">Input to the operation. </param>
        /// <param name="learning_rate">Input to the operation. </param>
        /// <param name="embedding_table">Input to the operation. </param>
        /// <param name="momenta">Input to the operation. </param>
        /// <param name="velocity">Input to the operation. </param>
        /// <param name="num_minibatches_per_physical_sparse_core">Input to the operation. </param>
        /// <param name="use_sum_inside_sqrt">use sum inside sqrt</param>
        /// <param name="beta1">beta1</param>
        /// <param name="beta2">beta2</param>
        /// <param name="epsilon">epsilon</param>
        /// <param name="max_ids_per_sparse_core">max ids per sparse core</param>
        /// <param name="max_unique_ids_per_sparse_core">max unique ids per sparse core</param>
        /// <param name="table_name">table name</param>
        /// <param name="clip_weight_min">clip weight min</param>
        /// <param name="clip_weight_max">clip weight max</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] updated_embedding_table(type: DtFloat).
        /// [1] updated_momenta(type: DtFloat).
        /// [2] updated_velocity(type: DtFloat).
        /// </returns>
        public Operation XlaSparseDenseMatmulGradWithAdamAndStaticBufferSize(Output row_pointers, Output sorted_sample_ids, Output sorted_token_ids, Output sorted_gains, Output activation_gradients, Output learning_rate, Output embedding_table, Output momenta, Output velocity, Output num_minibatches_per_physical_sparse_core, bool use_sum_inside_sqrt, float beta1, float beta2, float epsilon, long max_ids_per_sparse_core, long max_unique_ids_per_sparse_core, string table_name, float clip_weight_min = Single.NegativeInfinity, float clip_weight_max = Single.PositiveInfinity, String opName = "XlaSparseDenseMatmulGradWithAdamAndStaticBufferSize") 
        {
            OperationDescription desc = NewOperation("XlaSparseDenseMatmulGradWithAdamAndStaticBufferSize", opName);
            desc.AddInput(row_pointers);
            desc.AddInput(sorted_sample_ids);
            desc.AddInput(sorted_token_ids);
            desc.AddInput(sorted_gains);
            desc.AddInput(activation_gradients);
            desc.AddInput(learning_rate);
            desc.AddInput(embedding_table);
            desc.AddInput(momenta);
            desc.AddInput(velocity);
            desc.AddInput(num_minibatches_per_physical_sparse_core);
            desc.SetAttr("use_sum_inside_sqrt", use_sum_inside_sqrt);
            desc.SetAttr("beta1", beta1);
            desc.SetAttr("beta2", beta2);
            desc.SetAttr("epsilon", epsilon);
            desc.SetAttr("max_ids_per_sparse_core", max_ids_per_sparse_core);
            desc.SetAttr("max_unique_ids_per_sparse_core", max_unique_ids_per_sparse_core);
            desc.SetAttr("table_name", table_name);
            if (clip_weight_min != Single.NegativeInfinity)
                desc.SetAttr("clip_weight_min", clip_weight_min);
            if (clip_weight_max != Single.PositiveInfinity)
                desc.SetAttr("clip_weight_max", clip_weight_max);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaSparseDenseMatmulGradWithFtrlAndCsrInput
        /// </summary>
        /// <param name="row_pointers">Input to the operation. </param>
        /// <param name="sorted_sample_ids">Input to the operation. </param>
        /// <param name="sorted_token_ids">Input to the operation. </param>
        /// <param name="sorted_gains">Input to the operation. </param>
        /// <param name="activation_gradients">Input to the operation. </param>
        /// <param name="learning_rate">Input to the operation. </param>
        /// <param name="embedding_table">Input to the operation. </param>
        /// <param name="accumulator">Input to the operation. </param>
        /// <param name="linear">Input to the operation. </param>
        /// <param name="num_minibatches_per_physical_sparse_core">Input to the operation. </param>
        /// <param name="multiply_linear_by_learning_rate">multiply linear by learning rate</param>
        /// <param name="beta">beta</param>
        /// <param name="learning_rate_power">learning rate power</param>
        /// <param name="l1_regularization_strength">l1 regularization strength</param>
        /// <param name="l2_regularization_strength">l2 regularization strength</param>
        /// <param name="table_name">table name</param>
        /// <param name="clip_weight_min">clip weight min</param>
        /// <param name="clip_weight_max">clip weight max</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] updated_embedding_table(type: DtFloat).
        /// [1] updated_accumulator(type: DtFloat).
        /// [2] updated_linear(type: DtFloat).
        /// </returns>
        public Operation XlaSparseDenseMatmulGradWithFtrlAndCsrInput(Output row_pointers, Output sorted_sample_ids, Output sorted_token_ids, Output sorted_gains, Output activation_gradients, Output learning_rate, Output embedding_table, Output accumulator, Output linear, Output num_minibatches_per_physical_sparse_core, bool multiply_linear_by_learning_rate, float beta, float learning_rate_power, float l1_regularization_strength, float l2_regularization_strength, string table_name, float clip_weight_min = Single.NegativeInfinity, float clip_weight_max = Single.PositiveInfinity, String opName = "XlaSparseDenseMatmulGradWithFtrlAndCsrInput") 
        {
            OperationDescription desc = NewOperation("XlaSparseDenseMatmulGradWithFtrlAndCsrInput", opName);
            desc.AddInput(row_pointers);
            desc.AddInput(sorted_sample_ids);
            desc.AddInput(sorted_token_ids);
            desc.AddInput(sorted_gains);
            desc.AddInput(activation_gradients);
            desc.AddInput(learning_rate);
            desc.AddInput(embedding_table);
            desc.AddInput(accumulator);
            desc.AddInput(linear);
            desc.AddInput(num_minibatches_per_physical_sparse_core);
            desc.SetAttr("multiply_linear_by_learning_rate", multiply_linear_by_learning_rate);
            desc.SetAttr("beta", beta);
            desc.SetAttr("learning_rate_power", learning_rate_power);
            desc.SetAttr("l1_regularization_strength", l1_regularization_strength);
            desc.SetAttr("l2_regularization_strength", l2_regularization_strength);
            desc.SetAttr("table_name", table_name);
            if (clip_weight_min != Single.NegativeInfinity)
                desc.SetAttr("clip_weight_min", clip_weight_min);
            if (clip_weight_max != Single.PositiveInfinity)
                desc.SetAttr("clip_weight_max", clip_weight_max);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaSparseDenseMatmulGradWithFtrlAndStaticBufferSize
        /// </summary>
        /// <param name="row_pointers">Input to the operation. </param>
        /// <param name="sorted_sample_ids">Input to the operation. </param>
        /// <param name="sorted_token_ids">Input to the operation. </param>
        /// <param name="sorted_gains">Input to the operation. </param>
        /// <param name="activation_gradients">Input to the operation. </param>
        /// <param name="learning_rate">Input to the operation. </param>
        /// <param name="embedding_table">Input to the operation. </param>
        /// <param name="accumulator">Input to the operation. </param>
        /// <param name="linear">Input to the operation. </param>
        /// <param name="num_minibatches_per_physical_sparse_core">Input to the operation. </param>
        /// <param name="multiply_linear_by_learning_rate">multiply linear by learning rate</param>
        /// <param name="beta">beta</param>
        /// <param name="learning_rate_power">learning rate power</param>
        /// <param name="l1_regularization_strength">l1 regularization strength</param>
        /// <param name="l2_regularization_strength">l2 regularization strength</param>
        /// <param name="max_ids_per_sparse_core">max ids per sparse core</param>
        /// <param name="max_unique_ids_per_sparse_core">max unique ids per sparse core</param>
        /// <param name="table_name">table name</param>
        /// <param name="clip_weight_min">clip weight min</param>
        /// <param name="clip_weight_max">clip weight max</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] updated_embedding_table(type: DtFloat).
        /// [1] updated_accumulator(type: DtFloat).
        /// [2] updated_linear(type: DtFloat).
        /// </returns>
        public Operation XlaSparseDenseMatmulGradWithFtrlAndStaticBufferSize(Output row_pointers, Output sorted_sample_ids, Output sorted_token_ids, Output sorted_gains, Output activation_gradients, Output learning_rate, Output embedding_table, Output accumulator, Output linear, Output num_minibatches_per_physical_sparse_core, bool multiply_linear_by_learning_rate, float beta, float learning_rate_power, float l1_regularization_strength, float l2_regularization_strength, long max_ids_per_sparse_core, long max_unique_ids_per_sparse_core, string table_name, float clip_weight_min = Single.NegativeInfinity, float clip_weight_max = Single.PositiveInfinity, String opName = "XlaSparseDenseMatmulGradWithFtrlAndStaticBufferSize") 
        {
            OperationDescription desc = NewOperation("XlaSparseDenseMatmulGradWithFtrlAndStaticBufferSize", opName);
            desc.AddInput(row_pointers);
            desc.AddInput(sorted_sample_ids);
            desc.AddInput(sorted_token_ids);
            desc.AddInput(sorted_gains);
            desc.AddInput(activation_gradients);
            desc.AddInput(learning_rate);
            desc.AddInput(embedding_table);
            desc.AddInput(accumulator);
            desc.AddInput(linear);
            desc.AddInput(num_minibatches_per_physical_sparse_core);
            desc.SetAttr("multiply_linear_by_learning_rate", multiply_linear_by_learning_rate);
            desc.SetAttr("beta", beta);
            desc.SetAttr("learning_rate_power", learning_rate_power);
            desc.SetAttr("l1_regularization_strength", l1_regularization_strength);
            desc.SetAttr("l2_regularization_strength", l2_regularization_strength);
            desc.SetAttr("max_ids_per_sparse_core", max_ids_per_sparse_core);
            desc.SetAttr("max_unique_ids_per_sparse_core", max_unique_ids_per_sparse_core);
            desc.SetAttr("table_name", table_name);
            if (clip_weight_min != Single.NegativeInfinity)
                desc.SetAttr("clip_weight_min", clip_weight_min);
            if (clip_weight_max != Single.PositiveInfinity)
                desc.SetAttr("clip_weight_max", clip_weight_max);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaSparseDenseMatmulGradWithSgdAndCsrInput
        /// </summary>
        /// <param name="row_pointers">Input to the operation. </param>
        /// <param name="sorted_sample_ids">Input to the operation. </param>
        /// <param name="sorted_token_ids">Input to the operation. </param>
        /// <param name="sorted_gains">Input to the operation. </param>
        /// <param name="activation_gradients">Input to the operation. </param>
        /// <param name="learning_rate">Input to the operation. </param>
        /// <param name="embedding_table">Input to the operation. </param>
        /// <param name="num_minibatches_per_physical_sparse_core">Input to the operation. </param>
        /// <param name="table_name">table name</param>
        /// <param name="clip_weight_min">clip weight min</param>
        /// <param name="clip_weight_max">clip weight max</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] updated_embedding_table(type: DtFloat).
        /// </returns>
        public Operation XlaSparseDenseMatmulGradWithSgdAndCsrInput(Output row_pointers, Output sorted_sample_ids, Output sorted_token_ids, Output sorted_gains, Output activation_gradients, Output learning_rate, Output embedding_table, Output num_minibatches_per_physical_sparse_core, string table_name, float clip_weight_min = Single.NegativeInfinity, float clip_weight_max = Single.PositiveInfinity, String opName = "XlaSparseDenseMatmulGradWithSgdAndCsrInput") 
        {
            OperationDescription desc = NewOperation("XlaSparseDenseMatmulGradWithSgdAndCsrInput", opName);
            desc.AddInput(row_pointers);
            desc.AddInput(sorted_sample_ids);
            desc.AddInput(sorted_token_ids);
            desc.AddInput(sorted_gains);
            desc.AddInput(activation_gradients);
            desc.AddInput(learning_rate);
            desc.AddInput(embedding_table);
            desc.AddInput(num_minibatches_per_physical_sparse_core);
            desc.SetAttr("table_name", table_name);
            if (clip_weight_min != Single.NegativeInfinity)
                desc.SetAttr("clip_weight_min", clip_weight_min);
            if (clip_weight_max != Single.PositiveInfinity)
                desc.SetAttr("clip_weight_max", clip_weight_max);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaSparseDenseMatmulGradWithSgdAndStaticBufferSize
        /// </summary>
        /// <param name="row_pointers">Input to the operation. </param>
        /// <param name="sorted_sample_ids">Input to the operation. </param>
        /// <param name="sorted_token_ids">Input to the operation. </param>
        /// <param name="sorted_gains">Input to the operation. </param>
        /// <param name="activation_gradients">Input to the operation. </param>
        /// <param name="learning_rate">Input to the operation. </param>
        /// <param name="embedding_table">Input to the operation. </param>
        /// <param name="num_minibatches_per_physical_sparse_core">Input to the operation. </param>
        /// <param name="max_ids_per_sparse_core">max ids per sparse core</param>
        /// <param name="max_unique_ids_per_sparse_core">max unique ids per sparse core</param>
        /// <param name="table_name">table name</param>
        /// <param name="clip_weight_min">clip weight min</param>
        /// <param name="clip_weight_max">clip weight max</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] updated_embedding_table(type: DtFloat).
        /// </returns>
        public Operation XlaSparseDenseMatmulGradWithSgdAndStaticBufferSize(Output row_pointers, Output sorted_sample_ids, Output sorted_token_ids, Output sorted_gains, Output activation_gradients, Output learning_rate, Output embedding_table, Output num_minibatches_per_physical_sparse_core, long max_ids_per_sparse_core, long max_unique_ids_per_sparse_core, string table_name, float clip_weight_min = Single.NegativeInfinity, float clip_weight_max = Single.PositiveInfinity, String opName = "XlaSparseDenseMatmulGradWithSgdAndStaticBufferSize") 
        {
            OperationDescription desc = NewOperation("XlaSparseDenseMatmulGradWithSgdAndStaticBufferSize", opName);
            desc.AddInput(row_pointers);
            desc.AddInput(sorted_sample_ids);
            desc.AddInput(sorted_token_ids);
            desc.AddInput(sorted_gains);
            desc.AddInput(activation_gradients);
            desc.AddInput(learning_rate);
            desc.AddInput(embedding_table);
            desc.AddInput(num_minibatches_per_physical_sparse_core);
            desc.SetAttr("max_ids_per_sparse_core", max_ids_per_sparse_core);
            desc.SetAttr("max_unique_ids_per_sparse_core", max_unique_ids_per_sparse_core);
            desc.SetAttr("table_name", table_name);
            if (clip_weight_min != Single.NegativeInfinity)
                desc.SetAttr("clip_weight_min", clip_weight_min);
            if (clip_weight_max != Single.PositiveInfinity)
                desc.SetAttr("clip_weight_max", clip_weight_max);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaSparseDenseMatmulWithCsrInput
        /// </summary>
        /// <param name="row_pointers">Input to the operation. </param>
        /// <param name="sorted_sample_ids">Input to the operation. </param>
        /// <param name="sorted_token_ids">Input to the operation. </param>
        /// <param name="sorted_gains">Input to the operation. </param>
        /// <param name="embedding_table">Input to the operation. </param>
        /// <param name="num_minibatches_per_physical_sparse_core">Input to the operation. </param>
        /// <param name="input_size">input size</param>
        /// <param name="quantization_config_low">quantization config low</param>
        /// <param name="quantization_config_high">quantization config high</param>
        /// <param name="quantization_config_num_buckets">quantization config num buckets</param>
        /// <param name="table_name">table name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] activations(type: DtFloat).
        /// </returns>
        public Operation XlaSparseDenseMatmulWithCsrInput(Output row_pointers, Output sorted_sample_ids, Output sorted_token_ids, Output sorted_gains, Output embedding_table, Output num_minibatches_per_physical_sparse_core, long input_size, float quantization_config_low, float quantization_config_high, long quantization_config_num_buckets, string table_name, String opName = "XlaSparseDenseMatmulWithCsrInput") 
        {
            OperationDescription desc = NewOperation("XlaSparseDenseMatmulWithCsrInput", opName);
            desc.AddInput(row_pointers);
            desc.AddInput(sorted_sample_ids);
            desc.AddInput(sorted_token_ids);
            desc.AddInput(sorted_gains);
            desc.AddInput(embedding_table);
            desc.AddInput(num_minibatches_per_physical_sparse_core);
            desc.SetAttr("input_size", input_size);
            desc.SetAttr("quantization_config_low", quantization_config_low);
            desc.SetAttr("quantization_config_high", quantization_config_high);
            desc.SetAttr("quantization_config_num_buckets", quantization_config_num_buckets);
            desc.SetAttr("table_name", table_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaSparseDenseMatmulWithStaticBufferSize
        /// </summary>
        /// <param name="row_pointers">Input to the operation. </param>
        /// <param name="sorted_sample_ids">Input to the operation. </param>
        /// <param name="sorted_token_ids">Input to the operation. </param>
        /// <param name="sorted_gains">Input to the operation. </param>
        /// <param name="embedding_table">Input to the operation. </param>
        /// <param name="num_minibatches_per_physical_sparse_core">Input to the operation. </param>
        /// <param name="input_size">input size</param>
        /// <param name="quantization_config_low">quantization config low</param>
        /// <param name="quantization_config_high">quantization config high</param>
        /// <param name="quantization_config_num_buckets">quantization config num buckets</param>
        /// <param name="max_ids_per_sparse_core">max ids per sparse core</param>
        /// <param name="max_unique_ids_per_sparse_core">max unique ids per sparse core</param>
        /// <param name="table_name">table name</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] activations(type: DtFloat).
        /// </returns>
        public Operation XlaSparseDenseMatmulWithStaticBufferSize(Output row_pointers, Output sorted_sample_ids, Output sorted_token_ids, Output sorted_gains, Output embedding_table, Output num_minibatches_per_physical_sparse_core, long input_size, float quantization_config_low, float quantization_config_high, long quantization_config_num_buckets, long max_ids_per_sparse_core, long max_unique_ids_per_sparse_core, string table_name, String opName = "XlaSparseDenseMatmulWithStaticBufferSize") 
        {
            OperationDescription desc = NewOperation("XlaSparseDenseMatmulWithStaticBufferSize", opName);
            desc.AddInput(row_pointers);
            desc.AddInput(sorted_sample_ids);
            desc.AddInput(sorted_token_ids);
            desc.AddInput(sorted_gains);
            desc.AddInput(embedding_table);
            desc.AddInput(num_minibatches_per_physical_sparse_core);
            desc.SetAttr("input_size", input_size);
            desc.SetAttr("quantization_config_low", quantization_config_low);
            desc.SetAttr("quantization_config_high", quantization_config_high);
            desc.SetAttr("quantization_config_num_buckets", quantization_config_num_buckets);
            desc.SetAttr("max_ids_per_sparse_core", max_ids_per_sparse_core);
            desc.SetAttr("max_unique_ids_per_sparse_core", max_unique_ids_per_sparse_core);
            desc.SetAttr("table_name", table_name);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// XlaSplitND
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="N">N</param>
        /// <param name="num_splits">num splits</param>
        /// <param name="paddings">paddings</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] outputs(type: DtInvalid).
        /// </returns>
        public Operation XlaSplitND(Output input, long N, long[] num_splits, long[] paddings = null, String opName = "XlaSplitND") 
        {
            OperationDescription desc = NewOperation("XlaSplitND", opName);
            desc.AddInput(input);
            desc.SetAttr("N", N);
            desc.SetAttr("num_splits", num_splits);
            if (paddings != null) desc.SetAttr("paddings", paddings);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// An op used by XLA SPMD partitioner to switch from automatic partitioning to
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="manual_sharding">manual sharding</param>
        /// <param name="dim">dim</param>
        /// <param name="unspecified_dims">unspecified dims</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation XlaSpmdFullToShardShape(Output input, string manual_sharding, long dim = -1, long[] unspecified_dims = null, String opName = "XlaSpmdFullToShardShape") 
        {
            OperationDescription desc = NewOperation("XlaSpmdFullToShardShape", opName);
            desc.AddInput(input);
            desc.SetAttr("manual_sharding", manual_sharding);
            if (dim != -1)
                desc.SetAttr("dim", dim);
            if (unspecified_dims != null) desc.SetAttr("unspecified_dims", unspecified_dims);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// An op used by XLA SPMD partitioner to switch from manual partitioning to
        /// </summary>
        /// <param name="input">Input to the operation. </param>
        /// <param name="manual_sharding">manual sharding</param>
        /// <param name="full_shape">full shape</param>
        /// <param name="dim">dim</param>
        /// <param name="unspecified_dims">unspecified dims</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        public Operation XlaSpmdShardToFullShape(Output input, string manual_sharding, long[] full_shape, long dim = -1, long[] unspecified_dims = null, String opName = "XlaSpmdShardToFullShape") 
        {
            OperationDescription desc = NewOperation("XlaSpmdShardToFullShape", opName);
            desc.AddInput(input);
            desc.SetAttr("manual_sharding", manual_sharding);
            desc.SetAttrShape("full_shape", full_shape);
            if (dim != -1)
                desc.SetAttr("dim", dim);
            if (unspecified_dims != null) desc.SetAttr("unspecified_dims", unspecified_dims);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Computes the eigen decomposition of a batch of self-adjoint matrices
        /// </summary>
        /// <param name="a">Input to the operation: the input tensor.</param>
        /// <param name="max_iter">maximum number of sweep update, i.e., the whole lower triangular part or upper triangular part based on parameter lower. Heuristically, it has been argued that approximately log(min (M, N)) sweeps are needed in practice (Ref: Golub &amp; van Loan "Matrix Computation").</param>
        /// <param name="epsilon">the tolerance ratio.</param>
        /// <param name="precision_config">a serialized xla::PrecisionConfig proto.</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] s(type: DtInvalid): Singular values. The values are sorted in reverse order of magnitude, so s[..., 0] is the largest value, s[..., 1] is the second largest, etc.
        /// [1] u(type: DtInvalid): Left singular vectors.
        /// [2] v(type: DtInvalid): Right singular vectors.
        /// </returns>
        public Operation XlaSvd(Output a, long max_iter, float epsilon, string precision_config, String opName = "XlaSvd") 
        {
            OperationDescription desc = NewOperation("XlaSvd", opName);
            desc.AddInput(a);
            desc.SetAttr("max_iter", max_iter);
            desc.SetAttr("epsilon", epsilon);
            desc.SetAttr("precision_config", precision_config);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Wraps the variadic XLA Reduce operator.
        /// </summary>
        /// <param name="input">Input to the operation: the input tensor(s)</param>
        /// <param name="init_value">Input to the operation: scalar initial value(s) for the reduction</param>
        /// <param name="dimensions_to_reduce">dimension numbers over which to reduce</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid).
        /// </returns>
        // The following attributes are not known: reducer: func
        public Operation XlaVariadicReduce(Output input, Output init_value, long[] dimensions_to_reduce, String opName = "XlaVariadicReduce") 
        {
            OperationDescription desc = NewOperation("XlaVariadicReduce", opName);
            desc.AddInput(input);
            desc.AddInput(init_value);
            desc.SetAttr("dimensions_to_reduce", dimensions_to_reduce);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Wraps the variadic XLA Reduce operator.
        /// </summary>
        /// <param name="inputs">Input to the operation: the input tensor(s)</param>
        /// <param name="init_values">Input to the operation: scalar initial value(s) for the reduction</param>
        /// <param name="dimensions_to_reduce">dimension numbers over which to reduce</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] outputs(type: DtInvalid).
        /// </returns>
        // The following attributes are not known: reducer: func
        public Operation XlaVariadicReduceV2(Output inputs, Output init_values, long[] dimensions_to_reduce, String opName = "XlaVariadicReduceV2") 
        {
            OperationDescription desc = NewOperation("XlaVariadicReduceV2", opName);
            desc.AddInput(inputs);
            desc.AddInput(init_values);
            desc.SetAttr("dimensions_to_reduce", dimensions_to_reduce);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Wraps the XLA Sort operator, documented at
        /// </summary>
        /// <param name="inputs">Input to the operation: A list of `Tensor` of identical shape but possibly different types.</param>
        /// <param name="dimension">Input to the operation: The dimension along which to sort. Must be a compile-time constant.</param>
        /// <param name="is_stable">Whether to use stable sort.</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] outputs(type: DtInvalid): A list of `Tensor` of same shape and types as the `input`.
        /// </returns>
        // The following attributes are not known: comparator: func
        public Operation XlaVariadicSort(Output inputs, Output dimension, bool is_stable, String opName = "XlaVariadicSort") 
        {
            OperationDescription desc = NewOperation("XlaVariadicSort", opName);
            desc.AddInput(inputs);
            desc.AddInput(dimension);
            desc.SetAttr("is_stable", is_stable);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// output = input; While (Cond(output)) { output = Body(output) }
        /// </summary>
        /// <param name="input">Input to the operation: A list of input tensors whose types are T.</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] output(type: DtInvalid): A list of output tensors whose types are T.
        /// </returns>
        // The following attributes are not known: cond: func; body: func
        public Operation XlaWhile(Output input, String opName = "XlaWhile") 
        {
            OperationDescription desc = NewOperation("XlaWhile", opName);
            desc.AddInput(input);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Xlog1py
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation Xlog1py(Output x, Output y, String opName = "Xlog1py") 
        {
            OperationDescription desc = NewOperation("Xlog1py", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Xlogy
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="y">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation Xlogy(Output x, Output y, String opName = "Xlogy") 
        {
            OperationDescription desc = NewOperation("Xlogy", opName);
            desc.AddInput(x);
            desc.AddInput(y);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ZerosLike
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] y(type: DtInvalid).
        /// </returns>
        public Operation ZerosLike(Output x, String opName = "ZerosLike") 
        {
            OperationDescription desc = NewOperation("ZerosLike", opName);
            desc.AddInput(x);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// Zeta
        /// </summary>
        /// <param name="x">Input to the operation. </param>
        /// <param name="q">Input to the operation. </param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] z(type: DtInvalid).
        /// </returns>
        public Operation Zeta(Output x, Output q, String opName = "Zeta") 
        {
            OperationDescription desc = NewOperation("Zeta", opName);
            desc.AddInput(x);
            desc.AddInput(q);
            return desc.FinishOperation();
        } 

        /// <summary>
        /// ZipDataset
        /// </summary>
        /// <param name="input_datasets">Input to the operation. </param>
        /// <param name="output_types">output types</param>
        /// <param name="output_shapes">output shapes</param>
        /// <param name="metadata">metadata</param>
        /// <param name="opName">The name of the operation</param>
        /// <returns>
        /// The operation, where:
        /// [0] handle(type: DtVariant).
        /// </returns>
        public Operation ZipDataset(Output input_datasets, DataType[] output_types, long[][] output_shapes, string metadata = null, String opName = "ZipDataset") 
        {
            OperationDescription desc = NewOperation("ZipDataset", opName);
            desc.AddInput(input_datasets);
            desc.SetAttr("output_types", output_types);
            desc.SetAttrShapeList("output_shapes", output_shapes);
            if (metadata != null)
                 desc.SetAttr("metadata", metadata);
            return desc.FinishOperation();
        } 
   }
}